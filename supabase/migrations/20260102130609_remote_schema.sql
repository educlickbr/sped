create extension if not exists "http" with schema "extensions";


create extension if not exists "unaccent" with schema "public" version '1.1';

create type "public"."altura_coluna_tipo" as enum ('simples', 'alta');

create type "public"."bloco_pergunta" as enum ('dados_pessoais', 'responsavel_legal', 'dados_socio_economicos', 'pcd', 'endereco', 'documentos', 'aceite', 'sobre_curso', 'prontidao');

create type "public"."escopo_processo" as enum ('global', 'area', 'curso', 'turma');

create type "public"."largura_coluna_tipo" as enum ('simples', 'dupla');

create type "public"."modalidade_curso" as enum ('presencial', 'online');

create type "public"."sim_nao" as enum ('Sim', 'Não');

create type "public"."status_item" as enum ('disponível', 'reservado', 'manutenção', 'descartado');

create type "public"."status_matricula" as enum ('Ativa', 'Cancelada', 'Trancamento', 'Anulada');

create type "public"."status_presenca" as enum ('presente', 'falta', 'abonada', 'justificada');

create type "public"."status_reparo" as enum ('Não se Aplica', 'Pendente', 'Em Reparo', 'Reparado');

create type "public"."status_reserva" as enum ('reservado', 'retirado', 'devolvido', 'atrasado', 'cancelado');

create type "public"."status_sync" as enum ('pendente', 'iniciado', 'concluido', 'ignorado', 'erro');

create type "public"."tipo_area" as enum ('regulares', 'extensao', 'cursos_livres', 'eventos_editais', 'jornadas');

create type "public"."tipo_candidatura" as enum ('estudante', 'docente', 'jornadas', 'mesas', 'outros');

create type "public"."tipo_processo" as enum ('seletivo', 'matricula');

create type "public"."tipo_reserva_calendario" as enum ('evento', 'curso');

create sequence "public"."ra_alunos_id_seq";

create sequence "public"."stg_matriculas_id_seq";

create table "public"."bloco_perguntas" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "bloco" text not null,
    "ordem" bigint generated by default as identity not null,
    "tipo_faixa_etaria" text default 'menor_de_idade'::text,
    "qual_area" text,
    "tipo_processo" text,
    "estudante_docente_evento" text
);


alter table "public"."bloco_perguntas" enable row level security;

create table "public"."curso" (
    "id" uuid not null default gen_random_uuid(),
    "nome_curso" text not null,
    "area" tipo_area not null,
    "modalidade" modalidade_curso not null,
    "cod_curso" text,
    "descricao" text,
    "status" boolean not null default true,
    "qtd_modulos" integer not null default 1,
    "qtd_aulas_modulo" integer not null default 1,
    "qtd_periodos" integer not null default 1,
    "qtd_minutos_periodo" integer not null default 60,
    "qtd_minutos_aula" integer,
    "qtd_minutos_modulo" integer,
    "qtd_minutos_total" integer,
    "padrao_encontros" boolean not null default true,
    "criado_em" timestamp with time zone default now(),
    "modificado_em" timestamp with time zone default now(),
    "title_sharepoint" text,
    "id_sharepoint" bigint
);


alter table "public"."curso" enable row level security;

create table "public"."curso_encontros" (
    "id" uuid not null default gen_random_uuid(),
    "id_curso" uuid not null,
    "numero_encontro" integer not null,
    "qtd_periodos" integer not null default 1,
    "duracao_minutos" integer not null,
    "observacao" text,
    "criado_em" timestamp with time zone default now()
);


alter table "public"."curso_encontros" enable row level security;

create table "public"."curso_ficha_avaliacao" (
    "id" uuid not null default gen_random_uuid(),
    "id_curso" uuid not null,
    "pergunta_1" text not null,
    "pergunta_2" text not null,
    "pergunta_3" text not null,
    "rodape" text not null,
    "criado_por" uuid,
    "modificado_por" uuid,
    "criado_em" timestamp with time zone not null default now(),
    "modificado_em" timestamp with time zone not null default now()
);


alter table "public"."curso_ficha_avaliacao" enable row level security;

create table "public"."diario" (
    "id" uuid not null default gen_random_uuid(),
    "id_aluno" uuid not null,
    "id_turma" uuid not null,
    "area" text,
    "id_item_sharepoint" text,
    "justificativa" text,
    "data" timestamp with time zone not null,
    "p1" status_presenca,
    "p2" status_presenca,
    "p3" status_presenca,
    "p4" status_presenca,
    "criado_em" timestamp with time zone default now(),
    "criado_por" uuid,
    "modificado_em" timestamp with time zone default now(),
    "modificado_por" uuid,
    "sync_sharepoint" boolean not null default false,
    "ultima_sync" timestamp with time zone,
    "atualizado" boolean not null default false,
    "provisorio_legado" boolean not null default false,
    "condicao_legado" text,
    "log_legado" text,
    "area_provisorio" text,
    "cod_modulo_provisorio" text,
    "id_sharepoint_correto_provisorio" text,
    "id_sharepoint_correto_encontrado" boolean not null default false,
    "data_recebida_texto" text,
    "id_matricula" uuid
);


alter table "public"."diario" enable row level security;

create table "public"."diario_controle_sync" (
    "id" uuid not null default gen_random_uuid(),
    "id_diario" uuid not null,
    "status" status_sync not null default 'pendente'::status_sync,
    "data" timestamp with time zone not null default now(),
    "reenvio" boolean not null default false,
    "reenvio_realizado" boolean not null default false,
    "status_reenvio" text
);


alter table "public"."diario_controle_sync" enable row level security;

create table "public"."diario_sync_sessao" (
    "id" uuid not null default gen_random_uuid(),
    "in_time" timestamp with time zone not null default now(),
    "status" text not null default 'aberto'::text
);


alter table "public"."diario_sync_sessao" enable row level security;

create table "public"."email_queue" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "id_thread" uuid not null,
    "email_destino" text not null,
    "assunto" text not null,
    "mensagem" text not null,
    "status_fila" text not null default 'aguardando'::text,
    "tentativas" integer not null default 0,
    "data_envio" timestamp with time zone
);


alter table "public"."email_queue" enable row level security;

create table "public"."email_threads" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "assunto" text not null,
    "mensagem" text not null,
    "escopo" text not null,
    "ano_semestre" text,
    "status_thread" text not null default 'pendente'::text,
    "id_turma" uuid,
    "id_user_origem" uuid,
    "id_user_destino" uuid,
    "filtro_area" text
);


alter table "public"."email_threads" enable row level security;

create table "public"."feriados" (
    "id" uuid not null default gen_random_uuid(),
    "data_feriado" timestamp with time zone not null,
    "nome_feriado" text not null,
    "tipo_feriado" text,
    "ano_referencia" integer,
    "ano_semestre_referencia" text,
    "criado_em" timestamp with time zone default now()
);


alter table "public"."feriados" enable row level security;

create table "public"."matriculas" (
    "id" uuid not null default gen_random_uuid(),
    "id_aluno" uuid not null,
    "id_turma" uuid not null,
    "status" status_matricula not null default 'Ativa'::status_matricula,
    "declaracao_matricula" boolean not null default false,
    "data_envio_declaracao" timestamp with time zone,
    "arquivo_declaracao" text,
    "criado_em" timestamp with time zone not null default now(),
    "atualizado_em" timestamp with time zone not null default now(),
    "rematricula" boolean default false
);


alter table "public"."matriculas" enable row level security;

create table "public"."papeis_user" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null
);


alter table "public"."papeis_user" enable row level security;

create table "public"."papeis_user_auth" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "papel_id" uuid not null
);


alter table "public"."papeis_user_auth" enable row level security;

create table "public"."perguntas" (
    "id" uuid not null default gen_random_uuid(),
    "pergunta" text not null,
    "label" text,
    "tipo" text not null,
    "bloco" bloco_pergunta,
    "ordem" smallint
);


alter table "public"."perguntas" enable row level security;

create table "public"."perguntas_avaliacao_processos" (
    "id" uuid not null default gen_random_uuid(),
    "area" tipo_area not null,
    "id_turma" uuid,
    "escopo" text not null,
    "pergunta" text not null,
    "ordem" integer default 1,
    "ativo" boolean default true,
    "criado_por" uuid,
    "criado_em" timestamp with time zone default now(),
    "modificado_por" uuid,
    "modificado_em" timestamp with time zone default now(),
    "tipo" text not null default 'numero'::text,
    "opcoes" jsonb,
    "opcao_default" text
);


alter table "public"."perguntas_avaliacao_processos" enable row level security;

create table "public"."processo_documentos_obrigatorios" (
    "id" uuid not null default gen_random_uuid(),
    "escopo" escopo_processo not null,
    "id_area" tipo_area,
    "id_curso" uuid,
    "id_turma" uuid,
    "id_pergunta" uuid not null,
    "obrigatorio" boolean not null default true,
    "observacoes" text,
    "tipo_processo" tipo_processo not null default 'seletivo'::tipo_processo,
    "bloco" bloco_pergunta,
    "ordem" smallint,
    "leitura" boolean not null default false,
    "tipo_candidatura" tipo_candidatura,
    "largura_coluna" largura_coluna_tipo,
    "altura_coluna" altura_coluna_tipo,
    "largura" integer,
    "altura" integer,
    "depende" boolean not null default false,
    "depende_de" uuid,
    "valor_depende" jsonb,
    "pergunta_gatilho" boolean not null default false,
    "valor_gatilho" text,
    "ordem_bloco" integer
);


alter table "public"."processo_documentos_obrigatorios" enable row level security;

create table "public"."processos" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "turma_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "papel_user" uuid,
    "status" text,
    "user_expandido_id" uuid,
    "tipo_candidatura" tipo_candidatura not null default 'estudante'::tipo_candidatura,
    "modificado_em" timestamp with time zone default now(),
    "modificado_por" uuid,
    "documentos_pendentes" boolean not null default false,
    "envio_email" text not null default 'Aguardando'::text,
    "corrigido" boolean not null default false,
    "envio_whatsapp" text not null default 'Aguardando'::text,
    "tipo_processo" tipo_processo not null default 'seletivo'::tipo_processo,
    "nota_total_processo" bigint
);


alter table "public"."processos" enable row level security;

create table "public"."processos_antigos" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "processo" text,
    "status" boolean default true
);


alter table "public"."processos_antigos" enable row level security;

create table "public"."produto_avarias" (
    "id" uuid not null default gen_random_uuid(),
    "descricao" text not null,
    "observacoes" text,
    "data_entrada_avaria" timestamp with time zone not null default now(),
    "data_estimada_envio_reparo" timestamp with time zone,
    "data_estimada_retorno_reparo" timestamp with time zone,
    "data_retorno_reparo" timestamp with time zone,
    "imagem_avaria" text,
    "id_produto_estoque" uuid not null,
    "id_produto" uuid not null,
    "tipo_avaria" uuid,
    "status_reparo" status_reparo not null default 'Não se Aplica'::status_reparo,
    "data_envio_reparo" timestamp with time zone
);


alter table "public"."produto_avarias" enable row level security;

create table "public"."produto_categoria" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."produto_categoria" enable row level security;

create table "public"."produto_estoque" (
    "id" uuid not null default gen_random_uuid(),
    "id_produto" uuid not null,
    "id_kit" uuid,
    "id_sala" uuid,
    "valor_inicial" integer not null,
    "valor_atual" integer not null,
    "reservas" text,
    "kit" boolean default false,
    "sala" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "status_disponibilidade" boolean not null default true,
    "status_item" status_item not null default 'disponível'::status_item,
    "ordem_disponibilidade" smallint not null default '1'::smallint,
    "teste" numeric
);


alter table "public"."produto_estoque" enable row level security;

create table "public"."produto_kit" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."produto_kit" enable row level security;

create table "public"."produto_reservas" (
    "id" uuid not null default gen_random_uuid(),
    "id_produto" uuid,
    "id_produto_estoque" uuid,
    "id_usuario" uuid,
    "data_reserva" timestamp with time zone default now(),
    "data_retirada" timestamp with time zone,
    "data_devolucao" timestamp with time zone,
    "data_devolvido" timestamp with time zone,
    "status" status_reserva default 'reservado'::status_reserva,
    "id_avaria" uuid,
    "usuario_devolveu" uuid,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "auth_user_id" uuid
);


alter table "public"."produto_reservas" enable row level security;

create table "public"."produto_tipo_avaria" (
    "id" uuid not null default gen_random_uuid(),
    "avaria" text not null
);


alter table "public"."produto_tipo_avaria" enable row level security;

create table "public"."produto_unidade" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "numero" numeric,
    "sufixo" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
);


alter table "public"."produto_unidade" enable row level security;

create table "public"."produtos" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "treshold" integer default 0,
    "codigo_barras" text,
    "observacoes" text,
    "criado_em" timestamp with time zone default now(),
    "atualizado_em" timestamp with time zone default now(),
    "id_tipo_produto" uuid,
    "quantidade" bigint,
    "id_unidade" uuid,
    "valor_inicial" integer not null default 0,
    "imagem_produto" text,
    "mostrar_mais" boolean not null default false,
    "id_categoria_produto" uuid,
    "disponiveis" integer default 0
);


alter table "public"."produtos" enable row level security;

create table "public"."professor_turma_atribuicao" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "id_turmas" uuid not null,
    "status" boolean default true,
    "avaliador" boolean default false,
    "criado_por" uuid,
    "criado_em" timestamp with time zone default timezone('utc'::text, now()),
    "modificado_por" uuid,
    "modificado_em" timestamp with time zone,
    "auth_id" uuid
);


alter table "public"."professor_turma_atribuicao" enable row level security;

create table "public"."ra_alunos" (
    "id" bigint not null default nextval('ra_alunos_id_seq'::regclass),
    "id_aluno" uuid not null,
    "ra" text not null,
    "ra_legado" text,
    "ano_ingresso" character(4) not null,
    "semestre_ingresso" smallint not null,
    "ano_semestre_ingresso" text not null,
    "codigo_lista_ano_semestre" smallint not null,
    "milhar" integer not null default 1,
    "criado_em" timestamp with time zone not null default now(),
    "atualizado_em" timestamp with time zone not null default now()
);


alter table "public"."ra_alunos" enable row level security;

create table "public"."respostas" (
    "id" uuid not null default gen_random_uuid(),
    "id_pergunta" uuid,
    "id_usuario" uuid,
    "resposta" text,
    "tipo_resposta" text default 'texto'::text,
    "criado_em" timestamp without time zone default now(),
    "atualizado_em" timestamp without time zone,
    "arquivo_original" text,
    "user_expandido_id" uuid,
    "aprovado_doc" boolean,
    "aprovado_por" uuid,
    "aprovado_em" timestamp with time zone,
    "motivo_reprovacao_doc" text,
    "id_turma" uuid
);


alter table "public"."respostas" enable row level security;

create table "public"."respostas_conflito_bkp" (
    "id" uuid,
    "id_pergunta" uuid,
    "id_usuario" uuid,
    "resposta" text,
    "tipo_resposta" text,
    "criado_em" timestamp without time zone,
    "atualizado_em" timestamp without time zone,
    "arquivo_original" text,
    "user_expandido_id" uuid,
    "aprovado_doc" boolean,
    "aprovado_por" uuid,
    "aprovado_em" timestamp with time zone,
    "motivo_reprovacao_doc" text,
    "id_turma" uuid,
    "data_arquivamento" timestamp without time zone default now(),
    "turma_destino_tentativa" uuid
);


create table "public"."respostas_conflito_bkp_v2" (
    "id" uuid,
    "id_pergunta" uuid,
    "id_usuario" uuid,
    "resposta" text,
    "tipo_resposta" text,
    "criado_em" timestamp without time zone,
    "atualizado_em" timestamp without time zone,
    "arquivo_original" text,
    "user_expandido_id" uuid,
    "aprovado_doc" boolean,
    "aprovado_por" uuid,
    "aprovado_em" timestamp with time zone,
    "motivo_reprovacao_doc" text,
    "id_turma" uuid,
    "data_arquivamento" timestamp without time zone default now(),
    "turma_destino_tentativa" uuid,
    "motivo_arquivamento" text
);


create table "public"."respostas_perguntas_avaliacao_processos" (
    "id" uuid not null default gen_random_uuid(),
    "id_user" uuid not null,
    "id_pergunta_processo" uuid not null,
    "resposta_texto" text,
    "criado_por" uuid,
    "criado_em" timestamp with time zone default now(),
    "id_processo" uuid
);


alter table "public"."respostas_perguntas_avaliacao_processos" enable row level security;

create table "public"."sala" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "cor" text not null,
    "ordem" smallint
);


alter table "public"."sala" enable row level security;

create table "public"."sala_reservas" (
    "id" uuid not null default gen_random_uuid(),
    "sala_horario_id" uuid not null,
    "data" date not null,
    "status" text not null default 'reservado'::text,
    "observacoes" text,
    "evento" text,
    "turma_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "ano" text,
    "num_semana" integer,
    "tipo" tipo_reserva_calendario default 'evento'::tipo_reserva_calendario,
    "criado_por" uuid,
    "modificado_por" uuid,
    "modificado_em" timestamp with time zone
);


alter table "public"."sala_reservas" enable row level security;

create table "public"."salas_horarios" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "cor" text not null,
    "horario_total" text not null,
    "hora_ini" integer not null,
    "minuto_ini" integer not null,
    "hora_fim" integer not null,
    "minuto_fim" integer not null,
    "turno_cod" text not null,
    "turno_nome" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "indice" integer,
    "id_sala" uuid,
    "id_horario" uuid,
    "ordem_sala" integer
);


alter table "public"."salas_horarios" enable row level security;

create table "public"."slot_horarios" (
    "id" uuid not null default gen_random_uuid(),
    "horario_total" text not null,
    "hora_ini" integer not null,
    "minuto_ini" integer not null,
    "hora_fim" integer not null,
    "minuto_fim" integer not null,
    "turno_cod" text not null,
    "turno_nome" text not null,
    "indice" integer
);


alter table "public"."slot_horarios" enable row level security;

create table "public"."stg_corrigir_ras" (
    "id" uuid not null default gen_random_uuid(),
    "nome_completo_diario" text not null,
    "cod_modulo_diario" text not null,
    "ra_diario" text,
    "matid_diario" bigint,
    "id_aluno_encontrado" uuid,
    "nome_user_expandido" text,
    "sobrenome_user_expandido" text,
    "nome_composto_user_expandido" text,
    "id_ra_aluno" bigint,
    "ra_encontrado" text,
    "ra_legado_encontrado" text,
    "id_matricula_encontrada" uuid,
    "cod_modulo_turma" text,
    "status_match" text,
    "criado_em" timestamp with time zone not null default now(),
    "atualizado_em" timestamp with time zone not null default now(),
    "email" text
);


alter table "public"."stg_corrigir_ras" enable row level security;

create table "public"."stg_cursos" (
    "id" uuid not null default gen_random_uuid(),
    "nome_curso" text,
    "area" text,
    "modalidade" text,
    "cod_curso" text,
    "descricao" text,
    "status" text,
    "qtd_modulos" text,
    "qtd_aulas_modulo" text,
    "qtd_periodos" text,
    "qtd_horas_periodo" text,
    "usar_tabela_encontros" boolean default false,
    "processado" boolean not null default false,
    "erro" boolean not null default false,
    "log_erro" text
);


alter table "public"."stg_cursos" enable row level security;

create table "public"."stg_diario_mesclados" (
    "id" uuid not null default gen_random_uuid(),
    "id_sharepoint" bigint,
    "title" text,
    "ra" text,
    "matid" bigint,
    "mattitle" text,
    "cod_turma" text,
    "cod_modulo" text,
    "curso" text,
    "turno" text,
    "data" text,
    "p1" text,
    "p2" text,
    "justificativa" text,
    "criado" text,
    "nome" text,
    "mesclado" boolean not null default false,
    "tabela" text
);


alter table "public"."stg_diario_mesclados" enable row level security;

create table "public"."stg_matriculas" (
    "id" bigint not null default nextval('stg_matriculas_id_seq'::regclass),
    "email_aluno" text not null,
    "ra_legado" text,
    "codigo_turma" text not null,
    "ano_ingresso" character(4) not null,
    "semestre_ingresso" smallint not null,
    "processed" boolean not null default false,
    "processed_at" timestamp with time zone,
    "process_status" text,
    "process_error" text,
    "email_existe_user_expandido" boolean not null default false,
    "existe_em_turmas" boolean not null default false,
    "tem_conta_no_auth" boolean not null default false
);


alter table "public"."stg_matriculas" enable row level security;

create table "public"."stg_turmas_horarios" (
    "id" uuid not null default gen_random_uuid(),
    "cod_modulo" text not null,
    "hora_ini" text,
    "hora_fim" text,
    "criado_em" timestamp with time zone default now()
);


create table "public"."tabela" (
    "id" uuid not null default gen_random_uuid()
);


alter table "public"."tabela" enable row level security;

create table "public"."tabela_datas_teste" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "data_teste" timestamp with time zone
);


alter table "public"."tabela_datas_teste" enable row level security;

create table "public"."textos_listas_selecao" (
    "id" uuid not null default gen_random_uuid(),
    "id_turma" uuid not null,
    "data_prova" date,
    "hora_redacao" text,
    "hora_pratica" text,
    "cabecalho_texto" text,
    "criado_em" timestamp with time zone default now(),
    "modificado_em" timestamp with time zone default now(),
    "data_etapas" text,
    "ano_semestre" text,
    "ano_semestre_normalizado" text,
    "area" tipo_area,
    "area_normalizada" text
);


alter table "public"."textos_listas_selecao" enable row level security;

create table "public"."tipo_produto" (
    "id" uuid not null default gen_random_uuid(),
    "nome" text not null,
    "descricao" text,
    "criado_em" timestamp with time zone default now()
);


alter table "public"."tipo_produto" enable row level security;

create table "public"."turma_etapa_anosemestre" (
    "id" uuid not null default gen_random_uuid(),
    "id_turma" uuid not null,
    "id_etapa" uuid not null,
    "anosemestre" text not null,
    "data_ini" timestamp with time zone not null,
    "data_fim" timestamp with time zone not null,
    "criado_em" timestamp with time zone default now()
);


alter table "public"."turma_etapa_anosemestre" enable row level security;

create table "public"."turma_etapas" (
    "id" uuid not null default gen_random_uuid(),
    "etapa" text not null,
    "descricao" text,
    "color" text,
    "criado_em" timestamp with time zone default now()
);


alter table "public"."turma_etapas" enable row level security;

create table "public"."turmas" (
    "id" uuid not null default gen_random_uuid(),
    "nome_curso" text not null,
    "area_curso" text,
    "ano_semestre" text,
    "ano" text,
    "semestre" text,
    "turno" text,
    "cod_curso" text,
    "cod_turma" text,
    "cod_modulo" text,
    "qtd_horastotais" integer,
    "dt_ini_inscri" timestamp with time zone,
    "dt_fim_inscri" timestamp with time zone,
    "dt_ini_mat" timestamp with time zone,
    "dt_fim_mat" timestamp with time zone,
    "dt_ini_curso" timestamp with time zone,
    "dt_fim_curso" timestamp with time zone,
    "dt_ini_inscri_docente" timestamp with time zone,
    "dt_fim_inscri_docente" timestamp with time zone,
    "dias_semana" text,
    "id_sharepoint" integer,
    "link_video" boolean,
    "id_curso" uuid,
    "hora_ini" text,
    "hora_fim" text,
    "possui_calendario" boolean default false,
    "log_calendario" text,
    "info_calendario" jsonb default '{}'::jsonb
);


alter table "public"."turmas" enable row level security;

create table "public"."turmas_calendario" (
    "id" uuid not null default gen_random_uuid(),
    "id_turma" uuid not null,
    "start" timestamp with time zone not null,
    "end" timestamp with time zone not null,
    "title" text not null,
    "data" date not null,
    "content" text,
    "color" text,
    "id_etapa" uuid,
    "criado_em" timestamp with time zone default now(),
    "modificado_em" timestamp with time zone default now()
);


alter table "public"."turmas_calendario" enable row level security;

create table "public"."turmas_dias" (
    "id" uuid not null default gen_random_uuid(),
    "id_turma" uuid not null,
    "dia_da_semana_num" integer not null,
    "dia_da_semana_text" text not null
);


alter table "public"."turmas_dias" enable row level security;

create table "public"."turmas_dias_extra_calendario" (
    "id" uuid not null default gen_random_uuid(),
    "id_turma" uuid not null,
    "dia_da_semana_num" integer not null,
    "dia_da_semana_text" text not null,
    "data" timestamp with time zone not null,
    "observacoes" text,
    "criado_por" uuid,
    "criado_em" timestamp with time zone default now(),
    "modificado_por" uuid,
    "modificado_em" timestamp with time zone default now()
);


alter table "public"."turmas_dias_extra_calendario" enable row level security;

create table "public"."user_email_audit" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "old_email" text,
    "new_email" text,
    "changed_at" timestamp with time zone default now()
);


alter table "public"."user_email_audit" enable row level security;

create table "public"."user_expandido" (
    "user_id" uuid,
    "nome" text,
    "sobrenome" text,
    "email" text,
    "papel_id" uuid not null,
    "id" uuid not null default gen_random_uuid(),
    "imagem_user" text,
    "onboarding" boolean not null default true,
    "papel_modificado" boolean default false,
    "status" boolean default true
);


alter table "public"."user_expandido" enable row level security;

alter sequence "public"."ra_alunos_id_seq" owned by "public"."ra_alunos"."id";

alter sequence "public"."stg_matriculas_id_seq" owned by "public"."stg_matriculas"."id";

CREATE UNIQUE INDEX bloco_perguntas_pkey ON public.bloco_perguntas USING btree (id);

CREATE UNIQUE INDEX curso_cod_curso_key ON public.curso USING btree (cod_curso);

CREATE UNIQUE INDEX curso_encontros_pkey ON public.curso_encontros USING btree (id);

CREATE UNIQUE INDEX curso_ficha_avaliacao_id_curso_key ON public.curso_ficha_avaliacao USING btree (id_curso);

CREATE UNIQUE INDEX curso_ficha_avaliacao_pkey ON public.curso_ficha_avaliacao USING btree (id);

CREATE UNIQUE INDEX curso_pkey ON public.curso USING btree (id);

CREATE UNIQUE INDEX diario_controle_sync_pkey ON public.diario_controle_sync USING btree (id);

CREATE UNIQUE INDEX diario_pkey ON public.diario USING btree (id);

CREATE UNIQUE INDEX diario_sync_sessao_pkey ON public.diario_sync_sessao USING btree (id);

CREATE UNIQUE INDEX email_queue_pkey ON public.email_queue USING btree (id);

CREATE UNIQUE INDEX email_threads_pkey ON public.email_threads USING btree (id);

CREATE UNIQUE INDEX feriados_pkey ON public.feriados USING btree (id);

CREATE INDEX idx_avarias_produto ON public.produto_avarias USING btree (id_produto);

CREATE INDEX idx_avarias_status ON public.produto_avarias USING btree (status_reparo);

CREATE INDEX idx_estoque_produto ON public.produto_estoque USING btree (id_produto);

CREATE INDEX idx_processos_user ON public.processos USING btree (user_id);

CREATE INDEX idx_processos_ux ON public.processos USING btree (user_expandido_id);

CREATE INDEX idx_produto_estoque_prod_status ON public.produto_estoque USING btree (id_produto, status_item);

CREATE INDEX idx_produto_estoque_status_item ON public.produto_estoque USING btree (status_item);

CREATE INDEX idx_produto_reservas_auth_user_id ON public.produto_reservas USING btree (auth_user_id);

CREATE INDEX idx_produtos_nome_lower ON public.produtos USING btree (lower(nome) text_pattern_ops);

CREATE INDEX idx_produtos_tipo ON public.produtos USING btree (id_tipo_produto);

CREATE INDEX idx_produtos_unidade ON public.produtos USING btree (id_unidade);

CREATE INDEX idx_reservas_status ON public.produto_reservas USING btree (status, id_produto_estoque);

CREATE INDEX idx_respostas_user ON public.respostas USING btree (id_usuario);

CREATE INDEX idx_respostas_ux ON public.respostas USING btree (user_expandido_id);

CREATE INDEX idx_salas_horarios_id_horario ON public.salas_horarios USING btree (id_horario);

CREATE INDEX idx_salas_horarios_id_sala ON public.salas_horarios USING btree (id_sala);

CREATE INDEX ix_diario_aluno_data ON public.diario USING btree (id_aluno, data);

CREATE INDEX ix_diario_controle_sync_diario_status ON public.diario_controle_sync USING btree (id_diario, status);

CREATE INDEX ix_diario_matricula ON public.diario USING btree (id_matricula);

CREATE INDEX ix_diario_sync_sessao_in_time ON public.diario_sync_sessao USING btree (in_time);

CREATE INDEX ix_diario_sync_sessao_status ON public.diario_sync_sessao USING btree (status);

CREATE INDEX ix_diario_turma_data ON public.diario USING btree (id_turma, data);

CREATE INDEX ix_matriculas_aluno ON public.matriculas USING btree (id_aluno);

CREATE INDEX ix_matriculas_turma ON public.matriculas USING btree (id_turma);

CREATE INDEX ix_matriculas_turma_status ON public.matriculas USING btree (id_turma, status);

CREATE INDEX ix_ra_lookup ON public.ra_alunos USING btree (ano_ingresso, semestre_ingresso, milhar DESC, codigo_lista_ano_semestre DESC);

CREATE INDEX ix_respostas_aprovacao ON public.respostas USING btree (user_expandido_id, id_pergunta, aprovado_doc);

CREATE INDEX ix_respostas_user_pergunta ON public.respostas USING btree (id_usuario, id_pergunta);

CREATE UNIQUE INDEX ix_respostas_user_pergunta_global ON public.respostas USING btree (user_expandido_id, id_pergunta) WHERE (id_turma IS NULL);

CREATE UNIQUE INDEX ix_respostas_user_pergunta_turma ON public.respostas USING btree (user_expandido_id, id_pergunta, id_turma) WHERE (id_turma IS NOT NULL);

CREATE INDEX ix_stg_matriculas_codturma ON public.stg_matriculas USING btree (codigo_turma);

CREATE INDEX ix_stg_matriculas_email ON public.stg_matriculas USING btree (email_aluno);

CREATE INDEX ix_stg_matriculas_processed ON public.stg_matriculas USING btree (processed, process_status);

CREATE INDEX ix_stg_turmas_horarios_cod_modulo ON public.stg_turmas_horarios USING btree (cod_modulo);

CREATE INDEX ix_turmas_cod_turma ON public.turmas USING btree (cod_turma);

CREATE UNIQUE INDEX matriculas_id_aluno_id_turma_key ON public.matriculas USING btree (id_aluno, id_turma);

CREATE UNIQUE INDEX matriculas_pkey ON public.matriculas USING btree (id);

CREATE UNIQUE INDEX papeis_user_auth_pkey ON public.papeis_user_auth USING btree (id);

CREATE UNIQUE INDEX papeis_user_auth_user_id_papel_id_key ON public.papeis_user_auth USING btree (user_id, papel_id);

CREATE UNIQUE INDEX papeis_user_nome_key ON public.papeis_user USING btree (nome);

CREATE UNIQUE INDEX papeis_user_pkey ON public.papeis_user USING btree (id);

CREATE UNIQUE INDEX perguntas_avaliacao_processos_pkey ON public.perguntas_avaliacao_processos USING btree (id);

CREATE UNIQUE INDEX perguntas_pkey ON public.perguntas USING btree (id);

CREATE UNIQUE INDEX processo_documentos_obrigatorios_pkey ON public.processo_documentos_obrigatorios USING btree (id);

CREATE UNIQUE INDEX processos_antigos_pkey ON public.processos_antigos USING btree (id);

CREATE UNIQUE INDEX processos_pkey ON public.processos USING btree (id);

CREATE UNIQUE INDEX produto_avarias_pkey ON public.produto_avarias USING btree (id);

CREATE UNIQUE INDEX produto_categoria_pkey ON public.produto_categoria USING btree (id);

CREATE UNIQUE INDEX produto_estoque_pkey ON public.produto_estoque USING btree (id);

CREATE UNIQUE INDEX produto_kit_pkey ON public.produto_kit USING btree (id);

CREATE UNIQUE INDEX produto_reservas_pkey ON public.produto_reservas USING btree (id);

CREATE UNIQUE INDEX produto_tipo_avaria_pkey ON public.produto_tipo_avaria USING btree (id);

CREATE UNIQUE INDEX produtos_pkey ON public.produtos USING btree (id);

CREATE UNIQUE INDEX professor_turma_atribuicao_pkey ON public.professor_turma_atribuicao USING btree (id);

CREATE UNIQUE INDEX professor_turma_atribuicao_user_turma_unique ON public.professor_turma_atribuicao USING btree (user_id, id_turmas);

CREATE UNIQUE INDEX ra_alunos_pkey ON public.ra_alunos USING btree (id);

CREATE UNIQUE INDEX ra_alunos_ra_key ON public.ra_alunos USING btree (ra);

CREATE UNIQUE INDEX respostas_perguntas_avaliacao_processos_pkey ON public.respostas_perguntas_avaliacao_processos USING btree (id);

CREATE UNIQUE INDEX respostas_pkey ON public.respostas USING btree (id);

CREATE UNIQUE INDEX sala_pkey ON public.sala USING btree (id);

CREATE INDEX sala_reservas_data_sh ON public.sala_reservas USING btree (data, sala_horario_id);

CREATE UNIQUE INDEX sala_reservas_pkey ON public.sala_reservas USING btree (id);

CREATE UNIQUE INDEX sala_reservas_unq_ativo ON public.sala_reservas USING btree (sala_horario_id, data) WHERE (status <> 'cancelado'::text);

CREATE UNIQUE INDEX salas_horarios_pkey ON public.salas_horarios USING btree (id);

CREATE UNIQUE INDEX slot_horarios_pkey ON public.slot_horarios USING btree (id);

CREATE UNIQUE INDEX stg_corrigir_ras_pkey ON public.stg_corrigir_ras USING btree (id);

CREATE UNIQUE INDEX stg_cursos_pkey ON public.stg_cursos USING btree (id);

CREATE UNIQUE INDEX stg_diario_mesclados_pkey ON public.stg_diario_mesclados USING btree (id);

CREATE UNIQUE INDEX stg_matriculas_pkey ON public.stg_matriculas USING btree (id);

CREATE UNIQUE INDEX stg_turmas_horarios_pkey ON public.stg_turmas_horarios USING btree (id);

CREATE UNIQUE INDEX tabela_datas_teste_pkey ON public.tabela_datas_teste USING btree (id);

CREATE UNIQUE INDEX tabela_pkey ON public.tabela USING btree (id);

CREATE UNIQUE INDEX textos_listas_selecao_id_turma_key ON public.textos_listas_selecao USING btree (id_turma);

CREATE UNIQUE INDEX textos_listas_selecao_pkey ON public.textos_listas_selecao USING btree (id);

CREATE UNIQUE INDEX tipo_produto_nome_key ON public.tipo_produto USING btree (nome);

CREATE UNIQUE INDEX tipo_produto_pkey ON public.tipo_produto USING btree (id);

CREATE UNIQUE INDEX turma_etapa_anosemestre_pkey ON public.turma_etapa_anosemestre USING btree (id);

CREATE UNIQUE INDEX turma_etapas_etapa_key ON public.turma_etapas USING btree (etapa);

CREATE UNIQUE INDEX turma_etapas_pkey ON public.turma_etapas USING btree (id);

CREATE UNIQUE INDEX turmas_calendario_pkey ON public.turmas_calendario USING btree (id);

CREATE UNIQUE INDEX turmas_dias_extra_calendario_pkey ON public.turmas_dias_extra_calendario USING btree (id);

CREATE UNIQUE INDEX turmas_dias_pkey ON public.turmas_dias USING btree (id);

CREATE UNIQUE INDEX turmas_pkey ON public.turmas USING btree (id);

CREATE UNIQUE INDEX unidade_pkey ON public.produto_unidade USING btree (id);

CREATE UNIQUE INDEX uq_diario_aluno_turma_dia ON public.diario USING btree (id_aluno, id_turma, data);

CREATE UNIQUE INDEX uq_diario_matricula_data ON public.diario USING btree (id_matricula, data);

CREATE UNIQUE INDEX uq_ra_por_aluno ON public.ra_alunos USING btree (id_aluno);

CREATE UNIQUE INDEX uq_ra_slot ON public.ra_alunos USING btree (ano_ingresso, semestre_ingresso, milhar, codigo_lista_ano_semestre);

CREATE UNIQUE INDEX uq_stg_matriculas_aluno_turma ON public.stg_matriculas USING btree (email_aluno, codigo_turma);

CREATE UNIQUE INDEX user_email_audit_pkey ON public.user_email_audit USING btree (id);

CREATE UNIQUE INDEX user_expandido_email_key ON public.user_expandido USING btree (email);

CREATE UNIQUE INDEX user_expandido_pkey ON public.user_expandido USING btree (id);

CREATE UNIQUE INDEX user_expandido_user_id_unique ON public.user_expandido USING btree (user_id);

CREATE UNIQUE INDEX ux_respostas_user_pergunta_processo ON public.respostas_perguntas_avaliacao_processos USING btree (id_user, id_pergunta_processo, id_processo);

alter table "public"."bloco_perguntas" add constraint "bloco_perguntas_pkey" PRIMARY KEY using index "bloco_perguntas_pkey";

alter table "public"."curso" add constraint "curso_pkey" PRIMARY KEY using index "curso_pkey";

alter table "public"."curso_encontros" add constraint "curso_encontros_pkey" PRIMARY KEY using index "curso_encontros_pkey";

alter table "public"."curso_ficha_avaliacao" add constraint "curso_ficha_avaliacao_pkey" PRIMARY KEY using index "curso_ficha_avaliacao_pkey";

alter table "public"."diario" add constraint "diario_pkey" PRIMARY KEY using index "diario_pkey";

alter table "public"."diario_controle_sync" add constraint "diario_controle_sync_pkey" PRIMARY KEY using index "diario_controle_sync_pkey";

alter table "public"."diario_sync_sessao" add constraint "diario_sync_sessao_pkey" PRIMARY KEY using index "diario_sync_sessao_pkey";

alter table "public"."email_queue" add constraint "email_queue_pkey" PRIMARY KEY using index "email_queue_pkey";

alter table "public"."email_threads" add constraint "email_threads_pkey" PRIMARY KEY using index "email_threads_pkey";

alter table "public"."feriados" add constraint "feriados_pkey" PRIMARY KEY using index "feriados_pkey";

alter table "public"."matriculas" add constraint "matriculas_pkey" PRIMARY KEY using index "matriculas_pkey";

alter table "public"."papeis_user" add constraint "papeis_user_pkey" PRIMARY KEY using index "papeis_user_pkey";

alter table "public"."papeis_user_auth" add constraint "papeis_user_auth_pkey" PRIMARY KEY using index "papeis_user_auth_pkey";

alter table "public"."perguntas" add constraint "perguntas_pkey" PRIMARY KEY using index "perguntas_pkey";

alter table "public"."perguntas_avaliacao_processos" add constraint "perguntas_avaliacao_processos_pkey" PRIMARY KEY using index "perguntas_avaliacao_processos_pkey";

alter table "public"."processo_documentos_obrigatorios" add constraint "processo_documentos_obrigatorios_pkey" PRIMARY KEY using index "processo_documentos_obrigatorios_pkey";

alter table "public"."processos" add constraint "processos_pkey" PRIMARY KEY using index "processos_pkey";

alter table "public"."processos_antigos" add constraint "processos_antigos_pkey" PRIMARY KEY using index "processos_antigos_pkey";

alter table "public"."produto_avarias" add constraint "produto_avarias_pkey" PRIMARY KEY using index "produto_avarias_pkey";

alter table "public"."produto_categoria" add constraint "produto_categoria_pkey" PRIMARY KEY using index "produto_categoria_pkey";

alter table "public"."produto_estoque" add constraint "produto_estoque_pkey" PRIMARY KEY using index "produto_estoque_pkey";

alter table "public"."produto_kit" add constraint "produto_kit_pkey" PRIMARY KEY using index "produto_kit_pkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_pkey" PRIMARY KEY using index "produto_reservas_pkey";

alter table "public"."produto_tipo_avaria" add constraint "produto_tipo_avaria_pkey" PRIMARY KEY using index "produto_tipo_avaria_pkey";

alter table "public"."produto_unidade" add constraint "unidade_pkey" PRIMARY KEY using index "unidade_pkey";

alter table "public"."produtos" add constraint "produtos_pkey" PRIMARY KEY using index "produtos_pkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_pkey" PRIMARY KEY using index "professor_turma_atribuicao_pkey";

alter table "public"."ra_alunos" add constraint "ra_alunos_pkey" PRIMARY KEY using index "ra_alunos_pkey";

alter table "public"."respostas" add constraint "respostas_pkey" PRIMARY KEY using index "respostas_pkey";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "respostas_perguntas_avaliacao_processos_pkey" PRIMARY KEY using index "respostas_perguntas_avaliacao_processos_pkey";

alter table "public"."sala" add constraint "sala_pkey" PRIMARY KEY using index "sala_pkey";

alter table "public"."sala_reservas" add constraint "sala_reservas_pkey" PRIMARY KEY using index "sala_reservas_pkey";

alter table "public"."salas_horarios" add constraint "salas_horarios_pkey" PRIMARY KEY using index "salas_horarios_pkey";

alter table "public"."slot_horarios" add constraint "slot_horarios_pkey" PRIMARY KEY using index "slot_horarios_pkey";

alter table "public"."stg_corrigir_ras" add constraint "stg_corrigir_ras_pkey" PRIMARY KEY using index "stg_corrigir_ras_pkey";

alter table "public"."stg_cursos" add constraint "stg_cursos_pkey" PRIMARY KEY using index "stg_cursos_pkey";

alter table "public"."stg_diario_mesclados" add constraint "stg_diario_mesclados_pkey" PRIMARY KEY using index "stg_diario_mesclados_pkey";

alter table "public"."stg_matriculas" add constraint "stg_matriculas_pkey" PRIMARY KEY using index "stg_matriculas_pkey";

alter table "public"."stg_turmas_horarios" add constraint "stg_turmas_horarios_pkey" PRIMARY KEY using index "stg_turmas_horarios_pkey";

alter table "public"."tabela" add constraint "tabela_pkey" PRIMARY KEY using index "tabela_pkey";

alter table "public"."tabela_datas_teste" add constraint "tabela_datas_teste_pkey" PRIMARY KEY using index "tabela_datas_teste_pkey";

alter table "public"."textos_listas_selecao" add constraint "textos_listas_selecao_pkey" PRIMARY KEY using index "textos_listas_selecao_pkey";

alter table "public"."tipo_produto" add constraint "tipo_produto_pkey" PRIMARY KEY using index "tipo_produto_pkey";

alter table "public"."turma_etapa_anosemestre" add constraint "turma_etapa_anosemestre_pkey" PRIMARY KEY using index "turma_etapa_anosemestre_pkey";

alter table "public"."turma_etapas" add constraint "turma_etapas_pkey" PRIMARY KEY using index "turma_etapas_pkey";

alter table "public"."turmas" add constraint "turmas_pkey" PRIMARY KEY using index "turmas_pkey";

alter table "public"."turmas_calendario" add constraint "turmas_calendario_pkey" PRIMARY KEY using index "turmas_calendario_pkey";

alter table "public"."turmas_dias" add constraint "turmas_dias_pkey" PRIMARY KEY using index "turmas_dias_pkey";

alter table "public"."turmas_dias_extra_calendario" add constraint "turmas_dias_extra_calendario_pkey" PRIMARY KEY using index "turmas_dias_extra_calendario_pkey";

alter table "public"."user_email_audit" add constraint "user_email_audit_pkey" PRIMARY KEY using index "user_email_audit_pkey";

alter table "public"."user_expandido" add constraint "user_expandido_pkey" PRIMARY KEY using index "user_expandido_pkey";

alter table "public"."curso" add constraint "curso_cod_curso_key" UNIQUE using index "curso_cod_curso_key";

alter table "public"."curso_encontros" add constraint "curso_encontros_id_curso_fkey" FOREIGN KEY (id_curso) REFERENCES curso(id) ON DELETE CASCADE not valid;

alter table "public"."curso_encontros" validate constraint "curso_encontros_id_curso_fkey";

alter table "public"."curso_ficha_avaliacao" add constraint "curso_ficha_avaliacao_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."curso_ficha_avaliacao" validate constraint "curso_ficha_avaliacao_criado_por_fkey";

alter table "public"."curso_ficha_avaliacao" add constraint "curso_ficha_avaliacao_id_curso_fkey" FOREIGN KEY (id_curso) REFERENCES curso(id) ON DELETE CASCADE not valid;

alter table "public"."curso_ficha_avaliacao" validate constraint "curso_ficha_avaliacao_id_curso_fkey";

alter table "public"."curso_ficha_avaliacao" add constraint "curso_ficha_avaliacao_id_curso_key" UNIQUE using index "curso_ficha_avaliacao_id_curso_key";

alter table "public"."curso_ficha_avaliacao" add constraint "curso_ficha_avaliacao_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."curso_ficha_avaliacao" validate constraint "curso_ficha_avaliacao_modificado_por_fkey";

alter table "public"."diario" add constraint "diario_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) not valid;

alter table "public"."diario" validate constraint "diario_criado_por_fkey";

alter table "public"."diario" add constraint "diario_id_aluno_fkey" FOREIGN KEY (id_aluno) REFERENCES user_expandido(id) not valid;

alter table "public"."diario" validate constraint "diario_id_aluno_fkey";

alter table "public"."diario" add constraint "diario_id_matricula_fkey" FOREIGN KEY (id_matricula) REFERENCES matriculas(id) ON DELETE CASCADE not valid;

alter table "public"."diario" validate constraint "diario_id_matricula_fkey";

alter table "public"."diario" add constraint "diario_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) not valid;

alter table "public"."diario" validate constraint "diario_id_turma_fkey";

alter table "public"."diario" add constraint "diario_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) not valid;

alter table "public"."diario" validate constraint "diario_modificado_por_fkey";

alter table "public"."diario" add constraint "uq_diario_aluno_turma_dia" UNIQUE using index "uq_diario_aluno_turma_dia";

alter table "public"."diario" add constraint "uq_diario_matricula_data" UNIQUE using index "uq_diario_matricula_data";

alter table "public"."diario_controle_sync" add constraint "diario_controle_sync_id_diario_fkey" FOREIGN KEY (id_diario) REFERENCES diario(id) ON DELETE CASCADE not valid;

alter table "public"."diario_controle_sync" validate constraint "diario_controle_sync_id_diario_fkey";

alter table "public"."email_threads" add constraint "email_threads_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE SET NULL not valid;

alter table "public"."email_threads" validate constraint "email_threads_id_turma_fkey";

alter table "public"."email_threads" add constraint "email_threads_id_user_destino_fkey" FOREIGN KEY (id_user_destino) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."email_threads" validate constraint "email_threads_id_user_destino_fkey";

alter table "public"."email_threads" add constraint "email_threads_id_user_origem_fkey" FOREIGN KEY (id_user_origem) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."email_threads" validate constraint "email_threads_id_user_origem_fkey";

alter table "public"."matriculas" add constraint "matriculas_id_aluno_fkey" FOREIGN KEY (id_aluno) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."matriculas" validate constraint "matriculas_id_aluno_fkey";

alter table "public"."matriculas" add constraint "matriculas_id_aluno_id_turma_key" UNIQUE using index "matriculas_id_aluno_id_turma_key";

alter table "public"."matriculas" add constraint "matriculas_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."matriculas" validate constraint "matriculas_id_turma_fkey";

alter table "public"."papeis_user" add constraint "papeis_user_nome_key" UNIQUE using index "papeis_user_nome_key";

alter table "public"."papeis_user_auth" add constraint "papeis_user_auth_papel_id_fkey" FOREIGN KEY (papel_id) REFERENCES papeis_user(id) ON DELETE CASCADE not valid;

alter table "public"."papeis_user_auth" validate constraint "papeis_user_auth_papel_id_fkey";

alter table "public"."papeis_user_auth" add constraint "papeis_user_auth_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."papeis_user_auth" validate constraint "papeis_user_auth_user_id_fkey";

alter table "public"."papeis_user_auth" add constraint "papeis_user_auth_user_id_papel_id_key" UNIQUE using index "papeis_user_auth_user_id_papel_id_key";

alter table "public"."perguntas_avaliacao_processos" add constraint "perguntas_avaliacao_processos_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."perguntas_avaliacao_processos" validate constraint "perguntas_avaliacao_processos_criado_por_fkey";

alter table "public"."perguntas_avaliacao_processos" add constraint "perguntas_avaliacao_processos_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."perguntas_avaliacao_processos" validate constraint "perguntas_avaliacao_processos_id_turma_fkey";

alter table "public"."perguntas_avaliacao_processos" add constraint "perguntas_avaliacao_processos_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."perguntas_avaliacao_processos" validate constraint "perguntas_avaliacao_processos_modificado_por_fkey";

alter table "public"."processo_documentos_obrigatorios" add constraint "chk_escopo_area" CHECK (((escopo <> 'area'::escopo_processo) OR (id_area IS NOT NULL))) not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "chk_escopo_area";

alter table "public"."processo_documentos_obrigatorios" add constraint "chk_escopo_curso" CHECK (((escopo <> 'curso'::escopo_processo) OR (id_curso IS NOT NULL))) not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "chk_escopo_curso";

alter table "public"."processo_documentos_obrigatorios" add constraint "chk_escopo_turma" CHECK (((escopo <> 'turma'::escopo_processo) OR (id_turma IS NOT NULL) OR (id_area IS NOT NULL))) not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "chk_escopo_turma";

alter table "public"."processo_documentos_obrigatorios" add constraint "processo_documentos_obrigatorios_id_curso_fkey" FOREIGN KEY (id_curso) REFERENCES curso(id) ON DELETE CASCADE not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "processo_documentos_obrigatorios_id_curso_fkey";

alter table "public"."processo_documentos_obrigatorios" add constraint "processo_documentos_obrigatorios_id_pergunta_fkey" FOREIGN KEY (id_pergunta) REFERENCES perguntas(id) ON DELETE CASCADE not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "processo_documentos_obrigatorios_id_pergunta_fkey";

alter table "public"."processo_documentos_obrigatorios" add constraint "processo_documentos_obrigatorios_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."processo_documentos_obrigatorios" validate constraint "processo_documentos_obrigatorios_id_turma_fkey";

alter table "public"."processos" add constraint "fk_turma_id" FOREIGN KEY (turma_id) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."processos" validate constraint "fk_turma_id";

alter table "public"."processos" add constraint "processos_papel_user_fkey" FOREIGN KEY (papel_user) REFERENCES papeis_user(id) not valid;

alter table "public"."processos" validate constraint "processos_papel_user_fkey";

alter table "public"."processos" add constraint "processos_user_expandido_fk" FOREIGN KEY (user_expandido_id) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."processos" validate constraint "processos_user_expandido_fk";

alter table "public"."produto_avarias" add constraint "fk_produto" FOREIGN KEY (id_produto) REFERENCES produtos(id) ON DELETE CASCADE not valid;

alter table "public"."produto_avarias" validate constraint "fk_produto";

alter table "public"."produto_avarias" add constraint "fk_produto_estoque" FOREIGN KEY (id_produto_estoque) REFERENCES produto_estoque(id) ON DELETE CASCADE not valid;

alter table "public"."produto_avarias" validate constraint "fk_produto_estoque";

alter table "public"."produto_avarias" add constraint "fk_tipo_avaria" FOREIGN KEY (tipo_avaria) REFERENCES produto_tipo_avaria(id) ON DELETE SET NULL not valid;

alter table "public"."produto_avarias" validate constraint "fk_tipo_avaria";

alter table "public"."produto_estoque" add constraint "produto_estoque_id_produto_fkey" FOREIGN KEY (id_produto) REFERENCES produtos(id) ON DELETE CASCADE not valid;

alter table "public"."produto_estoque" validate constraint "produto_estoque_id_produto_fkey";

alter table "public"."produto_estoque" add constraint "produto_estoque_id_sala_fkey" FOREIGN KEY (id_sala) REFERENCES sala(id) not valid;

alter table "public"."produto_estoque" validate constraint "produto_estoque_id_sala_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_auth_user_id_fkey" FOREIGN KEY (auth_user_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_auth_user_id_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_id_avaria_fkey" FOREIGN KEY (id_avaria) REFERENCES produto_avarias(id) not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_id_avaria_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_id_produto_estoque_fkey" FOREIGN KEY (id_produto_estoque) REFERENCES produto_estoque(id) not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_id_produto_estoque_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_id_produto_fkey" FOREIGN KEY (id_produto) REFERENCES produtos(id) not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_id_produto_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_id_usuario_fkey" FOREIGN KEY (id_usuario) REFERENCES user_expandido(id) not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_id_usuario_fkey";

alter table "public"."produto_reservas" add constraint "produto_reservas_usuario_devolveu_fkey" FOREIGN KEY (usuario_devolveu) REFERENCES user_expandido(id) not valid;

alter table "public"."produto_reservas" validate constraint "produto_reservas_usuario_devolveu_fkey";

alter table "public"."produtos" add constraint "produtos_id_categoria_produto_fkey" FOREIGN KEY (id_categoria_produto) REFERENCES produto_categoria(id) not valid;

alter table "public"."produtos" validate constraint "produtos_id_categoria_produto_fkey";

alter table "public"."produtos" add constraint "produtos_id_tipo_produto_fkey" FOREIGN KEY (id_tipo_produto) REFERENCES tipo_produto(id) not valid;

alter table "public"."produtos" validate constraint "produtos_id_tipo_produto_fkey";

alter table "public"."produtos" add constraint "produtos_id_unidade_fkey" FOREIGN KEY (id_unidade) REFERENCES produto_unidade(id) not valid;

alter table "public"."produtos" validate constraint "produtos_id_unidade_fkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."professor_turma_atribuicao" validate constraint "professor_turma_atribuicao_criado_por_fkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."professor_turma_atribuicao" validate constraint "professor_turma_atribuicao_modificado_por_fkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_turmas_fkey" FOREIGN KEY (id_turmas) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."professor_turma_atribuicao" validate constraint "professor_turma_atribuicao_turmas_fkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_user_id_fkey" FOREIGN KEY (user_id) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."professor_turma_atribuicao" validate constraint "professor_turma_atribuicao_user_id_fkey";

alter table "public"."professor_turma_atribuicao" add constraint "professor_turma_atribuicao_user_turma_unique" UNIQUE using index "professor_turma_atribuicao_user_turma_unique";

alter table "public"."ra_alunos" add constraint "ra_alunos_codigo_lista_ano_semestre_check" CHECK (((codigo_lista_ano_semestre >= 1) AND (codigo_lista_ano_semestre <= 999))) not valid;

alter table "public"."ra_alunos" validate constraint "ra_alunos_codigo_lista_ano_semestre_check";

alter table "public"."ra_alunos" add constraint "ra_alunos_id_aluno_fkey" FOREIGN KEY (id_aluno) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."ra_alunos" validate constraint "ra_alunos_id_aluno_fkey";

alter table "public"."ra_alunos" add constraint "ra_alunos_milhar_check" CHECK ((milhar >= 1)) not valid;

alter table "public"."ra_alunos" validate constraint "ra_alunos_milhar_check";

alter table "public"."ra_alunos" add constraint "ra_alunos_ra_key" UNIQUE using index "ra_alunos_ra_key";

alter table "public"."ra_alunos" add constraint "ra_alunos_semestre_ingresso_check" CHECK ((semestre_ingresso = ANY (ARRAY[1, 2]))) not valid;

alter table "public"."ra_alunos" validate constraint "ra_alunos_semestre_ingresso_check";

alter table "public"."respostas" add constraint "respostas_aprovado_por_fkey" FOREIGN KEY (aprovado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."respostas" validate constraint "respostas_aprovado_por_fkey";

alter table "public"."respostas" add constraint "respostas_id_pergunta_fkey" FOREIGN KEY (id_pergunta) REFERENCES perguntas(id) not valid;

alter table "public"."respostas" validate constraint "respostas_id_pergunta_fkey";

alter table "public"."respostas" add constraint "respostas_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) not valid;

alter table "public"."respostas" validate constraint "respostas_id_turma_fkey";

alter table "public"."respostas" add constraint "respostas_id_usuario_fkey" FOREIGN KEY (id_usuario) REFERENCES auth.users(id) not valid;

alter table "public"."respostas" validate constraint "respostas_id_usuario_fkey";

alter table "public"."respostas" add constraint "respostas_user_expandido_fk" FOREIGN KEY (user_expandido_id) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."respostas" validate constraint "respostas_user_expandido_fk";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "fk_resposta_processo" FOREIGN KEY (id_processo) REFERENCES processos(id) ON DELETE SET NULL not valid;

alter table "public"."respostas_perguntas_avaliacao_processos" validate constraint "fk_resposta_processo";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "respostas_perguntas_avaliacao_process_id_pergunta_processo_fkey" FOREIGN KEY (id_pergunta_processo) REFERENCES perguntas_avaliacao_processos(id) ON DELETE CASCADE not valid;

alter table "public"."respostas_perguntas_avaliacao_processos" validate constraint "respostas_perguntas_avaliacao_process_id_pergunta_processo_fkey";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "respostas_perguntas_avaliacao_processos_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."respostas_perguntas_avaliacao_processos" validate constraint "respostas_perguntas_avaliacao_processos_criado_por_fkey";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "respostas_perguntas_avaliacao_processos_id_user_fkey" FOREIGN KEY (id_user) REFERENCES user_expandido(id) ON DELETE CASCADE not valid;

alter table "public"."respostas_perguntas_avaliacao_processos" validate constraint "respostas_perguntas_avaliacao_processos_id_user_fkey";

alter table "public"."respostas_perguntas_avaliacao_processos" add constraint "ux_respostas_user_pergunta_processo" UNIQUE using index "ux_respostas_user_pergunta_processo";

alter table "public"."sala" add constraint "sala_cor_hex_chk" CHECK ((cor ~ '^#[0-9A-Fa-f]{6}$'::text)) not valid;

alter table "public"."sala" validate constraint "sala_cor_hex_chk";

alter table "public"."sala_reservas" add constraint "sala_reservas_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) not valid;

alter table "public"."sala_reservas" validate constraint "sala_reservas_criado_por_fkey";

alter table "public"."sala_reservas" add constraint "sala_reservas_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) not valid;

alter table "public"."sala_reservas" validate constraint "sala_reservas_modificado_por_fkey";

alter table "public"."sala_reservas" add constraint "sala_reservas_sala_horario_id_fkey" FOREIGN KEY (sala_horario_id) REFERENCES salas_horarios(id) ON DELETE CASCADE not valid;

alter table "public"."sala_reservas" validate constraint "sala_reservas_sala_horario_id_fkey";

alter table "public"."sala_reservas" add constraint "sala_reservas_status_chk" CHECK ((status = ANY (ARRAY['reservado'::text, 'confirmado'::text, 'cancelado'::text]))) not valid;

alter table "public"."sala_reservas" validate constraint "sala_reservas_status_chk";

alter table "public"."sala_reservas" add constraint "sala_reservas_turma_id_fkey" FOREIGN KEY (turma_id) REFERENCES turmas(id) ON DELETE SET NULL not valid;

alter table "public"."sala_reservas" validate constraint "sala_reservas_turma_id_fkey";

alter table "public"."salas_horarios" add constraint "salas_horarios_cor_check" CHECK ((cor ~ '^#[0-9A-Fa-f]{6}$'::text)) not valid;

alter table "public"."salas_horarios" validate constraint "salas_horarios_cor_check";

alter table "public"."salas_horarios" add constraint "salas_horarios_id_horario_fkey" FOREIGN KEY (id_horario) REFERENCES slot_horarios(id) ON DELETE CASCADE not valid;

alter table "public"."salas_horarios" validate constraint "salas_horarios_id_horario_fkey";

alter table "public"."salas_horarios" add constraint "salas_horarios_id_sala_fkey" FOREIGN KEY (id_sala) REFERENCES sala(id) ON DELETE CASCADE not valid;

alter table "public"."salas_horarios" validate constraint "salas_horarios_id_sala_fkey";

alter table "public"."stg_matriculas" add constraint "stg_matriculas_semestre_ingresso_check" CHECK ((semestre_ingresso = ANY (ARRAY[1, 2]))) not valid;

alter table "public"."stg_matriculas" validate constraint "stg_matriculas_semestre_ingresso_check";

alter table "public"."textos_listas_selecao" add constraint "textos_listas_selecao_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."textos_listas_selecao" validate constraint "textos_listas_selecao_id_turma_fkey";

alter table "public"."textos_listas_selecao" add constraint "textos_listas_selecao_id_turma_key" UNIQUE using index "textos_listas_selecao_id_turma_key";

alter table "public"."tipo_produto" add constraint "tipo_produto_nome_key" UNIQUE using index "tipo_produto_nome_key";

alter table "public"."turma_etapa_anosemestre" add constraint "turma_etapa_anosemestre_id_etapa_fkey" FOREIGN KEY (id_etapa) REFERENCES turma_etapas(id) ON DELETE CASCADE not valid;

alter table "public"."turma_etapa_anosemestre" validate constraint "turma_etapa_anosemestre_id_etapa_fkey";

alter table "public"."turma_etapa_anosemestre" add constraint "turma_etapa_anosemestre_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."turma_etapa_anosemestre" validate constraint "turma_etapa_anosemestre_id_turma_fkey";

alter table "public"."turma_etapas" add constraint "turma_etapas_etapa_key" UNIQUE using index "turma_etapas_etapa_key";

alter table "public"."turmas" add constraint "turmas_id_curso_fkey" FOREIGN KEY (id_curso) REFERENCES curso(id) ON DELETE SET NULL not valid;

alter table "public"."turmas" validate constraint "turmas_id_curso_fkey";

alter table "public"."turmas_calendario" add constraint "turmas_calendario_id_etapa_fkey" FOREIGN KEY (id_etapa) REFERENCES turma_etapas(id) ON DELETE SET NULL not valid;

alter table "public"."turmas_calendario" validate constraint "turmas_calendario_id_etapa_fkey";

alter table "public"."turmas_calendario" add constraint "turmas_calendario_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."turmas_calendario" validate constraint "turmas_calendario_id_turma_fkey";

alter table "public"."turmas_dias" add constraint "turmas_dias_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."turmas_dias" validate constraint "turmas_dias_id_turma_fkey";

alter table "public"."turmas_dias_extra_calendario" add constraint "turmas_dias_extra_calendario_criado_por_fkey" FOREIGN KEY (criado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."turmas_dias_extra_calendario" validate constraint "turmas_dias_extra_calendario_criado_por_fkey";

alter table "public"."turmas_dias_extra_calendario" add constraint "turmas_dias_extra_calendario_dia_da_semana_num_check" CHECK (((dia_da_semana_num >= 1) AND (dia_da_semana_num <= 7))) not valid;

alter table "public"."turmas_dias_extra_calendario" validate constraint "turmas_dias_extra_calendario_dia_da_semana_num_check";

alter table "public"."turmas_dias_extra_calendario" add constraint "turmas_dias_extra_calendario_id_turma_fkey" FOREIGN KEY (id_turma) REFERENCES turmas(id) ON DELETE CASCADE not valid;

alter table "public"."turmas_dias_extra_calendario" validate constraint "turmas_dias_extra_calendario_id_turma_fkey";

alter table "public"."turmas_dias_extra_calendario" add constraint "turmas_dias_extra_calendario_modificado_por_fkey" FOREIGN KEY (modificado_por) REFERENCES user_expandido(id) ON DELETE SET NULL not valid;

alter table "public"."turmas_dias_extra_calendario" validate constraint "turmas_dias_extra_calendario_modificado_por_fkey";

alter table "public"."user_expandido" add constraint "user_expandido_email_key" UNIQUE using index "user_expandido_email_key";

alter table "public"."user_expandido" add constraint "user_expandido_papel_id_fkey" FOREIGN KEY (papel_id) REFERENCES papeis_user(id) not valid;

alter table "public"."user_expandido" validate constraint "user_expandido_papel_id_fkey";

alter table "public"."user_expandido" add constraint "user_expandido_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_expandido" validate constraint "user_expandido_user_id_fkey";

alter table "public"."user_expandido" add constraint "user_expandido_user_id_unique" UNIQUE using index "user_expandido_user_id_unique";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public._verificar_um_bloco(p_id_user_expandido uuid, p_id_turma uuid, p_area tipo_area, p_bloco text, p_idade integer, p_tipo_processo tipo_processo)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE 
    v_result jsonb;
BEGIN
    --------------------------------------------------------------------
    -- REGRAS DE IDADE (responsável legal)
    --------------------------------------------------------------------
    IF p_bloco = 'responsavel_legal' 
       AND p_idade IS NOT NULL 
       AND p_idade >= 18 THEN
        RETURN jsonb_build_object('ok', true);
    END IF;

    --------------------------------------------------------------------
    -- O CÉREBRO DA VALIDAÇÃO — CTE obrigatorias
    --------------------------------------------------------------------
    WITH obrigatorias AS (
        SELECT
            p.id AS id_pergunta,
            p.label,
            pdo.escopo
        FROM processo_documentos_obrigatorios pdo
        JOIN perguntas p ON p.id = pdo.id_pergunta

        WHERE 
            -- ✔ Bloco deve ser o mesmo na tabela perguntas e na obrigatórios
            p.bloco::text = p_bloco
            AND pdo.bloco::text = p_bloco

            -- ✔ Deve ser obrigatória
            AND pdo.obrigatorio = true
            
            -- ✔ Tipo Processo (NOVO)
            AND pdo.tipo_processo = p_tipo_processo

            -- ✔ CONTEXTO REAL DE ÁREA OU TURMA (HÍBRIDO CORRIGIDO)
            AND (
                   (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
                OR (
                    pdo.escopo = 'turma' 
                    AND (
                           pdo.id_turma = p_id_turma 
                        OR (pdo.id_turma IS NULL AND pdo.id_area = p_area) -- Fix: fallback apenas se id_turma IS NULL
                    )
                )
            )

            -- ✔ DEPENDÊNCIAS — só entra se a condição for satisfeita
            AND (
                  pdo.depende = false
               OR (
                    pdo.depende = true
                    AND pdo.depende_de IS NOT NULL
                    AND EXISTS (
                        SELECT 1
                        FROM respostas r2
                        WHERE r2.user_expandido_id = p_id_user_expandido
                          AND r2.id_pergunta = pdo.depende_de
                          -- Dependência também precisa respeitar escopo da pergunta gatilho?
                          -- Simplificação: Verifica se existe resposta válida no banco para a pergunta gatilho
                          -- Considerando que a gatilho pode ser global ou turma...
                          -- Como não temos o escopo da gatilho aqui facilmente, vamos assumir que se respondeu (em qq escopo válido), ok.
                          AND (r2.id_turma = p_id_turma OR r2.id_turma IS NULL)
                          AND r2.resposta IN (
                              SELECT jsonb_array_elements_text(pdo.valor_depende)
                          )
                    )
               )
            )
    ),

    respostas_user AS (
        SELECT 
            r.id_pergunta,
            r.resposta,
            r.id_turma
        FROM respostas r
        WHERE r.user_expandido_id = p_id_user_expandido
        -- Removido filtro de turma aqui para permitir que a regra de negócio decida no JOIN
        -- AND (r.id_turma = p_id_turma OR r.id_turma IS NULL)
    ),

    faltando AS (
        SELECT 
            o.id_pergunta,
            o.label
        FROM obrigatorias o
        LEFT JOIN respostas_user r ON r.id_pergunta = o.id_pergunta
        -- Lógica de Join Híbrida/Scope Aware
        AND (
            (o.escopo = 'area') -- ACEITA QUALQUER TURMA (ou nenhuma)
            OR
            (o.escopo = 'turma' AND r.id_turma = p_id_turma)
        )
        WHERE 
            r.resposta IS NULL
            OR trim(r.resposta) = ''
            OR trim(r.resposta) = '[]'
            OR trim(r.resposta) = '{}'
    )

    SELECT 
        CASE 
            WHEN NOT EXISTS (SELECT 1 FROM faltando)
                THEN jsonb_build_object('ok', true)
            ELSE jsonb_build_object(
                'ok', false,
                'bloco', p_bloco,
                'faltando', (
                    SELECT jsonb_agg(
                        jsonb_build_object(
                            'id_pergunta', f.id_pergunta,
                            'label', f.label
                        )
                    )
                    FROM faltando f
                )
            )
        END
    INTO v_result;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.adicionar_estoque_produto(p_id_produto uuid, p_quantidade integer)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_valor_inicial integer;
    v_qtd_inserir integer;
BEGIN
    -- Validação simples
    IF p_id_produto IS NULL THEN
        RETURN jsonb_build_object('ok', false, 'message', 'ID do produto é obrigatório');
    END IF;

    v_qtd_inserir := COALESCE(p_quantidade, 0);

    IF v_qtd_inserir <= 0 THEN
         RETURN jsonb_build_object('ok', false, 'message', 'Quantidade deve ser maior que zero');
    END IF;

    -- Busca o valor inicial configurado no produto
    SELECT valor_inicial INTO v_valor_inicial
    FROM public.produtos
    WHERE id = p_id_produto;

    IF v_valor_inicial IS NULL THEN
        -- Se não achou o produto, retorna erro
        RETURN jsonb_build_object('ok', false, 'message', 'Produto não encontrado');
    END IF;

    -- Insere os N itens no estoque
    INSERT INTO public.produto_estoque (
        id_produto,
        valor_inicial,
        valor_atual,
        status_item,
        status_disponibilidade
    )
    SELECT 
        p_id_produto,
        v_valor_inicial,
        v_valor_inicial,
        'disponível',
        true
    FROM generate_series(1, v_qtd_inserir);

    RETURN jsonb_build_object(
        'ok', true,
        'message', 'Estoque adicionado com sucesso',
        'qtd_adicionada', v_qtd_inserir
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'ok', false,
        'message', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.atualizar_reservas_atrasadas()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  update produto_reservas
  set status = 'atrasado'
  where status = 'retirado'
    and data_devolucao is not null
    and data_devolucao < now();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.atualizar_respostas_por_usuario(id_usuario uuid, respostas jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_id_usuario alias for id_usuario;
begin
  update public.respostas r
  set 
    resposta = t.value ->> 'resposta',
    tipo_resposta = coalesce(t.value ->> 'tipo', 'texto'),
    atualizado_em = now()
  from jsonb_array_elements(respostas) as t(value)
  where 
    r.id_usuario = v_id_usuario
    and r.id_pergunta = (t.value ->> 'id')::uuid;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.buscar_produtos_dropdown(p_nome text DEFAULT NULL::text)
 RETURNS TABLE(id_produto uuid, nome_produto text, quantidade_total integer, disponiveis integer)
 LANGUAGE sql
AS $function$

SELECT
    p.id AS id_produto,
    p.nome AS nome_produto,
    (
        SELECT count(*)::integer
        FROM public.produto_estoque pe
        WHERE pe.id_produto = p.id
          AND pe.status_item != 'descartado'
    ) AS quantidade_total,
    (
        SELECT count(*)::integer
        FROM public.produto_estoque pe
        WHERE pe.id_produto = p.id
          AND pe.status_item != 'descartado'
          AND pe.status_disponibilidade = true
    ) AS disponiveis
FROM public.produtos p
WHERE 
      p_nome IS NULL
   OR trim(p_nome) = ''
   OR lower(p.nome) LIKE lower(p_nome) || '%'
ORDER BY p.nome
LIMIT 30;

$function$
;

CREATE OR REPLACE FUNCTION public.buscar_produtos_filtrados(p_texto text, p_id_tipo_produto text, p_id_categoria_produto text)
 RETURNS TABLE(id_produto uuid, nome_produto text, total_itens integer, qtd_disponiveis integer, qtd_indisponiveis integer, quantidade_reserva integer, mostrar_itens_estoque boolean, itens_estoque jsonb)
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
BEGIN
  RETURN QUERY

  ----------------------------------------------------------------------
  -- 1) Filtra produtos e já LIMITA para 30 ANTES de qualquer JOIN
  ----------------------------------------------------------------------
  WITH produtos_iniciais AS (
      SELECT *
      FROM produtos
      WHERE
        (p_texto IS NULL OR trim(p_texto) = '' OR nome ILIKE '%' || p_texto || '%')
        AND (
            p_id_tipo_produto IS NULL
            OR trim(p_id_tipo_produto) IN ('', '0', 'Todos')
            OR id_tipo_produto::text = p_id_tipo_produto
        )
        AND (
            p_id_categoria_produto IS NULL
            OR trim(p_id_categoria_produto) IN ('', '0', 'Todos')
            OR id_categoria_produto::text = p_id_categoria_produto
        )
      ORDER BY nome
      LIMIT 30   -- 🔥 SEMPRE 30 PRODUTOS
  ),

  ----------------------------------------------------------------------
  -- 2) Estoque somente dos 30 produtos acima
  ----------------------------------------------------------------------
  estoque AS (
      SELECT 
         e.id AS id_produto_estoque,
         e.id_produto
      FROM produto_estoque e
      JOIN produtos_iniciais p ON p.id = e.id_produto
  ),

  reservas_ativas AS (
      SELECT DISTINCT r.id_produto_estoque
      FROM produto_reservas r
      WHERE r.status IN ('reservado', 'retirado', 'atrasado')
  ),

  estoque_marcado AS (
      SELECT
        e.id_produto_estoque,
        e.id_produto,
        CASE
          WHEN ra.id_produto_estoque IS NOT NULL THEN 'indisponivel'
          ELSE 'disponivel'
        END AS situacao
      FROM estoque e
      LEFT JOIN reservas_ativas ra
        ON ra.id_produto_estoque = e.id_produto_estoque
  ),

  avarias AS (
      SELECT DISTINCT ON (a.id_produto_estoque)
        a.id_produto_estoque,
        a.id,
        a.status_reparo,
        a.descricao,
        a.tipo_avaria,
        a.imagem_avaria
      FROM produto_avarias a
      ORDER BY a.id_produto_estoque, a.data_entrada_avaria DESC
  )

  ----------------------------------------------------------------------
  -- 3) Resultado final
  ----------------------------------------------------------------------
  SELECT
    p.id                          AS id_produto,
    p.nome                        AS nome_produto,

    COUNT(em.id_produto_estoque)::int AS total_itens,

    SUM(CASE WHEN em.situacao='disponivel' THEN 1 ELSE 0 END)::int   AS qtd_disponiveis,
    SUM(CASE WHEN em.situacao='indisponivel' THEN 1 ELSE 0 END)::int AS qtd_indisponiveis,

    0::int AS quantidade_reserva,
    false AS mostrar_itens_estoque,

    jsonb_agg(
      jsonb_build_object(
        'id_produto_estoque', em.id_produto_estoque,
        'situacao', em.situacao,
        'avaria',
          CASE 
            WHEN av.id IS NULL THEN NULL
            ELSE jsonb_build_object(
              'id', av.id,
              'status_reparo', av.status_reparo,
              'descricao', av.descricao,
              'tipo_avaria', av.tipo_avaria,
              'imagem_avaria', av.imagem_avaria
            )
          END,
        'item_selecionado', false
      )
      ORDER BY em.id_produto_estoque
    ) AS itens_estoque

  FROM produtos_iniciais p
  LEFT JOIN estoque_marcado em ON em.id_produto = p.id
  LEFT JOIN avarias av ON av.id_produto_estoque = em.id_produto_estoque

  GROUP BY p.id, p.nome;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.buscar_produtos_por_nome(p_texto text)
 RETURNS TABLE(id uuid)
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  return query
  select p.id
  from produtos p
  where 
    p_texto is null or trim(p_texto) = '' 
    or p.nome ilike '%' || p_texto || '%';
end;
$function$
;

CREATE OR REPLACE FUNCTION public.calsala_check_sala_slot_calsala(p_sala_id uuid, p_slot_id uuid, p_data date)
 RETURNS TABLE(disponivel boolean, reserva_id uuid, status text)
 LANGUAGE sql
 STABLE
 SET search_path TO 'extensions', 'public'
AS $function$
  with r as (
    select id, status
    from public.sala_reservas
    where sala_id = p_sala_id
      and slot_id = p_slot_id
      and data    = p_data
      and status <> 'cancelado'
    limit 1
  )
  select
    (select count(*) = 0 from r) as disponivel,
    (select id     from r)       as reserva_id,
    (select status from r)       as status;
$function$
;

CREATE OR REPLACE FUNCTION public.check_email_existences(p_email text)
 RETURNS TABLE(exists_in_auth boolean, exists_in_user_expandido boolean, user_expandido_has_user_id boolean, user_expandido_id uuid, auth_user_id uuid, has_matricula boolean, qtd_matriculas integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_auth_id uuid;
  v_ux_id uuid;
  v_ux_user_id uuid;
  v_has_matricula boolean := false;
  v_qtd_matriculas int := 0;
BEGIN
  -- 🔹 Busca no auth.users (schema auth não tem RLS)
  SELECT u.id
    INTO v_auth_id
  FROM auth.users u
  WHERE u.email = p_email
  LIMIT 1;

  -- 🔹 Busca no user_expandido
  SELECT ue.id, ue.user_id
    INTO v_ux_id, v_ux_user_id
  FROM public.user_expandido ue
  WHERE ue.email = p_email
  LIMIT 1;

  -- 🔹 Verifica matrícula vinculada ao user_expandido
  IF v_ux_id IS NOT NULL THEN
    SELECT count(*)
      INTO v_qtd_matriculas
    FROM public.matriculas m
    WHERE m.id_aluno = v_ux_id
      AND m.status = 'Ativa';

    v_has_matricula := (v_qtd_matriculas > 0);
  END IF;

  -- 🔹 Retorno final
  exists_in_auth := (v_auth_id IS NOT NULL);
  exists_in_user_expandido := (v_ux_id IS NOT NULL);
  user_expandido_has_user_id := (v_ux_user_id IS NOT NULL);
  user_expandido_id := v_ux_id;
  auth_user_id := v_auth_id;
  has_matricula := v_has_matricula;
  qtd_matriculas := v_qtd_matriculas;

  RETURN NEXT;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.confere_respostas_processo(p_id_user uuid, p_respostas uuid[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_total int;
  v_preenchidas int;
  v_result jsonb;
begin
  -- total de perguntas a verificar
  v_total := array_length(p_respostas, 1);

  if v_total is null or v_total = 0 then
    return jsonb_build_object(
      'success', false,
      'mensagem', 'Nenhum id de pergunta informado.',
      'preenchidas', 0,
      'total', 0,
      'ok', false
    );
  end if;

  -- conta quantas respostas válidas existem para esse usuário e perguntas
  select count(*) into v_preenchidas
  from public.respostas r
  where r.id_usuario = p_id_user
    and r.id_pergunta = any(p_respostas)
    and r.resposta is not null
    and trim(r.resposta) <> '';

  v_result := jsonb_build_object(
    'success', true,
    'usuario', p_id_user,
    'total', v_total,
    'preenchidas', v_preenchidas,
    'ok', (v_preenchidas = v_total)
  );

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.confirmar_email_usuario(p_user_id uuid)
 RETURNS void
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  update auth.users
  set email_confirmed_at = now()
  where id = p_user_id;
$function$
;

CREATE OR REPLACE FUNCTION public.criar_estoque_para_produto(p_id_produto uuid, p_valor_inicial integer)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$declare
  v_id_estoque uuid;
begin
  -- Inserir o produto no estoque com a quantidade inicial
  insert into public.produto_estoque (
    id_produto,
    valor_inicial,
    valor_atual,
    status_disponibilidade
  )
  values (
    p_id_produto,   -- ID do produto
    p_valor_inicial,  -- Quantidade inicial
    p_valor_inicial,  -- Valor inicial igual ao valor atual no começo
    true  -- Status como disponível no início
  )
  returning id into v_id_estoque;  -- Armazenar o ID do estoque recém-criado

  -- Aqui você pode adicionar mais lógicas de controle, se necessário (ex: associar a sala ou kit, etc.)
  
  -- Optional: Retornar uma mensagem (apenas para monitoramento)
  raise notice 'Produto % inserido no estoque com % unidades.', p_id_produto, p_valor_inicial;
end;$function$
;

CREATE OR REPLACE FUNCTION public.criar_matricula(p_id_processo uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_user_sessao uuid;          -- usuário logado
  v_user_do_processo uuid;     -- user_id do processo
  v_turma uuid;                -- turma vinculada ao processo
  v_user_expandido uuid;       -- aluno (user_expandido)
  v_dt_ini timestamptz;
  v_dt_fim timestamptz;
  v_status text;
  v_matricula_existente uuid;
  v_matricula_id uuid;
BEGIN
  ---------------------------------------------------------
  -- 1) Usuário logado
  ---------------------------------------------------------
  v_user_sessao := auth.uid();

  ---------------------------------------------------------
  -- 2) Busca do processo
  ---------------------------------------------------------
  SELECT 
      p.user_id,
      p.turma_id,
      p.user_expandido_id,
      p.status,
      t.dt_ini_mat,
      t.dt_fim_mat
  INTO 
      v_user_do_processo,
      v_turma,
      v_user_expandido,
      v_status,
      v_dt_ini,
      v_dt_fim
  FROM processos p
  LEFT JOIN turmas t ON t.id = p.turma_id
  WHERE p.id = p_id_processo;

  IF v_user_do_processo IS NULL THEN
    RETURN jsonb_build_object('ok', false, 'motivo', 'processo_inexistente');
  END IF;

  ---------------------------------------------------------
  -- 3) Processo pertence ao usuário?
  ---------------------------------------------------------
  IF v_user_do_processo <> v_user_sessao THEN
    RETURN jsonb_build_object('ok', false, 'motivo', 'processo_nao_e_do_usuario');
  END IF;

  ---------------------------------------------------------
  -- 4) Status aprovado?
  ---------------------------------------------------------
  IF v_status <> 'Aprovado' THEN
    RETURN jsonb_build_object('ok', false, 'motivo', 'status_nao_aprovado');
  END IF;

  ---------------------------------------------------------
  -- 5) Período permitido (com 1 dia extra no fim)
  ---------------------------------------------------------
  IF v_dt_ini IS NOT NULL AND now() < v_dt_ini THEN
    RETURN jsonb_build_object('ok', false, 'motivo', 'antes_do_periodo');
  END IF;

  IF v_dt_fim IS NOT NULL AND now() > (v_dt_fim + INTERVAL '1 day') THEN
    RETURN jsonb_build_object('ok', false, 'motivo', 'apos_periodo');
  END IF;

  ---------------------------------------------------------
  -- 6) Matrícula já existe?
  ---------------------------------------------------------
  SELECT id INTO v_matricula_existente
  FROM matriculas
  WHERE id_aluno = v_user_expandido
    AND id_turma = v_turma;

  IF v_matricula_existente IS NOT NULL THEN
    -- Atualiza o processo se ainda estiver aprovado
    UPDATE processos 
    SET status = 'Matriculado', modificado_em = now(), modificado_por = v_user_sessao
    WHERE id = p_id_processo AND status = 'Aprovado';

    RETURN jsonb_build_object(
      'ok', true,
      'motivo', 'ja_existe',
      'id_matricula', v_matricula_existente
    );
  END IF;

  ---------------------------------------------------------
  -- 7) Criar matrícula nova
  ---------------------------------------------------------
  INSERT INTO matriculas (id_aluno, id_turma, status)
  VALUES (v_user_expandido, v_turma, 'Ativa')
  RETURNING id INTO v_matricula_id;

  ---------------------------------------------------------
  -- 8) Atualizar processo
  ---------------------------------------------------------
  UPDATE processos
  SET 
    status = 'Matriculado',
    modificado_em = now(),
    modificado_por = v_user_sessao
  WHERE id = p_id_processo;

  ---------------------------------------------------------
  -- 9) Retorno final
  ---------------------------------------------------------
  RETURN jsonb_build_object(
    'ok', true,
    'motivo', 'criada',
    'id_matricula', v_matricula_id
  );

END;
$function$
;

CREATE OR REPLACE FUNCTION public.criar_processo_unico(p_id_user_expandido uuid, p_id_candidatura uuid, p_tipo_candidatura tipo_candidatura, p_tipo_processo tipo_processo)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    v_user_id uuid;
    v_papel_id uuid;
    v_exist uuid;
    v_id_processo uuid;
BEGIN
    --------------------------------------------------------------------
    -- 1) Número de vezes que aluno clica → idempotência total
    --------------------------------------------------------------------
    SELECT id INTO v_exist
    FROM public.processos
    WHERE user_expandido_id = p_id_user_expandido
      AND turma_id = p_id_candidatura   -- HOJE é turma
      AND tipo_processo = p_tipo_processo
      AND tipo_candidatura = p_tipo_candidatura
    LIMIT 1;

    IF v_exist IS NOT NULL THEN
        RETURN jsonb_build_object(
            'ok', true,
            'acao', 'ignorado',
            'mensagem', 'processo já existia',
            'id_processo', v_exist
        );
    END IF;

    --------------------------------------------------------------------
    -- 2) Buscar user_id (auth) no user_expandido
    --------------------------------------------------------------------
    SELECT user_id INTO v_user_id
    FROM public.user_expandido
    WHERE id = p_id_user_expandido;

    --------------------------------------------------------------------
    -- 3) Buscar papel do usuário
    --------------------------------------------------------------------
    SELECT papel_id INTO v_papel_id
    FROM public.papeis_user_auth
    WHERE user_id = v_user_id
    LIMIT 1;

    --------------------------------------------------------------------
    -- 4) Criar processo
    --------------------------------------------------------------------
    INSERT INTO public.processos (
        user_id,
        user_expandido_id,
        turma_id,              -- HOJE é turma, futuro mudamos aqui
        tipo_candidatura,
        tipo_processo,
        papel_user,
        status               -- deixa NULL para o sistema definir depois
    )
    VALUES (
        v_user_id,
        p_id_user_expandido,
        p_id_candidatura,
        p_tipo_candidatura,
        p_tipo_processo,
        v_papel_id,
        NULL
    )
    RETURNING id INTO v_id_processo;

    --------------------------------------------------------------------
    -- 5) Retorno final
    --------------------------------------------------------------------
    RETURN jsonb_build_object(
        'ok', true,
        'acao', 'criado',
        'id_processo', v_id_processo
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.criar_reserva_sala_multipla(p_id_sala_horario uuid, p_data date, p_evento text DEFAULT NULL::text, p_id_turma uuid DEFAULT NULL::uuid, p_observacao text DEFAULT NULL::text, p_status text DEFAULT 'reservado'::text, p_dois_periodos boolean DEFAULT false, p_dia_todo boolean DEFAULT false)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_id_sala uuid;
  v_turno text;
  v_id_horario_base uuid;         -- FK p/ slot_horarios
  v_ids_horarios uuid[];          -- ids de salas_horarios a reservar
  v_bloqueados uuid[] := array[
    'bc97509e-d478-4600-91ac-c3ae93035781'::uuid, -- almoço 12:00-13:00
    'a3de0190-c987-4959-b8bb-3f1bc77147f8'::uuid  -- jantar 17:30-18:00
  ];
  horario_id uuid;
  v_new_id uuid;
  v_created_ids uuid[] := array[]::uuid[];
  v_msg text;
begin
  -- precisa ter ao menos evento OU turma
  if p_evento is null and p_id_turma is null then
    return jsonb_build_object('success', false,
                              'message', 'Você deve informar ao menos um evento ou uma turma para a reserva.');
  end if;

  -- pega dados base do sala_horário enviado
  select id_sala, turno_cod, id_horario
    into v_id_sala, v_turno, v_id_horario_base
  from salas_horarios
  where id = p_id_sala_horario;

  if v_id_sala is null then
    return jsonb_build_object('success', false, 'message', 'Sala/horário inválido.');
  end if;

  -- Bloqueio de almoço/jantar SÓ quando for multi-escopo (dois períodos ou dia todo)
  if (p_dois_periodos or p_dia_todo) and v_id_horario_base = any (v_bloqueados) then
    return jsonb_build_object('success', false,
                              'message', 'Horário indisponível para reserva (intervalo de almoço/jantar).');
  end if;

  -- determina escopo
  if p_dois_periodos then
    -- mesmo turno, excluindo bloqueados
    select coalesce(array_agg(sh.id), array[]::uuid[])
      into v_ids_horarios
    from salas_horarios sh
    where sh.id_sala = v_id_sala
      and sh.turno_cod = v_turno
      and sh.id_horario <> all (v_bloqueados);

  elsif p_dia_todo then
    -- dia todo da sala, excluindo bloqueados
    select coalesce(array_agg(sh.id), array[]::uuid[])
      into v_ids_horarios
    from salas_horarios sh
    where sh.id_sala = v_id_sala
      and sh.id_horario <> all (v_bloqueados);

  else
    -- único horário SEJA ELE QUAL FOR (inclusive bloqueados)
    v_ids_horarios := array[p_id_sala_horario];
  end if;

  -- fallback defensivo
  if v_ids_horarios is null or array_length(v_ids_horarios,1) is null then
    v_ids_horarios := array[p_id_sala_horario];
  end if;

  -- conflito? (qualquer um no escopo) – ignora cancelados
  if exists (
    select 1
    from sala_reservas r
    where r.data = p_data
      and r.sala_horario_id = any (v_ids_horarios)
      and r.status <> 'cancelado'
  ) then
    v_msg := format(
      'Já existe uma reserva em %s para %s.',
      to_char(p_data, 'DD/MM/YYYY'),
      case when (not p_dois_periodos and not p_dia_todo)
           then 'o horário escolhido'
           else 'os horários escolhidos'
      end
    );

    return jsonb_build_object('success', false, 'message', v_msg);
  end if;

  -- insere todas as reservas do escopo
  foreach horario_id in array v_ids_horarios loop
    insert into sala_reservas (sala_horario_id, data, evento, turma_id, observacoes, status)
    values (horario_id, p_data, p_evento, p_id_turma, p_observacao, p_status)
    returning id into v_new_id;

    v_created_ids := array_append(v_created_ids, v_new_id);
  end loop;

  return jsonb_build_object(
    'success', true,
    'message', 'Reservas criadas com sucesso.',
    'reserved_count', coalesce(array_length(v_ids_horarios,1), 0),
    'ids', v_created_ids
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.criar_reservas_por_array(p_itens jsonb, p_id_usuario uuid, p_data_reserva timestamp with time zone, p_data_devolucao timestamp with time zone)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    v_produto jsonb;
    v_item jsonb;
    v_id_produto uuid;
    v_id_item uuid;
    v_id_avaria uuid;
    v_reserva_id uuid;
    v_criadas int := 0;
BEGIN

    --------------------------------------------------------------------
    -- LOOP por cada produto enviado
    --------------------------------------------------------------------
    FOR v_produto IN SELECT * FROM jsonb_array_elements(p_itens)
    LOOP
        v_id_produto := (v_produto->>'id_produto')::uuid;

        ----------------------------------------------------------------
        -- LOOP por cada item dentro do produto
        ----------------------------------------------------------------
        FOR v_item IN SELECT * FROM jsonb_array_elements(v_produto->'itens')
        LOOP
            -- só cria reserva se item_selecionado = true
            IF (v_item->>'item_selecionado')::boolean IS DISTINCT FROM TRUE THEN
                CONTINUE;
            END IF;

            v_id_item := (v_item->>'id_produto_estoque')::uuid;

            ----------------------------------------------------------------
            -- Se existir avaria no item, pega o ID
            ----------------------------------------------------------------
            v_id_avaria := NULL;

            IF v_item->'avaria' IS NOT NULL THEN
                IF (v_item->'avaria'->>'id') IS NOT NULL THEN
                    v_id_avaria := (v_item->'avaria'->>'id')::uuid;
                END IF;
            END IF;

            ----------------------------------------------------------------
            -- Criar reserva
            ----------------------------------------------------------------
            INSERT INTO produto_reservas (
                id_produto,
                id_produto_estoque,
                id_usuario,
                data_reserva,
                data_devolucao,
                status,
                id_avaria,
                created_at,
                updated_at
            )
            VALUES (
                v_id_produto,
                v_id_item,
                p_id_usuario,
                p_data_reserva AT TIME ZONE 'America/Sao_Paulo',
                p_data_devolucao AT TIME ZONE 'America/Sao_Paulo',
                'reservado',
                v_id_avaria,
                now() AT TIME ZONE 'America/Sao_Paulo',
                now() AT TIME ZONE 'America/Sao_Paulo'
            )
            RETURNING id INTO v_reserva_id;

            v_criadas := v_criadas + 1;

            ----------------------------------------------------------------
            -- Atualizar item do estoque → reservado
            ----------------------------------------------------------------
            UPDATE produto_estoque
            SET 
                status_disponibilidade = false,
                status_item = 'reservado',
                updated_at = now() AT TIME ZONE 'America/Sao_Paulo'
            WHERE id = v_id_item;
        END LOOP;
    END LOOP;

    RETURN jsonb_build_object(
        'ok', true,
        'reservas_criadas', v_criadas
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE
  claims jsonb;
  role_nome text;
BEGIN
  -- Busca o nome do papel associado ao usuário logado
  SELECT p.nome
  INTO role_nome
  FROM public.papeis_user_auth pa
  JOIN public.papeis_user p ON pa.papel_id = p.id
  WHERE pa.user_id = (event->>'user_id')::uuid
  LIMIT 1;

  claims := event->'claims';

  -- Se encontrou papel, adiciona no claim
  IF role_nome IS NOT NULL THEN
    claims := jsonb_set(claims, '{papeis_user}', to_jsonb(role_nome));
  ELSE
    claims := jsonb_set(claims, '{papeis_user}', 'null');
  END IF;

  RETURN jsonb_set(event, '{claims}', claims);
END;$function$
;

CREATE OR REPLACE FUNCTION public.dados_preencher_id_usuario()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Se id_usuario for NULL e tivermos user_expandido_id
    IF NEW.id_usuario IS NULL AND NEW.user_expandido_id IS NOT NULL THEN
        SELECT user_id INTO NEW.id_usuario
        FROM public.user_expandido
        WHERE id = NEW.user_expandido_id;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_curso(p_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_exists boolean;
begin
  -- 1️⃣ Verifica se o curso existe
  select exists(select 1 from public.curso where id = p_id)
  into v_exists;

  if not v_exists then
    return jsonb_build_object(
      'status', 'erro',
      'mensagem', 'Curso não encontrado'
    );
  end if;

  -- 2️⃣ Deleta os encontros relacionados (graças ao CASCADE, isso é opcional)
  delete from public.curso_encontros where id_curso = p_id;

  -- 3️⃣ Deleta o curso
  delete from public.curso where id = p_id;

  return jsonb_build_object(
    'status', 'ok',
    'mensagem', 'Curso e encontros associados foram removidos',
    'id_curso', p_id
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_inscricao_processo(p_processo_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- 1. Deletar o registro do processo seletivo pelo ID
    -- As respostas associadas não são deletadas (exigência do usuário)
    DELETE FROM public.processos
    WHERE id = p_processo_id;

    RAISE NOTICE 'Processo seletivo removido. ID: %', p_processo_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_turma_admin(p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_exist boolean;
  v_result jsonb;
begin
  -- 1️⃣ Verifica se a turma existe
  select exists(select 1 from public.turmas where id = p_id_turma)
  into v_exist;

  if not v_exist then
    return jsonb_build_object(
      'success', false,
      'mensagem', format('Turma com id %s não encontrada.', p_id_turma)
    );
  end if;

  -- 2️⃣ Apaga os dias da semana (caso existam)
  delete from public.turmas_dias where id_turma = p_id_turma;

  -- 3️⃣ Apaga a turma
  delete from public.turmas where id = p_id_turma;

  -- 4️⃣ Retorno de sucesso
  v_result := jsonb_build_object(
    'success', true,
    'mensagem', 'Turma e dias da semana removidos com sucesso.',
    'id_turma', p_id_turma
  );

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.diario_registrar_presenca(p_id_aluno uuid, p_id_turma uuid, p_area text, p_data timestamp with time zone, p_p1 status_presenca, p_p2 status_presenca, p_p3 status_presenca, p_p4 status_presenca, p_justificativa text, p_id_user uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_result jsonb;
  v_id_item_sharepoint text;
  v_id uuid;
begin
  update public.diario d
     set p1 = coalesce(p_p1, d.p1),
         p2 = coalesce(p_p2, d.p2),
         p3 = coalesce(p_p3, d.p3),
         p4 = coalesce(p_p4, d.p4),
         area = coalesce(p_area, d.area),
         justificativa = coalesce(p_justificativa, d.justificativa),
         atualizado = false,
         modificado_em = now(),
         modificado_por = p_id_user
   where d.id_aluno = p_id_aluno
     and d.id_turma = p_id_turma
     and (d.data at time zone 'America/Sao_Paulo')::date
         = (p_data at time zone 'America/Sao_Paulo')::date
   returning d.id, d.id_item_sharepoint into v_id, v_id_item_sharepoint;

  if found then
    v_result := jsonb_build_object(
      'status', 'atualizado',
      'success', true,
      'id', v_id,
      'id_item_sharepoint', v_id_item_sharepoint
    );
  else
    insert into public.diario (
      id_aluno, id_turma, data,
      area, p1, p2, p3, p4,
      justificativa, atualizado,
      criado_em, criado_por,
      data_recebida_texto
    )
    values (
      p_id_aluno, p_id_turma, p_data,  -- 👈 insere direto
      p_area, p_p1, p_p2, p_p3, p_p4,
      p_justificativa, false,
      now(), p_id_user,
      p_data::text                     -- 👈 log do que veio
    )
    returning id, id_item_sharepoint into v_id, v_id_item_sharepoint;

    v_result := jsonb_build_object(
      'status', 'inserido',
      'success', true,
      'id', v_id,
      'id_item_sharepoint', v_id_item_sharepoint
    );
  end if;

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.diario_registrar_presenca_v2(p_id_matricula uuid, p_data timestamp with time zone, p_p1 status_presenca, p_p2 status_presenca, p_p3 status_presenca, p_p4 status_presenca, p_justificativa text, p_criador uuid, p_area text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
declare
  v_result jsonb;
  v_id_item_sharepoint text;
  v_id uuid;
  v_id_aluno uuid;
  v_id_turma uuid;
begin
  -- 1. Look up student and class from matricula (Safety check & NOT NULL satisfaction)
  SELECT id_aluno, id_turma INTO v_id_aluno, v_id_turma
  FROM public.matriculas
  WHERE id = p_id_matricula;

  IF v_id_aluno IS NULL THEN
     RAISE EXCEPTION 'Matricula % nao encontrada', p_id_matricula;
  END IF;

  -- 2. Try to update existing record by (id_matricula, data)
  update public.diario d
     set p1 = coalesce(p_p1, d.p1),
         p2 = coalesce(p_p2, d.p2),
         p3 = coalesce(p_p3, d.p3),
         p4 = coalesce(p_p4, d.p4),
         area = coalesce(p_area, d.area),
         justificativa = coalesce(p_justificativa, d.justificativa),
         atualizado = false,
         modificado_em = now(),
         modificado_por = p_criador -- Updated param name
   where d.id_matricula = p_id_matricula
     and (d.data at time zone 'America/Sao_Paulo')::date
         = (p_data at time zone 'America/Sao_Paulo')::date
   returning d.id, d.id_item_sharepoint into v_id, v_id_item_sharepoint;

  if found then
    v_result := jsonb_build_object(
      'status', 'atualizado',
      'success', true,
      'id', v_id,
      'id_item_sharepoint', v_id_item_sharepoint
    );
  else
    -- 3. Insert new record
    -- We provide v_id_aluno and v_id_turma explicitly to satisfy NOT NULL constraints immediately.
    insert into public.diario (
      id_matricula,
      id_aluno,
      id_turma,
      data,
      area, p1, p2, p3, p4,
      justificativa, atualizado,
      criado_em, criado_por,
      data_recebida_texto
    )
    values (
      p_id_matricula,
      v_id_aluno,
      v_id_turma,
      p_data,
      p_area, p_p1, p_p2, p_p3, p_p4,
      p_justificativa, false,
      now(), p_criador, -- Updated param name
      p_data::text
    )
    returning id, id_item_sharepoint into v_id, v_id_item_sharepoint;

    v_result := jsonb_build_object(
      'status', 'inserido',
      'success', true,
      'id', v_id,
      'id_item_sharepoint', v_id_item_sharepoint
    );
  end if;

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.email_threads_upsert(p_assunto text, p_mensagem text, p_escopo text, p_id_user_origem uuid, p_ano_semestre text DEFAULT NULL::text, p_status_thread text DEFAULT 'pendente'::text, p_id_turma uuid DEFAULT NULL::uuid, p_id_user_destino uuid DEFAULT NULL::uuid, p_filtro_area text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_existing_id uuid;
    v_new_id uuid;
BEGIN
    -- 1. DESINFECÇÃO / VALIDAÇÃO BÁSICA
    -- (Pode adicionar validações aqui se necessário, ex: id_turma required se escopo = turma)

    -- 2. VERIFICAÇÃO DE DUPLICIDADE (IDEMPOTÊNCIA)
    
    -- Case 1: Scope 'user'
    IF p_escopo = 'user' THEN
        SELECT id INTO v_existing_id
        FROM public.email_threads
        WHERE escopo = 'user'
          AND assunto = p_assunto
          AND mensagem = p_mensagem
          AND id_user_destino = p_id_user_destino
          AND created_at > now() - interval '1 hour' -- Opcional: Janela de tempo para considerar duplicado? 
          -- O usuário pediu "se existe... ignora". Sem janela de tempo, nunca mais poderá mandar o mesmo email para a mesma pessoa.
          -- Vou assumir uma janela de segurança (ex: 24h) ou verificação absoluta se for crítica. 
          -- Pelo pedido "verificar se existe", farei absoluto para o teste, mas alertarei sobre janela de tempo.
        LIMIT 1;

    -- Case 2: Scope 'turma'
    ELSIF p_escopo = 'turma' THEN
        SELECT id INTO v_existing_id
        FROM public.email_threads
        WHERE escopo = 'turma'
          AND assunto = p_assunto
          AND mensagem = p_mensagem
          AND id_turma = p_id_turma
        LIMIT 1;

    -- Case 3: Scope 'area'
    ELSIF p_escopo = 'area' THEN
        SELECT id INTO v_existing_id
        FROM public.email_threads
        WHERE escopo = 'area'
          AND assunto = p_assunto
          AND mensagem = p_mensagem
          -- Comparação de filtros e área. 
          -- Assumindo que para 'area', o filtro_area e ano_semestre definem a unicidade junto com o conteúdo.
          AND COALESCE(filtro_area, '') = COALESCE(p_filtro_area, '')
          AND COALESCE(ano_semestre, '') = COALESCE(p_ano_semestre, '')
        LIMIT 1;
    END IF;

    -- 3. AÇÃO: RETORNAR EXISTENTE OU INSERIR NOVO
    
    IF v_existing_id IS NOT NULL THEN
        RETURN jsonb_build_object(
            'status', 'ignorado',
            'mensagem', 'Thread duplicada detectada. Nenhuma ação realizada.',
            'id', v_existing_id
        );
    ELSE
        INSERT INTO public.email_threads (
            assunto,
            mensagem,
            escopo,
            ano_semestre,
            status_thread,
            id_turma,
            id_user_origem,
            id_user_destino,
            filtro_area
        ) VALUES (
            p_assunto,
            p_mensagem,
            p_escopo,
            p_ano_semestre,
            p_status_thread, -- Geralmente 'pendente'
            p_id_turma,
            p_id_user_origem,
            p_id_user_destino,
            p_filtro_area
        )
        RETURNING id INTO v_new_id;

        RETURN jsonb_build_object(
            'status', 'sucesso',
            'mensagem', 'Nova thread criada.',
            'id', v_new_id
        );
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object('status', 'erro', 'mensagem', SQLERRM);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.enviar_dados_processo(processo_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$declare
  turma_info record;
  aluno_info record;
  papel_nome text;
  payload jsonb;
  url text := 'https://default9774d10ef79b4bb2836d1e37117fb3.68.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/7bf0e429f06645509188560edc12d18d/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=SwtGBgXHKDurnpfGs340O6sFwltwuQ-bqEtNPlvQ5UU';
begin
  -- Obter informações da turma
  select
    t.nome_curso,
    t.ano_semestre,
    t.turno,
    t.id_sharepoint,
    t.area_curso
  into turma_info
  from processos p
  join turmas t on t.id = p.turma_id
  where p.id = processo_id;

  -- Obter informações do aluno
  select
    ue.id as id_supabase,  -- agora o id do user_expandido
    ue.nome,
    ue.sobrenome,
    ue.email
  into aluno_info
  from processos p
  join user_expandido ue on ue.id = p.user_expandido_id
  where p.id = processo_id;

  -- Obter nome do papel
  select pu.nome
  into papel_nome
  from processos p
  join papeis_user pu on pu.id = p.papel_user
  where p.id = processo_id;

  -- Montar o payload
  payload := jsonb_build_array(
    jsonb_build_object(
      'key', 'turma',
      'nome', turma_info.nome_curso,
      'ano_semestre', turma_info.ano_semestre,
      'turno', turma_info.turno,
      'id_sharepoint', turma_info.id_sharepoint,
      'area_curso', turma_info.area_curso
    ),
    jsonb_build_object(
      'key', 'aluno',
      'id_supabase', aluno_info.id_supabase,  -- nome permanece id_supabase!
      'nome', aluno_info.nome,
      'sobrenome', aluno_info.sobrenome,
      'email', aluno_info.email,
      'papel_user', papel_nome
    )
  );

  -- Enviar o webhook
  perform http_post(
    url,
    payload::text,
    'application/json'
  );
end;$function$
;

CREATE OR REPLACE FUNCTION public.fg_update_textos_listas_selecao()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.modificado_em = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fmt_minutos(p_minutos integer)
 RETURNS jsonb
 LANGUAGE sql
 IMMUTABLE
 SET search_path TO 'extensions', 'public'
AS $function$
  select jsonb_build_array(
    -- horas completas, sem truncar
    coalesce((p_minutos / 60)::text, '0'),
    -- minutos restantes (0..59) com 2 dígitos
    lpad((coalesce(p_minutos,0) % 60)::text, 2, '0'),
    coalesce(p_minutos,0)
  );
$function$
;

CREATE OR REPLACE FUNCTION public.fn_avalia_prevalencia_fonte()
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  update public.stg_definitivo_diario s
  set fonte_prevalece = true
  from public.diario d
  where s.id_aluno_supabase = d.id_aluno
    and s.id_turma_supabase = d.id_turma
    and s.data_formato_supabase = d.data
    and s.existe_no_diario = true
    and (
      lower(s.p1) = 'abonada'
      or lower(s.p2) = 'abonada'
    );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_email_queue_batch_lock(p_thread_id uuid, p_batch_size integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    v_batch_data jsonb;
BEGIN
    -- 1. Tenta travar N itens que estão 'aguardando'
    -- Usa FOR UPDATE SKIP LOCKED para evitar contenção se houver múltiplos processadores (embora aqui seja sequencial)
    
    WITH itens_selecionados AS (
        SELECT id
        FROM public.email_queue
        WHERE id_thread = p_thread_id
          AND status_fila = 'aguardando'
        ORDER BY created_at ASC
        LIMIT p_batch_size
        FOR UPDATE SKIP LOCKED
    ),
    itens_atualizados AS (
        UPDATE public.email_queue
        SET 
            status_fila = 'enviando',
            -- data_envio = now(), -- Data envio é quando realmente for para o Power Automate? Ou quando sai da fila? Vamos deixar NULL ou setar agora. O padrão anterior era NULL.
            updated_at = now()
        WHERE id IN (SELECT id FROM itens_selecionados)
        RETURNING id, email_destino, mensagem, assunto
    )
    SELECT 
        jsonb_agg(to_jsonb(itens_atualizados.*))
    INTO v_batch_data
    FROM itens_atualizados;

    -- 2. Trata caso de array vazio
    IF v_batch_data IS NULL THEN
        RETURN jsonb_build_object(
            'batch_count', 0,
            'batch_data', '[]'::jsonb
        );
    END IF;

    -- 3. Atualiza o status da Thread para 'enviando' (Gatilho da Edge Function)
    -- IMPORTANTE: Atualiza updated_at para garantir que o Supabase detecte evento,
    -- mesmo que o status já fosse 'enviando'.
    UPDATE public.email_threads
    SET 
        status_thread = 'enviando',
        updated_at = now()
    WHERE id = p_thread_id;

    RETURN jsonb_build_object(
        'batch_count', jsonb_array_length(v_batch_data),
        'batch_data', v_batch_data
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_email_queue_update_and_retrigger(p_thread_id uuid, p_lote_enviado_ids uuid[], p_lote_falha_ids uuid[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
    v_total_atualizado int;
    v_aguardando_count int;
    v_lock_result jsonb;
    v_novo_thread_status varchar;
begin

    -- 1. ATUALIZAR ITENS DA QUEUE (SUCESSO)
    with sucesso as (
        update email_queue
        set status_fila = 'enviado', updated_at = now()
        where id = any(p_lote_enviado_ids)
        returning id
    )
    select count(id) into v_total_atualizado from sucesso;

    -- 2. ATUALIZAR ITENS DA QUEUE (FALHA)
    with falha as (
        update email_queue
        set status_fila = 'erro', updated_at = now()
        where id = any(p_lote_falha_ids)
        returning id
    )
    select v_total_atualizado + count(id) into v_total_atualizado from falha;

    -- 3. RESET DE SINALIZAÇÃO (CRÍTICO)
    -- Define status para 'processando' para garantir que a próxima mudança para 'enviando'
    -- seja detectada como uma ALTERAÇÃO de estado (old != new) pelo trigger do Supabase.
    update email_threads
    set status_thread = 'processando', updated_at = now()
    where id = p_thread_id;

    -- 4. VERIFICAÇÃO E RE-DISPARO
    
    -- Conta quantos itens AINDA PRECISAM ser processados
    select count(id)
    into v_aguardando_count
    from email_queue
    where id_thread = p_thread_id
      and status_fila = 'aguardando';

    if v_aguardando_count > 0 then
        -- RE-DISPARO: Chama a função de bloqueio.
        -- Esta função vai alterar o status_thread de volta para 'enviando'.
        -- Transição: processando -> enviando (Gatilho OK!)
        select public.fn_email_queue_batch_lock(p_thread_id, 10) into v_lock_result;
        v_novo_thread_status := 'enviando';

    else
        -- FINALIZAÇÃO: Não há mais itens.
        -- Transição: processando -> completa
        update email_threads
        set status_thread = 'completa', updated_at = now()
        where id = p_thread_id
        returning status_thread into v_novo_thread_status;
        
        v_lock_result := null;
    end if;

    -- 5. RETORNO
    return jsonb_build_object(
        'status', 'sucesso',
        'mensagem', 'Ciclo finalizado.',
        'total_atualizado', v_total_atualizado,
        'aguardando_restantes', v_aguardando_count,
        'thread_status_final', v_novo_thread_status,
        'lock_attempt', coalesce(v_lock_result, 'null'::jsonb)
    );

exception
    when others then
        return jsonb_build_object('status', 'erro', 'mensagem', SQLERRM);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_gerar_ra()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
DECLARE
    v_max_codigo INT;
    v_qtd_no_milhar INT;
    v_milhar INT;
    v_codigo INT;
BEGIN
    -- ✅ Se já existe RA para o aluno, ignora este insert
    IF EXISTS (SELECT 1 FROM ra_alunos WHERE id_aluno = NEW.id_aluno) THEN
        RETURN NULL; -- cancela o insert silenciosamente
    END IF;

    -- valores padrão
    v_milhar := 1;
    v_codigo := 1;

    -- pega último milhar para o ano/semestre
    SELECT COALESCE(MAX(milhar), 1)
      INTO v_milhar
    FROM ra_alunos
    WHERE ano_ingresso = NEW.ano_ingresso
      AND semestre_ingresso = NEW.semestre_ingresso;

    -- conta quantos registros já existem nesse milhar
    SELECT COUNT(*)
      INTO v_qtd_no_milhar
    FROM ra_alunos
    WHERE ano_ingresso = NEW.ano_ingresso
      AND semestre_ingresso = NEW.semestre_ingresso
      AND milhar = v_milhar;

    -- se chegou no limite de 999, abre novo milhar
    IF v_qtd_no_milhar >= 999 THEN
        v_milhar := v_milhar + 1;
        v_codigo := 1;
    ELSE
        -- pega próximo código dentro do milhar atual
        SELECT COALESCE(MAX(codigo_lista_ano_semestre), 0) + 1
          INTO v_codigo
        FROM ra_alunos
        WHERE ano_ingresso = NEW.ano_ingresso
          AND semestre_ingresso = NEW.semestre_ingresso
          AND milhar = v_milhar;
    END IF;

    -- preenche campos calculados
    NEW.milhar := v_milhar;
    NEW.codigo_lista_ano_semestre := v_codigo;

    NEW.ra := 'RA-' ||
              RIGHT(NEW.ano_ingresso, 2) ||
              CASE
                  WHEN NEW.semestre_ingresso = 1 THEN (1 + (v_milhar - 1) * 2)::text
                  WHEN NEW.semestre_ingresso = 2 THEN (2 + (v_milhar - 1) * 2)::text
              END ||
              LPAD(v_codigo::text, 3, '0');

    NEW.criado_em := COALESCE(NEW.criado_em, now());
    NEW.atualizado_em := now();

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_gerar_ra_matricula()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_ano_semestre text;
    v_ano text;
    v_semestre smallint;
BEGIN
    -- Busca ano_semestre da turma
    SELECT ano_semestre INTO v_ano_semestre
    FROM public.turmas
    WHERE id = NEW.id_turma;

    -- Se encontrou a turma e tem ano_semestre preenchido
    IF v_ano_semestre IS NOT NULL THEN
        -- Extrai o ano (assumindo formato YY...) -> 20YY
        -- Ex: 26Is -> 2026
        v_ano := '20' || substring(v_ano_semestre from 1 for 2);
        
        -- Define o semestre baseado no sufixo
        -- Ex: 26Is -> 1, 26IIs -> 2
        IF v_ano_semestre LIKE '%IIs' THEN
            v_semestre := 2;
        ELSIF v_ano_semestre LIKE '%Is' THEN
            v_semestre := 1;
        ELSE 
            -- Se não corresponder ao padrão esperado, não gera RA (ou pode-se logs erro)
            -- Por segurança, retornamos sem fazer nada se o formato for desconhecido
            RETURN NEW; 
        END IF;

        -- Chama a função determinística existente para gerar e inserir o RA
        -- Ora, a função já verifica se o aluno tem RA (idempotência)
        PERFORM public.gerar_ra_aluno_deterministico(
            NEW.id_aluno, 
            v_ano, 
            v_semestre, 
            NULL -- ra_legado
        );
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_normalizar_texto_envio(p_texto text)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    v_texto text;
BEGIN
    IF p_texto IS NULL THEN
        RETURN NULL;
    END IF;

    v_texto := lower(p_texto);
    
    -- Remoção manual de acentos
    v_texto := replace(v_texto, 'á', 'a');
    v_texto := replace(v_texto, 'à', 'a');
    v_texto := replace(v_texto, 'ã', 'a');
    v_texto := replace(v_texto, 'â', 'a');
    v_texto := replace(v_texto, 'ä', 'a');
    
    v_texto := replace(v_texto, 'é', 'e');
    v_texto := replace(v_texto, 'è', 'e');
    v_texto := replace(v_texto, 'ê', 'e');
    v_texto := replace(v_texto, 'ë', 'e');
    
    v_texto := replace(v_texto, 'í', 'i');
    v_texto := replace(v_texto, 'ì', 'i');
    v_texto := replace(v_texto, 'î', 'i');
    v_texto := replace(v_texto, 'ï', 'i');
    
    v_texto := replace(v_texto, 'ó', 'o');
    v_texto := replace(v_texto, 'ò', 'o');
    v_texto := replace(v_texto, 'õ', 'o');
    v_texto := replace(v_texto, 'ô', 'o');
    v_texto := replace(v_texto, 'ö', 'o');
    
    v_texto := replace(v_texto, 'ú', 'u');
    v_texto := replace(v_texto, 'ù', 'u');
    v_texto := replace(v_texto, 'û', 'u');
    v_texto := replace(v_texto, 'ü', 'u');
    
    v_texto := replace(v_texto, 'ç', 'c');
    v_texto := replace(v_texto, 'ñ', 'n');
    
    -- Substituição de separadores
    v_texto := replace(v_texto, ' ', '_');
    v_texto := replace(v_texto, '-', '_');
    
    RETURN v_texto;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_sync_link_video_processo()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_id_pergunta uuid := 'ef92aa9b-eed1-4009-adba-197719f4f0f3'::uuid;  -- pergunta link_video
  v_area public.tipo_area;
BEGIN

  --------------------------------------------------------------------
  -- Buscar área do curso da turma
  --------------------------------------------------------------------
  SELECT c.area
  INTO v_area
  FROM public.curso c
  WHERE c.id = NEW.id_curso;

  --------------------------------------------------------------------
  -- CASO 1 — link_video TRUE → criar registro se não existir
  --------------------------------------------------------------------
  IF NEW.link_video IS TRUE THEN
    
    INSERT INTO public.processo_documentos_obrigatorios (
      id,
      escopo,
      id_area,
      id_curso,
      id_turma,
      id_pergunta,
      obrigatorio,
      observacoes,
      tipo_processo,
      bloco,
      ordem,
      leitura,
      tipo_candidatura,
      largura_coluna,
      altura_coluna
    )
    SELECT
      gen_random_uuid(),
      'turma'::escopo_processo,
      v_area,               -- <<< AQUI AGORA VAI A ÁREA DO CURSO
      NULL,
      NEW.id,
      v_id_pergunta,
      TRUE,
      NULL,
      'seletivo'::tipo_processo,
      'documentos'::bloco_pergunta,
      8,
      FALSE,
      'estudante'::tipo_candidatura,
      'simples'::largura_coluna_tipo,
      'simples'::altura_coluna_tipo
    WHERE NOT EXISTS (
      SELECT 1 
      FROM public.processo_documentos_obrigatorios p
      WHERE p.id_turma = NEW.id
        AND p.id_pergunta = v_id_pergunta
        AND p.escopo = 'turma'
    );

    RETURN NEW;
  END IF;


  --------------------------------------------------------------------
  -- CASO 2 — link_video FALSE → remover registro se existir
  --------------------------------------------------------------------
  IF NEW.link_video IS FALSE THEN
    DELETE FROM public.processo_documentos_obrigatorios
    WHERE id_turma = NEW.id
      AND id_pergunta = v_id_pergunta
      AND escopo = 'turma';
  END IF;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_turmas_calendario_set_data()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.data := (new.start at time zone 'America/Sao_Paulo')::date;
  new.modificado_em := now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_update_timestamp_perg_avaliacao()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.modificado_em = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.fn_update_timestamp_turmas_dias_extra()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.modificado_em = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.gerar_calendario_turma(p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  result jsonb;
  turma record;
  dias int[];
  data_ref date;
  eventos jsonb := '[]'::jsonb;

  minutos_por_encontro numeric;
  minutos_totais numeric;
  minutos_por_modulo numeric;

  encontros_previstos int;
  encontros_regulares int := 0;
  encontros_extras int := 0;
  encontros_totais int := 0;

  qtd_feriados int := 0;
  ajuste text := null;
  nome_curso text;

  dia_extra record;
  eh_feriado boolean;

  hora_ini text;
  hora_fim text;
  ts_inicio timestamptz;
  ts_fim timestamptz;
begin
  -- 1️⃣ turma + curso
  select
    t.id,
    t.dt_ini_curso::date as ini,
    t.dt_fim_curso::date as fim,
    t.hora_ini,
    t.hora_fim,
    c.nome_curso as nome_curso_c,
    t.nome_curso as nome_curso_t,
    c.qtd_modulos, c.qtd_aulas_modulo, c.qtd_periodos,
    c.qtd_minutos_periodo, c.qtd_minutos_aula,
    c.qtd_minutos_modulo, c.qtd_minutos_total,
    t.turno, t.ano_semestre, t.id_curso
  into turma
  from public.turmas t
  left join public.curso c on c.id = t.id_curso
  where t.id = p_id_turma;

  if not found then
    return jsonb_build_object('erro','Turma não encontrada');
  end if;

  nome_curso := coalesce(turma.nome_curso_c, turma.nome_curso_t, 'Curso');

  if turma.ini is null or turma.fim is null then
    return jsonb_build_object('erro','Turma sem dt_ini_curso/dt_fim_curso');
  end if;

  hora_ini := coalesce(turma.hora_ini, '00:00');
  hora_fim := coalesce(turma.hora_fim, '00:00');

  -- 2️⃣ dias da semana da turma
  select array_agg(dia_da_semana_num order by dia_da_semana_num)
    into dias
  from public.turmas_dias
  where id_turma = p_id_turma;

  if dias is null or array_length(dias,1) = 0 then
    return jsonb_build_object('erro','Turma não possui dias da semana definidos');
  end if;

  -- 3️⃣ minutos e encontros
  minutos_por_encontro :=
    coalesce(
      nullif(turma.qtd_minutos_aula, 0),
      (nullif(turma.qtd_periodos,0) * nullif(turma.qtd_minutos_periodo,0)),
      case
        when nullif(turma.qtd_minutos_modulo,0) is not null
             and nullif(turma.qtd_aulas_modulo,0) is not null
        then (turma.qtd_minutos_modulo::numeric / turma.qtd_aulas_modulo::numeric)
        else null
      end
    );

  minutos_totais :=
    coalesce(
      nullif(turma.qtd_minutos_total, 0),
      case
        when nullif(turma.qtd_modulos,0) is not null
         and nullif(turma.qtd_aulas_modulo,0) is not null
         and minutos_por_encontro is not null
        then turma.qtd_modulos::numeric * turma.qtd_aulas_modulo::numeric * minutos_por_encontro
        else null
      end
    );

  minutos_por_modulo := case
    when turma.qtd_modulos is not null and turma.qtd_modulos > 0
    then minutos_totais / turma.qtd_modulos
    else minutos_totais
  end;

  encontros_previstos := ceil(minutos_por_modulo / minutos_por_encontro);

  -- 4️⃣ Gera aulas regulares com horário
  data_ref := turma.ini;
  while data_ref <= turma.fim loop
    if extract(isodow from data_ref)::int = any(dias) then
      -- checa feriado
      select exists(
        select 1 from public.feriados f where f.data_feriado::date = data_ref
      ) into eh_feriado;

      if not eh_feriado then
        encontros_regulares := encontros_regulares + 1;

        ts_inicio := make_timestamptz(
          extract(year from data_ref)::int,
          extract(month from data_ref)::int,
          extract(day from data_ref)::int,
          split_part(hora_ini, ':', 1)::int,
          split_part(hora_ini, ':', 2)::int,
          0,
          'America/Sao_Paulo'
        );

        ts_fim := make_timestamptz(
          extract(year from data_ref)::int,
          extract(month from data_ref)::int,
          extract(day from data_ref)::int,
          split_part(hora_fim, ':', 1)::int,
          split_part(hora_fim, ':', 2)::int,
          0,
          'America/Sao_Paulo'
        );

        eventos := eventos || jsonb_build_array(
          jsonb_build_object(
            'start', ts_inicio,
            'end', ts_fim,
            'title', format('%s — Encontro %s', nome_curso, encontros_regulares),
            'color', '#009C82',
            'data', jsonb_build_object('tipo','aula','id_turma',turma.id)
          )
        );
      end if;
    end if;
    data_ref := data_ref + interval '1 day';
  end loop;

  -- 5️⃣ Dias extras (mantêm mesmo se feriado)
  for dia_extra in
    select tec.data::date as data_dia, tec.dia_da_semana_text, tec.observacoes
    from public.turmas_dias_extra_calendario tec
    where tec.id_turma = turma.id
  loop
    encontros_extras := encontros_extras + 1;

    ts_inicio := make_timestamptz(
      extract(year from dia_extra.data_dia)::int,
      extract(month from dia_extra.data_dia)::int,
      extract(day from dia_extra.data_dia)::int,
      split_part(hora_ini, ':', 1)::int,
      split_part(hora_ini, ':', 2)::int,
      0,
      'America/Sao_Paulo'
    );

    ts_fim := make_timestamptz(
      extract(year from dia_extra.data_dia)::int,
      extract(month from dia_extra.data_dia)::int,
      extract(day from dia_extra.data_dia)::int,
      split_part(hora_fim, ':', 1)::int,
      split_part(hora_fim, ':', 2)::int,
      0,
      'America/Sao_Paulo'
    );

    eventos := eventos || jsonb_build_array(
      jsonb_build_object(
        'start', ts_inicio,
        'end', ts_fim,
        'title', format('%s — Aula Extra (%s)', nome_curso, coalesce(dia_extra.observacoes, dia_extra.dia_da_semana_text)),
        'color', '#87878D',
        'data', jsonb_build_object('tipo','aula_extra','id_turma',turma.id)
      )
    );
  end loop;

  -- 6️⃣ Feriados
  eventos := eventos || coalesce((
    select jsonb_agg(
             jsonb_build_object(
               'start', f.data_feriado,
               'end', f.data_feriado,
               'title', f.nome_feriado,
               'color', '#E7333F',
               'data', jsonb_build_object('tipo','feriado','id_turma',turma.id)
             )
           )
    from public.feriados f
    where f.data_feriado between turma.ini and turma.fim
  ), '[]'::jsonb);

  -- 7️⃣ Resumo
  encontros_totais := encontros_regulares + encontros_extras;
  ajuste := format(
    'Gerados %s encontros (%s regulares + %s extras).',
    encontros_totais, encontros_regulares, encontros_extras
  );

  result := jsonb_build_object(
    'eventos', eventos,
    'encontros_previstos', encontros_previstos,
    'encontros_regulares', encontros_regulares,
    'encontros_extras', encontros_extras,
    'encontros_totais', encontros_totais,
    'ajuste', ajuste
  );

  return result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.gerar_ra_aluno_deterministico(p_id_aluno uuid, p_ano character, p_semestre smallint, p_ra_legado text DEFAULT NULL::text)
 RETURNS ra_alunos
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_ra public.ra_alunos;
  v_email text;
  v_codigo_sequencial int;
  v_codigo_lista int;
  v_milhar int;
  v_ra_texto text;
  v_label text;
begin
  -- Se já existe RA para o aluno, retorna direto
  select * into v_ra
  from public.ra_alunos
  where id_aluno = p_id_aluno
  limit 1;

  if found then
    return v_ra;
  end if;

  -- Pega o e-mail
  select email into v_email
  from public.user_expandido
  where id = p_id_aluno;

  if v_email is null then
    raise exception 'Aluno não encontrado para o id %', p_id_aluno;
  end if;

  -- Calcular posição sequencial para este ano/semestre
  select count(*) + 1 into v_codigo_sequencial
  from public.ra_alunos ra
  join public.user_expandido ue on ue.id = ra.id_aluno
  where ra.ano_ingresso = p_ano
    and ra.semestre_ingresso = p_semestre
    and lower(ue.email) < lower(v_email); -- ordenação estável por email

  -- Milhar e código (como na sua lógica)
  if v_codigo_sequencial <= 999 then
    v_milhar := 1;
    v_codigo_lista := v_codigo_sequencial;
  elsif v_codigo_sequencial <= 1998 then
    v_milhar := 2;
    v_codigo_lista := v_codigo_sequencial - 999;
  elsif v_codigo_sequencial <= 2997 then
    v_milhar := 3;
    v_codigo_lista := v_codigo_sequencial - 1998;
  else
    v_milhar := 4;
    v_codigo_lista := v_codigo_sequencial - 2997;
  end if;

  -- Gerar RA formatado
  v_ra_texto := 'RA-' ||
                right(p_ano, 2) ||
                case
                  when p_semestre = 1 and v_milhar = 1 then '1'
                  when p_semestre = 2 and v_milhar = 1 then '2'
                  when p_semestre = 1 and v_milhar = 2 then '3'
                  when p_semestre = 2 and v_milhar = 2 then '4'
                  when p_semestre = 1 and v_milhar = 3 then '5'
                  when p_semestre = 2 and v_milhar = 3 then '6'
                  when p_semestre = 1 and v_milhar = 4 then '7'
                  else '8'
                end ||
                lpad(v_codigo_lista::text, 3, '0');

  -- Label
  v_label := right(p_ano, 2) || case p_semestre when 1 then 'Is' else 'IIs' end;

  -- Inserir
  insert into public.ra_alunos (
    id_aluno,
    ra,
    ra_legado,
    ano_ingresso,
    semestre_ingresso,
    ano_semestre_ingresso,
    codigo_lista_ano_semestre,
    milhar
  )
  values (
    p_id_aluno,
    v_ra_texto,
    p_ra_legado,
    p_ano,
    p_semestre,
    v_label,
    v_codigo_lista,
    v_milhar
  )
  returning * into v_ra;

  return v_ra;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_candidatos_processo_turma(p_id_turma uuid DEFAULT NULL::uuid, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 20, p_tipo_candidatura tipo_candidatura DEFAULT NULL::tipo_candidatura, p_busca text DEFAULT NULL::text, p_filtros jsonb DEFAULT '[]'::jsonb, p_pcd text DEFAULT NULL::text, p_laudo boolean DEFAULT NULL::boolean, p_ordenar_por text DEFAULT 'nome_completo'::text, p_ordenar_como text DEFAULT 'ASC'::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_result  jsonb;
  v_offset  int := (p_pagina - 1) * p_limite;
  v_filtros jsonb := p_filtros;

  -- IDs FIXOS
  v_id_genero uuid := '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea';
  v_id_raca   uuid := '9670c817-5db6-4055-8fc9-04cc15d6cd3e';
  v_id_renda  uuid := '98d09feb-ec9a-4a30-882d-7de8099c153f';
  v_id_foto   uuid := 'c95e476a-c4dc-4520-badd-d7392b0aeab7';
  v_id_nome_social uuid := '32b1a387-a2a9-4f79-af30-d32026af64fe';
  v_id_nome_artistico uuid := '5747a06b-2385-4920-af8a-48f8ec870518';
  v_id_data_nascimento uuid := '8925bdc2-538a-408d-bd34-fb64b2638621';

  -- ⭐ NOVOS
  v_id_pcd uuid := 'eae93308-1e4d-4c67-9c53-c9abf6a31eaf';
  v_id_laudo uuid := 'de76ebe6-38d2-44e1-a112-ee64ad604c4f';
BEGIN
  --------------------------------------------------------------------
  -- Normaliza filtros
  --------------------------------------------------------------------
  IF v_filtros IS NULL OR jsonb_typeof(v_filtros) <> 'array' THEN
    v_filtros := '[]'::jsonb;
  END IF;

  WITH

  --------------------------------------------------------------------
  -- BASE: um registro por processo
  --------------------------------------------------------------------
  base AS (
    SELECT
      pr.id         AS id_processo,
      pr.turma_id   AS id_turma,
      pr.created_at AS criado_em,
      pr.status     AS status_processo,
      pr.nota_total_processo,
      t.turno,
      t.nome_curso  AS nome_turma,
      c.nome_curso  AS nome_curso_oficial,
      c.area        AS area_curso,

      ux.id         AS id_user_expandido,
      ux.user_id,
      COALESCE(trim(ux.nome || ' ' || ux.sobrenome), ux.email) AS nome_completo,
      ux.email,
      ux.imagem_user,

      -- PERGUNTAS PADRÃO
      MAX(CASE WHEN r.id_pergunta = v_id_genero         THEN r.resposta        END) AS genero,
      MAX(CASE WHEN r.id_pergunta = v_id_raca           THEN r.resposta        END) AS raca,
      MAX(CASE WHEN r.id_pergunta = v_id_renda          THEN r.resposta        END) AS renda,
      MAX(CASE WHEN r.id_pergunta = v_id_foto           THEN r.arquivo_original END) AS imagem_arquivo,
      MAX(CASE WHEN r.id_pergunta = v_id_nome_social    THEN r.resposta        END) AS nome_social,
      MAX(CASE WHEN r.id_pergunta = v_id_nome_artistico THEN r.resposta        END) AS nome_artistico,
      MAX(CASE WHEN r.id_pergunta = v_id_data_nascimento THEN r.resposta       END) AS data_nascimento,

      -- ⭐ NOVOS CAMPOS
      MAX(CASE WHEN r.id_pergunta = v_id_pcd   THEN r.resposta        END) AS pcd,
      MAX(CASE WHEN r.id_pergunta = v_id_laudo THEN r.arquivo_original END) AS laudo_arquivo

    FROM public.processos pr
    JOIN public.user_expandido ux ON ux.id = pr.user_expandido_id
    LEFT JOIN public.respostas r   ON r.user_expandido_id = ux.id
    LEFT JOIN public.turmas t      ON t.id = pr.turma_id
    LEFT JOIN public.curso  c      ON c.id = t.id_curso

    WHERE
      (p_id_turma IS NULL OR pr.turma_id = p_id_turma)
      AND (p_tipo_candidatura IS NULL OR pr.tipo_candidatura = p_tipo_candidatura)
      AND (
          p_busca IS NULL
          OR unaccent(ux.nome) ILIKE unaccent('%' || p_busca || '%')
          OR unaccent(ux.sobrenome) ILIKE unaccent('%' || p_busca || '%')
          OR unaccent(ux.nome || ' ' || ux.sobrenome) ILIKE unaccent('%' || p_busca || '%')
      )

    GROUP BY
      pr.id,
      pr.turma_id,
      pr.created_at,
      pr.status,
      pr.nota_total_processo,
      t.turno,
      t.nome_curso,
      c.nome_curso,
      c.area,
      ux.id,
      ux.user_id,
      ux.nome,
      ux.sobrenome,
      ux.email,
      ux.imagem_user

    ORDER BY nome_completo ASC
  ),

  --------------------------------------------------------------------
  -- Filtros DO FRONT (já existentes)
  --------------------------------------------------------------------
  filtros AS (
    SELECT
      (f->>'id_pergunta')::uuid AS id_pergunta,
      f->>'resposta'            AS valor
    FROM jsonb_array_elements(v_filtros) f
  ),

  --------------------------------------------------------------------
  -- Perguntas válidas (avaliação) por PROCESSO
  --------------------------------------------------------------------
  perguntas_validas AS (
    SELECT
      b.id_user_expandido,
      b.id_processo,
      p.*
    FROM base b
    JOIN perguntas_avaliacao_processos p
      ON p.ativo = TRUE
     AND (
          (p.escopo = 'area'  AND p.area    = b.area_curso)
       OR (p.escopo = 'turma' AND p.id_turma = b.id_turma)
         )
  ),

  --------------------------------------------------------------------
  -- Flatten avaliação (inclui id_processo!)
  --------------------------------------------------------------------
  avaliacao_flat AS (
    SELECT DISTINCT ON (pv.id_processo, pv.id)
      pv.id_user_expandido,
      pv.id_processo,
      pv.id                  AS id_pergunta,
      pv.pergunta,
      pv.escopo,
      pv.tipo,
      pv.ordem,
      pv.opcoes,
      pv.opcao_default,
      ra.resposta_texto,

      CASE
        WHEN ra.resposta_texto IS NOT NULL THEN ra.resposta_texto
        WHEN pv.tipo = 'opcao'  AND pv.opcao_default IS NOT NULL THEN pv.opcao_default
        WHEN pv.tipo = 'numero' THEN '0'
        ELSE NULL
      END AS resposta_normalizada
    FROM perguntas_validas pv
    LEFT JOIN respostas_perguntas_avaliacao_processos ra
      ON ra.id_pergunta_processo = pv.id
     AND ra.id_user             = pv.id_user_expandido
     AND (
           -- REGRA DE OURO (Aplicada aqui também):
           -- 1. Escopo AREA: Aceita qualquer resposta deste user para esta pergunta (ignora id_processo).
           -- 2. Escopo TURMA: Exige que a resposta pertença a este processo (que está ligado à turma).
           (pv.escopo = 'area')
           OR
           (pv.escopo = 'turma' AND ra.id_processo = pv.id_processo)
           -- Mantemos compatibilidade com respostas legadas sem id_processo, se houver
           OR ra.id_processo IS NULL
         )
    -- Ordena para priorizar a resposta do PRÓPRIO processo se houver conflito (ex: para área, tem do processo atual A e do antigo B)
    ORDER BY pv.id_processo, pv.id, CASE WHEN ra.id_processo = pv.id_processo THEN 0 ELSE 1 END, ra.criado_em DESC
  ),

  --------------------------------------------------------------------
  -- Agregação da avaliação por (user, processo)
  --------------------------------------------------------------------
  avaliacao_agg AS (
    SELECT
      id_user_expandido,
      id_processo,
      jsonb_agg(
        jsonb_build_object(
          'id_pergunta',    id_pergunta,
          'pergunta',       pergunta,
          'escopo',         escopo,
          'tipo',           tipo,
          'ordem',          ordem,
          'opcoes',         opcoes,
          'opcao_default',  opcao_default,
          'resposta',       resposta_normalizada
        )
        ORDER BY ordem
      ) AS avaliacao
    FROM avaliacao_flat
    GROUP BY id_user_expandido, id_processo
  ),

  --------------------------------------------------------------------
  -- Calculado: idade (por processo também)
  --------------------------------------------------------------------
  calculado AS (
    SELECT
      b.*,
      a.avaliacao,
      CASE
        WHEN data_nascimento ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'
          THEN extract(year from age(current_date, data_nascimento::date))
        WHEN data_nascimento ~ '^[0-9]{2}/[0-9]{2}/[0-9]{4}$'
          THEN extract(year from age(current_date, to_date(data_nascimento, 'DD/MM/YYYY')))
        ELSE NULL
      END AS idade
    FROM base b
    LEFT JOIN avaliacao_agg a
      ON a.id_user_expandido = b.id_user_expandido
     AND a.id_processo       = b.id_processo
  ),

  --------------------------------------------------------------------
  -- ⭐ FILTROS PCD + LAUDO + filtros de avaliação
  --------------------------------------------------------------------
  filtrado AS (
    SELECT c.*
    FROM calculado c
    WHERE TRUE

    -- Filtros das perguntas normais (agora por processo também)
    AND NOT EXISTS (
      SELECT 1
      FROM filtros f
      LEFT JOIN avaliacao_flat af
        ON af.id_user_expandido = c.id_user_expandido
       AND af.id_processo       = c.id_processo
       AND af.id_pergunta       = f.id_pergunta
      WHERE af.resposta_normalizada IS DISTINCT FROM f.valor
    )

    ----------------------------------------------------------------
    -- ⭐ FILTRO PCD
    ----------------------------------------------------------------
    AND (
      p_pcd IS NULL
      OR (
        p_pcd = 'sim'
        AND unaccent(lower(c.pcd)) LIKE '%sim%'
      )
      OR (
        p_pcd = 'nao'
        AND (
          unaccent(lower(c.pcd)) LIKE '%nao%'
          OR unaccent(lower(c.pcd)) LIKE '%não%'
          OR unaccent(lower(c.pcd)) LIKE 'n'
        )
      )
    )

    ----------------------------------------------------------------
    -- ⭐ FILTRO LAUDO
    ----------------------------------------------------------------
    AND (
      p_laudo IS NULL
      OR (p_laudo = TRUE  AND c.laudo_arquivo IS NOT NULL)
      OR (p_laudo = FALSE AND c.laudo_arquivo IS NULL)
    )
  ),

  --------------------------------------------------------------------
  -- Paginação
  --------------------------------------------------------------------
  final_com_paginacao AS (
    SELECT
      f.*,
      COUNT(*) OVER() AS total_registros
    FROM filtrado f

    ORDER BY
        CASE
            WHEN p_ordenar_como = 'DESC' AND p_ordenar_por = 'created_at' THEN f.criado_em
        END DESC,
        CASE
            WHEN p_ordenar_como = 'DESC' AND p_ordenar_por = 'nome_completo' THEN f.nome_completo
        END DESC,
        CASE
            WHEN p_ordenar_como <> 'DESC' AND p_ordenar_por = 'created_at' THEN f.criado_em
        END ASC,
        CASE
            WHEN p_ordenar_como <> 'DESC' AND p_ordenar_por = 'nome_completo' THEN f.nome_completo
        END ASC

    LIMIT p_limite OFFSET v_offset
  )

  --------------------------------------------------------------------
  -- JSON FINAL
  --------------------------------------------------------------------
  SELECT jsonb_build_object(
    'pagina_atual', p_pagina,
    'qtd_paginas',  CEIL(MAX(total_registros) / p_limite::numeric),
    'qtd_total',    COALESCE(MAX(total_registros),0),
    'itens', COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'id_processo',       id_processo,
          'id_turma',          id_turma,
          'criado_em',         criado_em,
          'status_processo',   status_processo,

          'nome_curso',        nome_curso_oficial,
          'nome_turma',        nome_turma,
          'turno',             turno,

          'id_user_expandido', id_user_expandido,
          'nome_completo',     nome_completo,
          'nome_social',       nome_social,
          'nome_artistico',    nome_artistico,
          'email',             email,

          'genero',            genero,
          'raca',              raca,
          'renda',             renda,
          'idade',             idade,
          'imagem_user',       COALESCE(imagem_user, imagem_arquivo),
          'nota_total_processo', nota_total_processo,

          -- NOVOS
          'pcd',               pcd,
          'laudo_enviado',     (laudo_arquivo IS NOT NULL),

          'avaliacao',         avaliacao
        )
      ),
      '[]'::jsonb
    )
  )
  INTO v_result
  FROM final_com_paginacao;

  RETURN v_result;
END
$function$
;

CREATE OR REPLACE FUNCTION public.get_candidatos_processo_turma_v2(p_id_turma uuid DEFAULT NULL::uuid, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 20, p_tipo_candidatura tipo_candidatura DEFAULT NULL::tipo_candidatura, p_busca text DEFAULT NULL::text, p_filtros jsonb DEFAULT '[]'::jsonb, p_pcd text DEFAULT NULL::text, p_laudo boolean DEFAULT NULL::boolean, p_ordenar_por text DEFAULT 'nome_completo'::text, p_ordenar_como text DEFAULT 'ASC'::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_result  jsonb;
  v_offset  int := (p_pagina - 1) * p_limite;
  v_filtros jsonb := p_filtros;

  -- IDs FIXOS
  v_id_genero uuid := '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea';
  v_id_raca   uuid := '9670c817-5db6-4055-8fc9-04cc15d6cd3e';
  v_id_renda  uuid := '98d09feb-ec9a-4a30-882d-7de8099c153f';
  v_id_foto   uuid := 'c95e476a-c4dc-4520-badd-d7392b0aeab7';
  v_id_nome_social uuid := '32b1a387-a2a9-4f79-af30-d32026af64fe';
  v_id_nome_artistico uuid := '5747a06b-2385-4920-af8a-48f8ec870518';
  v_id_data_nascimento uuid := '8925bdc2-538a-408d-bd34-fb64b2638621';

  -- ⭐ NOVOS
  v_id_pcd uuid := 'eae93308-1e4d-4c67-9c53-c9abf6a31eaf';
  v_id_laudo uuid := 'de76ebe6-38d2-44e1-a112-ee64ad604c4f';
BEGIN
  --------------------------------------------------------------------
  -- Normaliza filtros
  --------------------------------------------------------------------
  IF v_filtros IS NULL OR jsonb_typeof(v_filtros) <> 'array' THEN
    v_filtros := '[]'::jsonb;
  END IF;

  WITH

  --------------------------------------------------------------------
  -- BASE: um registro por processo
  --------------------------------------------------------------------
  base AS (
    SELECT
      pr.id         AS id_processo,
      pr.turma_id   AS id_turma,
      pr.created_at AS criado_em,
      pr.status     AS status_processo,
      pr.nota_total_processo,
      t.turno,
      t.nome_curso  AS nome_turma,
      c.nome_curso  AS nome_curso_oficial,
      c.area        AS area_curso,

      ux.id         AS id_user_expandido,
      ux.user_id,
      COALESCE(trim(ux.nome || ' ' || ux.sobrenome), ux.email) AS nome_completo,
      ux.email,
      ux.imagem_user,

      -- PERGUNTAS PADRÃO
      MAX(CASE WHEN r.id_pergunta = v_id_genero         THEN r.resposta        END) AS genero,
      MAX(CASE WHEN r.id_pergunta = v_id_raca           THEN r.resposta        END) AS raca,
      MAX(CASE WHEN r.id_pergunta = v_id_renda          THEN r.resposta        END) AS renda,
      MAX(CASE WHEN r.id_pergunta = v_id_foto           THEN r.arquivo_original END) AS imagem_arquivo,
      MAX(CASE WHEN r.id_pergunta = v_id_nome_social    THEN r.resposta        END) AS nome_social,
      MAX(CASE WHEN r.id_pergunta = v_id_nome_artistico THEN r.resposta        END) AS nome_artistico,
      MAX(CASE WHEN r.id_pergunta = v_id_data_nascimento THEN r.resposta       END) AS data_nascimento,

      -- ⭐ NOVOS CAMPOS
      MAX(CASE WHEN r.id_pergunta = v_id_pcd   THEN r.resposta        END) AS pcd,
      MAX(CASE WHEN r.id_pergunta = v_id_laudo THEN r.arquivo_original END) AS laudo_arquivo

    FROM public.processos pr
    JOIN public.user_expandido ux ON ux.id = pr.user_expandido_id
    LEFT JOIN public.respostas r   ON r.user_expandido_id = ux.id
    LEFT JOIN public.turmas t      ON t.id = pr.turma_id
    LEFT JOIN public.curso  c      ON c.id = t.id_curso

    WHERE
      (p_id_turma IS NULL OR pr.turma_id = p_id_turma)
      AND (p_tipo_candidatura IS NULL OR pr.tipo_candidatura = p_tipo_candidatura)
      AND (
          p_busca IS NULL
          OR unaccent(ux.nome) ILIKE unaccent('%' || p_busca || '%')
          OR unaccent(ux.sobrenome) ILIKE unaccent('%' || p_busca || '%')
          OR unaccent(ux.nome || ' ' || ux.sobrenome) ILIKE unaccent('%' || p_busca || '%')
      )

    GROUP BY
      pr.id,
      pr.turma_id,
      pr.created_at,
      pr.status,
      pr.nota_total_processo,
      t.turno,
      t.nome_curso,
      c.nome_curso,
      c.area,
      ux.id,
      ux.user_id,
      ux.nome,
      ux.sobrenome,
      ux.email,
      ux.imagem_user

    ORDER BY nome_completo ASC
  ),

  --------------------------------------------------------------------
  -- Filtros DO FRONT (já existentes)
  --------------------------------------------------------------------
  filtros AS (
    SELECT
      (f->>'id_pergunta')::uuid AS id_pergunta,
      f->>'resposta'            AS valor
    FROM jsonb_array_elements(v_filtros) f
  ),

  --------------------------------------------------------------------
  -- Perguntas válidas (avaliação) por PROCESSO
  --------------------------------------------------------------------
  perguntas_validas AS (
    SELECT
      b.id_user_expandido,
      b.id_processo,
      p.*
    FROM base b
    JOIN perguntas_avaliacao_processos p
      ON p.ativo = TRUE
     AND (
          (p.escopo = 'area'  AND p.area    = b.area_curso)
       OR (p.escopo = 'turma' AND p.id_turma = b.id_turma)
         )
  ),

  --------------------------------------------------------------------
  -- Flatten avaliação (inclui id_processo!)
  --------------------------------------------------------------------
  avaliacao_flat AS (
    SELECT DISTINCT ON (pv.id_processo, pv.id)
      pv.id_user_expandido,
      pv.id_processo,
      pv.id                  AS id_pergunta,
      pv.pergunta,
      pv.escopo,
      pv.tipo,
      pv.ordem,
      pv.opcoes,
      pv.opcao_default,
      ra.resposta_texto,

      CASE
        WHEN ra.resposta_texto IS NOT NULL THEN ra.resposta_texto
        WHEN pv.tipo = 'opcao'  AND pv.opcao_default IS NOT NULL THEN pv.opcao_default
        WHEN pv.tipo = 'numero' THEN '0'
        ELSE NULL
      END AS resposta_normalizada
    FROM perguntas_validas pv
    LEFT JOIN respostas_perguntas_avaliacao_processos ra
      ON ra.id_pergunta_processo = pv.id
     AND ra.id_user             = pv.id_user_expandido
     AND (
           -- REGRA DE OURO (Aplicada aqui também):
           -- 1. Escopo AREA: Aceita qualquer resposta deste user para esta pergunta (ignora id_processo).
           -- 2. Escopo TURMA: Exige que a resposta pertença a este processo (que está ligado à turma).
           (pv.escopo = 'area')
           OR
           (pv.escopo = 'turma' AND ra.id_processo = pv.id_processo)
           -- Mantemos compatibilidade com respostas legadas sem id_processo, se houver
           OR ra.id_processo IS NULL
         )
    -- Ordena para priorizar a resposta do PRÓPRIO processo se houver conflito (ex: para área, tem do processo atual A e do antigo B)
    ORDER BY pv.id_processo, pv.id, CASE WHEN ra.id_processo = pv.id_processo THEN 0 ELSE 1 END, ra.criado_em DESC
  ),

  --------------------------------------------------------------------
  -- Agregação da avaliação por (user, processo)
  --------------------------------------------------------------------
  avaliacao_agg AS (
    SELECT
      id_user_expandido,
      id_processo,
      jsonb_agg(
        jsonb_build_object(
          'id_pergunta',    id_pergunta,
          'pergunta',       pergunta,
          'escopo',         escopo,
          'tipo',           tipo,
          'ordem',          ordem,
          'opcoes',         opcoes,
          'opcao_default',  opcao_default,
          'resposta',       resposta_normalizada
        )
        ORDER BY ordem
      ) AS avaliacao
    FROM avaliacao_flat
    GROUP BY id_user_expandido, id_processo
  ),

  --------------------------------------------------------------------
  -- Calculado: idade (por processo também)
  --------------------------------------------------------------------
  calculado AS (
    SELECT
      b.*,
      a.avaliacao,
      CASE
        WHEN data_nascimento ~ '^[0-9]{4}-[0-9]{2}-[0-9]{2}$'
          THEN extract(year from age(current_date, data_nascimento::date))
        WHEN data_nascimento ~ '^[0-9]{2}/[0-9]{2}/[0-9]{4}$'
          THEN extract(year from age(current_date, to_date(data_nascimento, 'DD/MM/YYYY')))
        ELSE NULL
      END AS idade
    FROM base b
    LEFT JOIN avaliacao_agg a
      ON a.id_user_expandido = b.id_user_expandido
     AND a.id_processo       = b.id_processo
  ),

  --------------------------------------------------------------------
  -- ⭐ FILTROS PCD + LAUDO + filtros de avaliação
  --------------------------------------------------------------------
  filtrado AS (
    SELECT c.*
    FROM calculado c
    WHERE TRUE

    -- Filtros das perguntas normais (agora por processo também)
    AND NOT EXISTS (
      SELECT 1
      FROM filtros f
      LEFT JOIN avaliacao_flat af
        ON af.id_user_expandido = c.id_user_expandido
       AND af.id_processo       = c.id_processo
       AND af.id_pergunta       = f.id_pergunta
      WHERE af.resposta_normalizada IS DISTINCT FROM f.valor
    )

    ----------------------------------------------------------------
    -- ⭐ FILTRO PCD
    ----------------------------------------------------------------
    AND (
      p_pcd IS NULL
      OR (
        p_pcd = 'sim'
        AND unaccent(lower(c.pcd)) LIKE '%sim%'
      )
      OR (
        p_pcd = 'nao'
        AND (
          unaccent(lower(c.pcd)) LIKE '%nao%'
          OR unaccent(lower(c.pcd)) LIKE '%não%'
          OR unaccent(lower(c.pcd)) LIKE 'n'
        )
      )
    )

    ----------------------------------------------------------------
    -- ⭐ FILTRO LAUDO
    ----------------------------------------------------------------
    AND (
      p_laudo IS NULL
      OR (p_laudo = TRUE  AND c.laudo_arquivo IS NOT NULL)
      OR (p_laudo = FALSE AND c.laudo_arquivo IS NULL)
    )
  ),

  --------------------------------------------------------------------
  -- Paginação
  --------------------------------------------------------------------
  final_com_paginacao AS (
    SELECT
      f.*,
      COUNT(*) OVER() AS total_registros
    FROM filtrado f

    ORDER BY
        CASE
            WHEN p_ordenar_como = 'DESC' AND p_ordenar_por = 'created_at' THEN f.criado_em
        END DESC,
        CASE
            WHEN p_ordenar_como = 'DESC' AND p_ordenar_por = 'nome_completo' THEN f.nome_completo
        END DESC,
        CASE
            WHEN p_ordenar_como <> 'DESC' AND p_ordenar_por = 'created_at' THEN f.criado_em
        END ASC,
        CASE
            WHEN p_ordenar_como <> 'DESC' AND p_ordenar_por = 'nome_completo' THEN f.nome_completo
        END ASC

    LIMIT p_limite OFFSET v_offset
  )

  --------------------------------------------------------------------
  -- JSON FINAL
  --------------------------------------------------------------------
  SELECT jsonb_build_object(
    'pagina_atual', p_pagina,
    'qtd_paginas',  CEIL(MAX(total_registros) / p_limite::numeric),
    'qtd_total',    COALESCE(MAX(total_registros),0),
    'itens', COALESCE(
      jsonb_agg(
        jsonb_build_object(
          'id_processo',       id_processo,
          'id_turma',          id_turma,
          'criado_em',         criado_em,
          'status_processo',   status_processo,

          'nome_curso',        nome_curso_oficial,
          'nome_turma',        nome_turma,
          'turno',             turno,

          'id_user_expandido', id_user_expandido,
          'nome_completo',     nome_completo,
          'nome_social',       nome_social,
          'nome_artistico',    nome_artistico,
          'email',             email,

          'genero',            genero,
          'raca',              raca,
          'renda',             renda,
          'idade',             idade,
          'imagem_user',       COALESCE(imagem_user, imagem_arquivo),
          'nota_total_processo', nota_total_processo,

          -- NOVOS
          'pcd',               pcd,
          'laudo_enviado',     (laudo_arquivo IS NOT NULL),

          'avaliacao',         avaliacao
        )
      ),
      '[]'::jsonb
    )
  )
  INTO v_result
  FROM final_com_paginacao;

  RETURN v_result;
END
$function$
;

CREATE OR REPLACE FUNCTION public.get_carometro_paginado(p_pagina integer DEFAULT 1, p_itens_por_pagina integer DEFAULT 10, p_nome text DEFAULT NULL::text, p_turma uuid DEFAULT NULL::uuid, p_turno text DEFAULT NULL::text, p_ano_semestre text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_offset int;
  v_total int;
  v_total_paginas int;
  v_result json;
begin
  v_offset := (p_pagina - 1) * p_itens_por_pagina;

  -- 🔹 1. COUNT com todos os filtros (usando matriculas)
  select count(distinct u.id)
  into v_total
  from public.user_expandido u
  left join public.matriculas m on m.id_aluno = u.id
  left join public.turmas t on t.id = m.id_turma
  where
    u.papel_id = '9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid
    and (
      p_nome is null or
      lower(u.nome) ilike lower('%' || p_nome || '%') or
      lower(u.sobrenome) ilike lower('%' || p_nome || '%')
    )
    and (p_turma is null or m.id_turma = p_turma)
    and (p_turno is null or t.turno ilike p_turno)
    and (p_ano_semestre is null or t.ano_semestre = p_ano_semestre);

  v_total_paginas := ceil(v_total::numeric / p_itens_por_pagina::numeric);

  -- 🔹 2. SELECT paginado com mesmos filtros
  select json_agg(row_to_json(sub))
  into v_result
  from (
    select
      u.id,
      trim(u.nome || ' ' || coalesce(u.sobrenome, '')) as nome_completo,
      u.imagem_user,
      (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe') as nome_social,
      (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '5747a06b-2385-4920-af8a-48f8ec870518') as nome_artistico,
      (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea') as identidade_genero,
      (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '8925bdc2-538a-408d-bd34-fb64b2638621') as data_nascimento,

      (
        select case
          when r.resposta ~ '^\d{4}-\d{2}-\d{2}$'
            then floor(date_part('year', age(current_date, r.resposta::date)))::int
          else null
        end
        from public.respostas r
        where r.user_expandido_id = u.id
          and r.id_pergunta = '8925bdc2-538a-408d-bd34-fb64b2638621'
      ) as idade,

      case
        when (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea') not in ('Homem Cis', 'Mulher Cis')
             and coalesce((select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'),'') <> ''
        then (select r.resposta from public.respostas r where r.user_expandido_id = u.id and r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe')
        else trim(u.nome || ' ' || coalesce(u.sobrenome, ''))
      end as nome_card,

      coalesce((
        select json_agg(distinct jsonb_build_object(
          'nome_curso',  t.nome_curso,
          'ano_semestre',t.ano_semestre,
          'turno',       t.turno,
          'cod_modulo',  t.cod_modulo,
          'cod_turma',   t.cod_turma,
          'status',      m.status
        ))
        from public.matriculas m
        join public.turmas t on t.id = m.id_turma
        where m.id_aluno = u.id
      ), '[]'::json) as turmas

    from public.user_expandido u
    left join public.matriculas m on m.id_aluno = u.id
    left join public.turmas t on t.id = m.id_turma
    where
      u.papel_id = '9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid
      and (
        p_nome is null or
        lower(u.nome) ilike lower('%' || p_nome || '%') or
        lower(u.sobrenome) ilike lower('%' || p_nome || '%')
      )
      and (p_turma is null or m.id_turma = p_turma)
      and (p_turno is null or t.turno ilike p_turno)
      and (p_ano_semestre is null or t.ano_semestre = p_ano_semestre)
    group by u.id
    order by 
      (u.imagem_user is null or trim(u.imagem_user) = '') asc, -- ✅ com foto primeiro
      lower(u.nome)
    limit p_itens_por_pagina offset v_offset
  ) sub;

  return json_build_object(
    'pagina_atual',     p_pagina,
    'qtd_itens_total',  v_total,
    'qtd_paginas',      v_total_paginas,
    'itens',            coalesce(v_result, '[]'::json)
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_complete_schema()
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
DECLARE
    result jsonb;
BEGIN
    -- Get all enums
    WITH enum_types AS (
        SELECT 
            t.typname as enum_name,
            array_agg(e.enumlabel ORDER BY e.enumsortorder) as enum_values
        FROM pg_type t
        JOIN pg_enum e ON t.oid = e.enumtypid
        JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
        WHERE n.nspname = 'public'
        GROUP BY t.typname
    )
    SELECT jsonb_build_object(
        'enums',
        COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'name', enum_name,
                    'values', to_jsonb(enum_values)
                )
            ),
            '[]'::jsonb
        )
    )
    FROM enum_types
    INTO result;

    -- Get all tables with their details
    WITH RECURSIVE 
    columns_info AS (
        SELECT 
            c.oid as table_oid,
            c.relname as table_name,
            a.attname as column_name,
            format_type(a.atttypid, a.atttypmod) as column_type,
            a.attnotnull as notnull,
            pg_get_expr(d.adbin, d.adrelid) as column_default,
            CASE 
                WHEN a.attidentity != '' THEN true
                WHEN pg_get_expr(d.adbin, d.adrelid) LIKE 'nextval%' THEN true
                ELSE false
            END as is_identity,
            EXISTS (
                SELECT 1 FROM pg_constraint con 
                WHERE con.conrelid = c.oid 
                AND con.contype = 'p' 
                AND a.attnum = ANY(con.conkey)
            ) as is_pk
        FROM pg_class c
        JOIN pg_namespace n ON n.oid = c.relnamespace
        LEFT JOIN pg_attribute a ON a.attrelid = c.oid
        LEFT JOIN pg_attrdef d ON d.adrelid = c.oid AND d.adnum = a.attnum
        WHERE n.nspname = 'public' 
        AND c.relkind = 'r'
        AND a.attnum > 0 
        AND NOT a.attisdropped
    ),
    fk_info AS (
        SELECT 
            c.oid as table_oid,
            jsonb_agg(
                jsonb_build_object(
                    'name', con.conname,
                    'column', col.attname,
                    'foreign_schema', fs.nspname,
                    'foreign_table', ft.relname,
                    'foreign_column', fcol.attname,
                    'on_delete', CASE con.confdeltype
                        WHEN 'a' THEN 'NO ACTION'
                        WHEN 'c' THEN 'CASCADE'
                        WHEN 'r' THEN 'RESTRICT'
                        WHEN 'n' THEN 'SET NULL'
                        WHEN 'd' THEN 'SET DEFAULT'
                        ELSE NULL
                    END
                )
            ) as foreign_keys
        FROM pg_class c
        JOIN pg_constraint con ON con.conrelid = c.oid
        JOIN pg_attribute col ON col.attrelid = con.conrelid AND col.attnum = ANY(con.conkey)
        JOIN pg_class ft ON ft.oid = con.confrelid
        JOIN pg_namespace fs ON fs.oid = ft.relnamespace
        JOIN pg_attribute fcol ON fcol.attrelid = con.confrelid AND fcol.attnum = ANY(con.confkey)
        WHERE con.contype = 'f'
        GROUP BY c.oid
    ),
    index_info AS (
        SELECT 
            c.oid as table_oid,
            jsonb_agg(
                jsonb_build_object(
                    'name', i.relname,
                    'using', am.amname,
                    'columns', (
                        SELECT jsonb_agg(a.attname ORDER BY array_position(ix.indkey, a.attnum))
                        FROM unnest(ix.indkey) WITH ORDINALITY as u(attnum, ord)
                        JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = u.attnum
                    )
                )
            ) as indexes
        FROM pg_class c
        JOIN pg_index ix ON ix.indrelid = c.oid
        JOIN pg_class i ON i.oid = ix.indexrelid
        JOIN pg_am am ON am.oid = i.relam
        WHERE NOT ix.indisprimary
        GROUP BY c.oid
    ),
    policy_info AS (
        SELECT 
            c.oid as table_oid,
            jsonb_agg(
                jsonb_build_object(
                    'name', pol.polname,
                    'command', CASE pol.polcmd
                        WHEN 'r' THEN 'SELECT'
                        WHEN 'a' THEN 'INSERT'
                        WHEN 'w' THEN 'UPDATE'
                        WHEN 'd' THEN 'DELETE'
                        WHEN '*' THEN 'ALL'
                    END,
                    'roles', (
                        SELECT string_agg(quote_ident(r.rolname), ', ')
                        FROM pg_roles r
                        WHERE r.oid = ANY(pol.polroles)
                    ),
                    'using', pg_get_expr(pol.polqual, pol.polrelid),
                    'check', pg_get_expr(pol.polwithcheck, pol.polrelid)
                )
            ) as policies
        FROM pg_class c
        JOIN pg_policy pol ON pol.polrelid = c.oid
        GROUP BY c.oid
    ),
    trigger_info AS (
        SELECT 
            c.oid as table_oid,
            jsonb_agg(
                jsonb_build_object(
                    'name', t.tgname,
                    'timing', CASE 
                        WHEN t.tgtype & 2 = 2 THEN 'BEFORE'
                        WHEN t.tgtype & 4 = 4 THEN 'AFTER'
                        WHEN t.tgtype & 64 = 64 THEN 'INSTEAD OF'
                    END,
                    'events', (
                        CASE WHEN t.tgtype & 1 = 1 THEN 'INSERT'
                             WHEN t.tgtype & 8 = 8 THEN 'DELETE'
                             WHEN t.tgtype & 16 = 16 THEN 'UPDATE'
                             WHEN t.tgtype & 32 = 32 THEN 'TRUNCATE'
                        END
                    ),
                    'statement', pg_get_triggerdef(t.oid)
                )
            ) as triggers
        FROM pg_class c
        JOIN pg_trigger t ON t.tgrelid = c.oid
        WHERE NOT t.tgisinternal
        GROUP BY c.oid
    ),
    table_info AS (
        SELECT DISTINCT 
            c.table_oid,
            c.table_name,
            jsonb_agg(
                jsonb_build_object(
                    'name', c.column_name,
                    'type', c.column_type,
                    'notnull', c.notnull,
                    'default', c.column_default,
                    'identity', c.is_identity,
                    'is_pk', c.is_pk
                ) ORDER BY c.column_name
            ) as columns,
            COALESCE(fk.foreign_keys, '[]'::jsonb) as foreign_keys,
            COALESCE(i.indexes, '[]'::jsonb) as indexes,
            COALESCE(p.policies, '[]'::jsonb) as policies,
            COALESCE(t.triggers, '[]'::jsonb) as triggers
        FROM columns_info c
        LEFT JOIN fk_info fk ON fk.table_oid = c.table_oid
        LEFT JOIN index_info i ON i.table_oid = c.table_oid
        LEFT JOIN policy_info p ON p.table_oid = c.table_oid
        LEFT JOIN trigger_info t ON t.table_oid = c.table_oid
        GROUP BY c.table_oid, c.table_name, fk.foreign_keys, i.indexes, p.policies, t.triggers
    )
    SELECT result || jsonb_build_object(
        'tables',
        COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'name', table_name,
                    'columns', columns,
                    'foreign_keys', foreign_keys,
                    'indexes', indexes,
                    'policies', policies,
                    'triggers', triggers
                )
            ),
            '[]'::jsonb
        )
    )
    FROM table_info
    INTO result;

    -- Get all functions
    WITH function_info AS (
        SELECT 
            p.proname AS name,
            pg_get_functiondef(p.oid) AS definition
        FROM pg_proc p
        JOIN pg_namespace n ON n.oid = p.pronamespace
        WHERE n.nspname = 'public'
        AND p.prokind = 'f'
    )
    SELECT result || jsonb_build_object(
        'functions',
        COALESCE(
            jsonb_agg(
                jsonb_build_object(
                    'name', name,
                    'definition', definition
                )
            ),
            '[]'::jsonb
        )
    )
    FROM function_info
    INTO result;

    RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_cursos_p_turmas(p_id_curso uuid DEFAULT NULL::uuid, p_area text DEFAULT NULL::text, p_nome text DEFAULT NULL::text, p_limite integer DEFAULT 20)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_result jsonb;
begin
  with dados as (
    select
      c.id,
      c.nome_curso,
      c.cod_curso,
      (c.area)::text as area_int,
      case lower((c.area)::text)
        when 'extensao' then 'Extensão'
        when 'cursos_livres' then 'Cursos Livres'
        when 'regulares' then 'Regulares'
        else initcap((c.area)::text)
      end as area,
      (c.modalidade)::text as modalidade
    from public.curso c
    where c.status is true
      -- 🧩 1️⃣ Se p_id_curso for enviado, ignora filtros e traz só ele
      and (
        (p_id_curso is not null and c.id = p_id_curso)
        or (p_id_curso is null and (
          (p_area is null or lower((c.area)::text) = lower(trim(p_area)))
          and (p_nome is null or c.nome_curso ilike '%' || p_nome || '%')
        ))
      )
    order by lower(c.nome_curso) asc
    limit case when p_id_curso is not null then 1 else p_limite end
  )
  select jsonb_agg(to_jsonb(dados))
  into v_result
  from dados;

  return coalesce(v_result, '[]'::jsonb);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dados_alunos_por_ids(p_id_turma uuid, p_ids_alunos uuid[])
 RETURNS TABLE(id_turma uuid, id_aluno uuid, nome_registro text, email text, nome_social text, nome_artistico text, identidade_genero text, foto_user text, ra text, ra_legado text, ano_ingresso character, semestre_ingresso smallint)
 LANGUAGE sql
 SET search_path TO 'extensions', 'public'
AS $function$
  with alunos(id_aluno) as (
    select unnest(p_ids_alunos)
  )
  select
    p_id_turma,
    a.id_aluno,
    nullif(btrim(concat_ws(' ', ue.nome, ue.sobrenome)), '') as nome_registro,
    ue.email,
    r_soc.resposta  as nome_social,        -- 32b1a387-a2a9-4f79-af30-d32026af64fe
    r_art.resposta  as nome_artistico,     -- 5747a06b-2385-4920-af8a-48f8ec870518
    r_gen.resposta  as identidade_genero,  -- 25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea
    r_foto.resposta as foto_user,          -- c95e476a-c4dc-4520-badd-d7392b0aeab7
    ra.ra,
    ra.ra_legado,
    ra.ano_ingresso,
    ra.semestre_ingresso
  from alunos a
  left join public.user_expandido ue
    on ue.id = a.id_aluno
  left join public.ra_alunos ra
    on ra.id_aluno = a.id_aluno
  left join public.respostas r_soc
    on r_soc.user_expandido_id = a.id_aluno
   and r_soc.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'::uuid
   and (r_soc.tipo_resposta is distinct from 'arquivo')
  left join public.respostas r_art
    on r_art.user_expandido_id = a.id_aluno
   and r_art.id_pergunta = '5747a06b-2385-4920-af8a-48f8ec870518'::uuid
   and (r_art.tipo_resposta is distinct from 'arquivo')
  left join public.respostas r_gen
    on r_gen.user_expandido_id = a.id_aluno
   and r_gen.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'::uuid
   and (r_gen.tipo_resposta is distinct from 'arquivo')
  left join public.respostas r_foto
    on r_foto.user_expandido_id = a.id_aluno
   and r_foto.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid;
$function$
;

CREATE OR REPLACE FUNCTION public.get_dados_curso(p_id uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$declare
  v_curso jsonb;
  v_encontros jsonb;
begin
  -- 1️⃣ Curso principal
  select jsonb_build_object(
    'criar_editar', 'editar',
    'padrao_encontros', c.padrao_encontros,
    'id', c.id,
    'nome_curso', c.nome_curso,
    'area', c.area,
    'modalidade', c.modalidade,
    'cod_curso', c.cod_curso,
    'descricao', c.descricao,
    'modulos', c.qtd_modulos,
    'encontros_modulo', c.qtd_aulas_modulo,
    'c_encontros_totais', (c.qtd_modulos * c.qtd_aulas_modulo),
    'periodos', c.qtd_periodos,

    -- conversão correta dos minutos para [horas, minutos, total]
    'carga_horaria_total',     fmt_minutos(c.qtd_minutos_total),
    'c_carga_horaria_modulo',  fmt_minutos(c.qtd_minutos_modulo),
    'c_carga_horaria_encontro',fmt_minutos(coalesce(c.qtd_minutos_aula, c.qtd_minutos_modulo)),
    'c_carga_horaria_periodo', fmt_minutos(c.qtd_minutos_periodo)
  )
  into v_curso
  from curso c
  where c.id = p_id;

  -- 2️⃣ Encontros (se houver)
select coalesce(
  jsonb_agg(
    jsonb_build_object(
      'id_curso', e.id_curso,
      'numero_encontro', e.numero_encontro,
      'duracao_horas', (e.duracao_minutos / 60)::text,
      'duracao_minutos', lpad((e.duracao_minutos % 60)::text, 2, '0'),
      'duracao_somente_minutos', e.duracao_minutos,
      'observacao', coalesce(e.observacao, 'livre')
    )
    order by e.numero_encontro
  ),
  '[]'::jsonb
)
into v_encontros
from curso_encontros e
where e.id_curso = p_id;

  -- 3️⃣ Retorno final
  return jsonb_build_object('curso', v_curso, 'encontros', v_encontros);
end;$function$
;

CREATE OR REPLACE FUNCTION public.get_dashboard_areas(p_ano_semestre text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result jsonb;
BEGIN

  --------------------------------------------------------------------
  -- 1. TURMAS DO ANO/SEMESTRE
  --------------------------------------------------------------------
  WITH turmas_filtradas AS (
    SELECT
      t.id AS id_turma,
      t.nome_curso,
      t.cod_turma,
      t.ano_semestre,
      c.area AS area_curso,   -- ENUM tipo_area
      c.id AS id_curso
    FROM turmas t
    JOIN curso c ON c.id = t.id_curso
    WHERE t.ano_semestre ILIKE p_ano_semestre
  ),

  --------------------------------------------------------------------
  -- 2. PROCESSOS AGRUPADOS POR TURMA
  --------------------------------------------------------------------
  processos_agg AS (
    SELECT
      tf.area_curso,
      tf.id_turma,
      COUNT(p.id) AS total_inscricoes
    FROM turmas_filtradas tf
    LEFT JOIN processos p ON p.turma_id = tf.id_turma
    GROUP BY tf.area_curso, tf.id_turma
  ),

  --------------------------------------------------------------------
  -- 3. TOTAL POR ÁREA
  --------------------------------------------------------------------
  areas_totais AS (
    SELECT
      area_curso,
      SUM(total_inscricoes) AS total_area
    FROM processos_agg
    GROUP BY area_curso
  ),

  --------------------------------------------------------------------
  -- 4. PERGUNTAS (area / turma)
  --------------------------------------------------------------------
  perguntas_area AS (
    SELECT
      p.id,
      p.pergunta AS label,
      p.tipo,
      p.opcoes,
      p.ordem,
      p.id_turma,
      p.area,        -- ENUM tipo_area
      p.escopo
    FROM perguntas_avaliacao_processos p
    WHERE COALESCE(p.ativo, true) IS TRUE
      AND p.escopo IN ('area','turma')
  ),

  --------------------------------------------------------------------
  -- 5. RESPOSTAS (sem filtro de turma ainda)
  --------------------------------------------------------------------
  respostas AS (
    SELECT
      r.id_pergunta_processo AS id_pergunta,
      r.id_user,
      r.resposta_texto AS valor
    FROM respostas_perguntas_avaliacao_processos r
  ),

  --------------------------------------------------------------------
  -- 6. AVALIAÇÃO POR TURMA (TOTALIZADORES)
  --------------------------------------------------------------------
  avaliacao_por_turma AS (
    SELECT
      tf.id_turma,

      -- perguntas válidas (numero + opção)
      COUNT(DISTINCT CASE 
        WHEN p.tipo IN ('numero','number','opcao','opção','radio','select')
        THEN p.id 
      END) AS total_perguntas,

      -- respostas somente dos alunos desta turma
      COUNT(
        CASE 
          WHEN pr.id IS NOT NULL AND r.valor IS NOT NULL 
          THEN 1 
        END
      ) AS total_respostas,

      CASE 
        WHEN COUNT(DISTINCT CASE 
               WHEN p.tipo IN ('numero','number','opcao','opção','radio','select') 
               THEN p.id END) = 0
          THEN 0
        ELSE ROUND(
          (
            COUNT(
              CASE WHEN pr.id IS NOT NULL AND r.valor IS NOT NULL THEN 1 END
            )::numeric * 100
          ) /
          COUNT(DISTINCT CASE 
            WHEN p.tipo IN ('numero','number','opcao','opção','radio','select') 
            THEN p.id END)
          , 1
        )
      END AS percentual_respostas

    FROM turmas_filtradas tf
    LEFT JOIN perguntas_area p
      ON (
           (p.escopo = 'area'  AND p.area     = tf.area_curso)  
        OR (p.escopo = 'turma' AND p.id_turma = tf.id_turma)
      )
    LEFT JOIN respostas r 
      ON r.id_pergunta = p.id
    LEFT JOIN processos pr
      ON pr.user_expandido_id = r.id_user
     AND pr.turma_id = tf.id_turma

    GROUP BY tf.id_turma
  ),

  --------------------------------------------------------------------
  -- 7. DETALHES DAS PERGUNTAS (apenas numero + opção)
  --------------------------------------------------------------------
  perguntas_detalhes AS (
    SELECT
      tf.id_turma,
      p.id AS id_pergunta,
      p.label,
      p.tipo,
      p.opcoes,
      p.ordem
    FROM turmas_filtradas tf
    JOIN perguntas_area p
      ON (
           (p.escopo = 'area'  AND p.area     = tf.area_curso)
        OR (p.escopo = 'turma' AND p.id_turma = tf.id_turma)
      )
    WHERE p.tipo IN ('numero','number','opcao','opção','radio','select')
  ),

  --------------------------------------------------------------------
  -- 8. ANALYTICS POR PERGUNTA (POR TURMA)
  --------------------------------------------------------------------
  perguntas_analytics AS (
    SELECT
      pd.id_turma,
      pd.id_pergunta,
      pd.label,
      pd.tipo,
      pd.ordem,

      CASE
        ----------------------------------------------------------------
        -- 📌 TIPO NUMÉRICO
        ----------------------------------------------------------------
        WHEN pd.tipo IN ('numero','number') THEN
          jsonb_build_object(
            'tipo', 'numero',
            'media',
              (
                SELECT AVG((r.resposta_texto)::numeric)
                FROM respostas_perguntas_avaliacao_processos r
                JOIN processos pr
                  ON pr.user_expandido_id = r.id_user
                 AND pr.turma_id = pd.id_turma
                WHERE r.id_pergunta_processo = pd.id_pergunta
              ),
            'total_respostas',
              (
                SELECT COUNT(*)
                FROM respostas_perguntas_avaliacao_processos r
                JOIN processos pr
                  ON pr.user_expandido_id = r.id_user
                 AND pr.turma_id = pd.id_turma
                WHERE r.id_pergunta_processo = pd.id_pergunta
              )
          )

        ----------------------------------------------------------------
        -- 📌 TIPO OPÇÃO
        ----------------------------------------------------------------
        ELSE
          jsonb_build_object(
            'tipo', 'opcao',
            'total_respostas',
              (
                SELECT COUNT(*)
                FROM respostas_perguntas_avaliacao_processos r
                JOIN processos pr
                  ON pr.user_expandido_id = r.id_user
                 AND pr.turma_id = pd.id_turma
                WHERE r.id_pergunta_processo = pd.id_pergunta
              ),
            'opcoes',
              (
                SELECT jsonb_agg(
                  jsonb_build_object(
                    'valor', opcao,
                    'qtd',
                      COALESCE((
                          SELECT COUNT(*) 
                          FROM respostas_perguntas_avaliacao_processos r
                          JOIN processos pr
                            ON pr.user_expandido_id = r.id_user
                           AND pr.turma_id = pd.id_turma
                          WHERE r.id_pergunta_processo = pd.id_pergunta
                            AND r.resposta_texto = opcao
                      ), 0)
                  )
                )
                FROM jsonb_array_elements_text(pd.opcoes) AS opcao
              )
          )
      END AS dados

    FROM perguntas_detalhes pd
  ),

  --------------------------------------------------------------------
  -- 9. AGRUPAMENTO FINAL POR TURMA
  --------------------------------------------------------------------
  turmas_final AS (
    SELECT
      tf.area_curso,
      jsonb_agg(
        jsonb_build_object(
          'id_turma', tf.id_turma,
          'nome_curso', tf.nome_curso,
          'cod_turma', tf.cod_turma,
          'total_inscricoes',
            (SELECT total_inscricoes FROM processos_agg pa WHERE pa.id_turma = tf.id_turma),

          'avaliacao',
            jsonb_build_object(
              'total_perguntas',
                (SELECT total_perguntas FROM avaliacao_por_turma av WHERE av.id_turma = tf.id_turma),
              'total_respostas',
                (SELECT total_respostas FROM avaliacao_por_turma av WHERE av.id_turma = tf.id_turma),
              'percentual_respostas',
                (SELECT percentual_respostas FROM avaliacao_por_turma av WHERE av.id_turma = tf.id_turma),
              'perguntas',
                (
                  SELECT jsonb_agg(
                    jsonb_build_object(
                      'id_pergunta', pd.id_pergunta,
                      'label', pd.label,
                      'tipo', pd.tipo,
                      'dados', pd.dados
                    )
                    ORDER BY pd.ordem
                  )
                  FROM perguntas_analytics pd
                  WHERE pd.id_turma = tf.id_turma
                )
            )
        )
        ORDER BY tf.nome_curso
      ) AS turmas
    FROM turmas_filtradas tf
    GROUP BY tf.area_curso
  )

  --------------------------------------------------------------------
  -- 10. RESULTADO FINAL (com área_normalized)
  --------------------------------------------------------------------
  SELECT jsonb_agg(
    jsonb_build_object(
      'area', a.area_curso,
      'area_normalized',
        CASE a.area_curso
          WHEN 'regulares'       THEN 'Regulares'
          WHEN 'extensao'        THEN 'Extensão'
          WHEN 'cursos_livres'   THEN 'Cursos Livres'
          WHEN 'eventos_editais' THEN 'Eventos / Editais'
          WHEN 'jornadas'        THEN 'Jornadas'
          ELSE INITCAP(REPLACE(a.area_curso::text, '_', ' '))
        END,
      'total_inscricoes', a.total_area,
      'turmas',
        (SELECT turmas FROM turmas_final t WHERE t.area_curso = a.area_curso)
    )
    ORDER BY a.area_curso
  )
  INTO v_result
  FROM areas_totais a;

  RETURN jsonb_build_object(
    'ano_semestre', p_ano_semestre,
    'areas', COALESCE(v_result, '[]'::jsonb)
  );

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_diario_pendentes()
 RETURNS TABLE(id_controle_sync uuid, id_diario uuid, id_item_sharepoint text, sync_sharepoint boolean, email_aluno text, cod_modulo text, data timestamp with time zone, p1 status_presenca, p2 status_presenca, p3 status_presenca, p4 status_presenca, justificativa text)
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'extensions', 'public'
AS $function$
  select
    dcs.id as id_controle_sync,
    d.id as id_diario,
    d.id_item_sharepoint,
    d.sync_sharepoint,
    ue.email as email_aluno,
    t.cod_modulo,
    d.data,
    d.p1,
    d.p2,
    d.p3,
    d.p4,
    d.justificativa
  from public.diario_controle_sync dcs
  join public.diario d on d.id = dcs.id_diario
  join public.user_expandido ue on ue.id = d.id_aluno
  join public.turmas t on t.id = d.id_turma
  where dcs.status = 'pendente'
  order by dcs.data asc;
$function$
;

CREATE OR REPLACE FUNCTION public.get_diario_turma_data(p_id_turma uuid, p_data timestamp with time zone)
 RETURNS TABLE(id_matricula uuid, id_aluno uuid, nome_aluno text, nome_social text, nome_artistico text, identidade_genero text, foto_user text, ra text, ra_legado text, ano_ingresso character, semestre_ingresso smallint, status_matricula status_matricula, diario_id uuid, diario_p1 status_presenca, diario_p2 status_presenca, diario_p3 status_presenca, diario_p4 status_presenca, diario_justificativa text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        m.id AS id_matricula,
        m.id_aluno,
        u.nome || ' ' || COALESCE(u.sobrenome, '') AS nome_aluno,
        -- Extra fields from get_dados_alunos_por_ids
        r_soc.resposta  as nome_social,
        r_art.resposta  as nome_artistico,
        r_gen.resposta  as identidade_genero,
        r_foto.resposta as foto_user,
        ra.ra,
        ra.ra_legado,
        ra.ano_ingresso,
        ra.semestre_ingresso,
        -- End extra fields
        m.status AS status_matricula,
        d.id AS diario_id,
        d.p1 AS diario_p1,
        d.p2 AS diario_p2,
        d.p3 AS diario_p3,
        d.p4 AS diario_p4,
        d.justificativa AS diario_justificativa
    FROM 
        public.matriculas m
    JOIN 
        public.user_expandido u ON m.id_aluno = u.id
    LEFT JOIN 
        public.diario d ON d.id_matricula = m.id 
        AND (d.data AT TIME ZONE 'America/Sao_Paulo')::date = (p_data AT TIME ZONE 'America/Sao_Paulo')::date
    -- Joins for extra data
    LEFT JOIN public.ra_alunos ra ON ra.id_aluno = m.id_aluno
    LEFT JOIN public.respostas r_soc
        ON r_soc.user_expandido_id = m.id_aluno
        AND r_soc.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'::uuid
        AND (r_soc.tipo_resposta IS DISTINCT FROM 'arquivo')
    LEFT JOIN public.respostas r_art
        ON r_art.user_expandido_id = m.id_aluno
        AND r_art.id_pergunta = '5747a06b-2385-4920-af8a-48f8ec870518'::uuid
        AND (r_art.tipo_resposta IS DISTINCT FROM 'arquivo')
    LEFT JOIN public.respostas r_gen
        ON r_gen.user_expandido_id = m.id_aluno
        AND r_gen.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'::uuid
        AND (r_gen.tipo_resposta IS DISTINCT FROM 'arquivo')
    LEFT JOIN public.respostas r_foto
        ON r_foto.user_expandido_id = m.id_aluno
        AND r_foto.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid
    WHERE 
        m.id_turma = p_id_turma
    ORDER BY 
        u.nome;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_documentos_pendentes(p_ano_semestre text, p_area tipo_area, p_page integer DEFAULT 1, p_limit integer DEFAULT 50)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result jsonb;
  v_offset integer := (p_page - 1) * p_limit;
BEGIN
  WITH turmas_area AS (
      SELECT t.id AS id_turma
      FROM turmas t
      JOIN curso c ON c.id = t.id_curso
      WHERE c.area = p_area
        AND t.ano_semestre ILIKE p_ano_semestre
  ),

  processos_filtrados AS (
      SELECT DISTINCT ON (p.user_expandido_id, p.turma_id)
          p.id AS id_processo,
          p.user_expandido_id,
          p.turma_id,
          p.documentos_pendentes,
          p.envio_email,
          p.envio_whatsapp,
          p.corrigido
      FROM processos p
      JOIN turmas_area ta ON ta.id_turma = p.turma_id
      WHERE p.tipo_candidatura = 'estudante'
      ORDER BY p.user_expandido_id, p.turma_id, p.created_at DESC
  ),

  alunos AS (
      SELECT DISTINCT
          u.id AS id_user_expandido,
          u.nome,
          u.sobrenome,
          u.email,
          u.imagem_user
      FROM user_expandido u
      JOIN processos_filtrados pf ON pf.user_expandido_id = u.id
  ),

  turmas_do_aluno AS (
      SELECT
          pf.user_expandido_id,
          jsonb_agg(
              DISTINCT jsonb_build_object(
                  'id_turma', t.id,
                  'nome_curso', t.nome_curso,
                  'area_curso', t.area_curso,
                  'ano_semestre', t.ano_semestre
              )
          ) AS turmas
      FROM processos_filtrados pf
      JOIN turmas t ON t.id = pf.turma_id
      GROUP BY pf.user_expandido_id
  ),

  docs_obrigatorios AS (
      SELECT DISTINCT
          pdo.id_pergunta,
          per.label
      FROM processo_documentos_obrigatorios pdo
      JOIN perguntas per ON per.id = pdo.id_pergunta
      WHERE pdo.tipo_processo = 'seletivo'
        AND (
             (pdo.escopo = 'area' AND pdo.id_area = p_area)
          OR (pdo.escopo = 'turma' AND pdo.id_turma IN (SELECT id_turma FROM turmas_area))
        )
        AND lower(per.tipo) IN ('arquivo', 'link')
        AND pdo.obrigatorio = true
  ),

  respostas_alunos AS (
      SELECT DISTINCT ON (r.user_expandido_id, r.id_pergunta)
          r.user_expandido_id,
          r.id_pergunta,
          r.resposta
      FROM respostas r
      WHERE r.user_expandido_id IN (SELECT id_user_expandido FROM alunos)
      ORDER BY r.user_expandido_id, r.id_pergunta, r.criado_em DESC
  ),

  telefone_aluno AS (
      SELECT DISTINCT ON (r.user_expandido_id)
          r.user_expandido_id,
          r.resposta AS telefone
      FROM respostas r
      WHERE r.id_pergunta = '93642773-5a9c-4ada-8356-21e7e7bb9eda'
      ORDER BY r.user_expandido_id, r.criado_em DESC
  ),

  documentos_do_aluno AS (
      SELECT 
          a.id_user_expandido,
          jsonb_agg(
              jsonb_build_object(
                  'id_pergunta', d.id_pergunta,
                  'documento', d.label,
                  'arquivo_enviado', r.resposta,
                  'falta', (r.resposta IS NULL)
              ) ORDER BY d.label
          ) AS documentos
      FROM alunos a
      CROSS JOIN docs_obrigatorios d
      LEFT JOIN respostas_alunos r 
             ON r.user_expandido_id = a.id_user_expandido
            AND r.id_pergunta = d.id_pergunta
      GROUP BY a.id_user_expandido
      HAVING bool_or(r.resposta IS NULL)
  ),

  -- 🔥 marca pendências ANTES do retorno
  atualiza AS (
      UPDATE processos p
      SET documentos_pendentes = true
      WHERE p.user_expandido_id IN (SELECT id_user_expandido FROM documentos_do_aluno)
        AND p.corrigido = false
      RETURNING p.user_expandido_id
  ),

  finalizado AS (
      SELECT
          a.id_user_expandido,
          a.nome,
          a.sobrenome,
          a.email,

          COALESCE(tel.telefone, '') AS telefone_bruto,

          CASE 
            WHEN COALESCE(tel.telefone, '') LIKE '+%' 
              THEN COALESCE(tel.telefone, '')
            ELSE '+55' || regexp_replace(COALESCE(tel.telefone, ''), '[^0-9]', '', 'g')
          END AS telefone_normalizado,

          'https://wa.me/' ||
          CASE 
            WHEN COALESCE(tel.telefone, '') LIKE '+%' 
              THEN replace(COALESCE(tel.telefone, ''), '+', '')
            ELSE '55' || regexp_replace(COALESCE(tel.telefone, ''), '[^0-9]', '', 'g')
          END AS whatsapp_link,

          a.imagem_user,
          t.turmas,
          d.documentos,

          -- ⭐ novas colunas de status
          (SELECT documentos_pendentes FROM processos_filtrados pf WHERE pf.user_expandido_id = a.id_user_expandido LIMIT 1) AS documentos_pendentes,
          (SELECT envio_email FROM processos_filtrados pf WHERE pf.user_expandido_id = a.id_user_expandido LIMIT 1) AS envio_email,
          (SELECT envio_whatsapp FROM processos_filtrados pf WHERE pf.user_expandido_id = a.id_user_expandido LIMIT 1) AS envio_whatsapp,
          (SELECT corrigido FROM processos_filtrados pf WHERE pf.user_expandido_id = a.id_user_expandido LIMIT 1) AS corrigido,

          -- ⭐ nova coluna fake
          false AS mostrar_documentos

      FROM documentos_do_aluno d
      JOIN alunos a ON a.id_user_expandido = d.id_user_expandido
      LEFT JOIN turmas_do_aluno t ON t.user_expandido_id = a.id_user_expandido
      LEFT JOIN telefone_aluno tel ON tel.user_expandido_id = a.id_user_expandido
  ),

  final_com_paginacao AS (
      SELECT 
         f.*,
         COUNT(*) OVER() AS total_registros
      FROM finalizado f
      ORDER BY f.nome
      LIMIT p_limit
      OFFSET v_offset
  )

  SELECT jsonb_build_object(
      'page', p_page,
      'limit', p_limit,
      'total', COALESCE(MAX(total_registros), 0),
      'total_pages', CEIL(COALESCE(MAX(total_registros), 0) / p_limit::numeric),
      'data', jsonb_agg(to_jsonb(final_com_paginacao.*))
  )
  INTO v_result
  FROM final_com_paginacao;

  RETURN v_result;
END
$function$
;

CREATE OR REPLACE FUNCTION public.get_eixos_usuario(p_id_user_expandido uuid)
 RETURNS text
 LANGUAGE sql
 SET search_path TO 'extensions', 'public'
AS $function$
  select regexp_replace(          -- remove espaços duplicados
           regexp_replace(        -- troca " e " por "-"
             regexp_replace(lower(trim(r.resposta)), '^eixo[[:space:]]*', ''), 
             '[[:space:]]*e[[:space:]]*', '-', 'gi'
           ),
           '\s+', '', 'g'
         ) as eixos
  from public.respostas r
  where r.user_expandido_id = p_id_user_expandido
    and r.id_pergunta = '0c05fac6-6cf1-41b0-985d-931fff2a59bb'::uuid
  limit 1;
$function$
;

CREATE OR REPLACE FUNCTION public.get_estoque_produto(p_id_produto uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    WITH estoque AS (
        SELECT 
            e.id AS id_produto_estoque, 
            e.status_disponibilidade, 
            e.status_item, 
            e.valor_atual, 
            e.valor_inicial
        FROM produto_estoque e
        WHERE e.id_produto = p_id_produto
          AND e.status_item != 'descartado' -- Filtro solicitado
    ),
    reservas_ativas AS (
        SELECT DISTINCT id_produto_estoque 
        FROM produto_reservas 
        WHERE status IN ('reservado','retirado','atrasado')
    ),
    avarias AS (
        SELECT DISTINCT ON (a.id_produto_estoque) 
            a.id_produto_estoque, 
            a.id, 
            a.status_reparo, 
            a.descricao, 
            a.tipo_avaria, 
            a.imagem_avaria 
        FROM produto_avarias a
        ORDER BY a.id_produto_estoque, a.data_entrada_avaria DESC
    ),
    final AS (
        SELECT 
            e.id_produto_estoque,
            CASE 
                WHEN r.id_produto_estoque IS NOT NULL THEN 'indisponivel' 
                ELSE 'disponivel' 
            END AS situacao,
            jsonb_build_object(
                'id', av.id, 
                'status_reparo', av.status_reparo, 
                'descricao', av.descricao, 
                'tipo_avaria', av.tipo_avaria, 
                'imagem_avaria', av.imagem_avaria
            ) AS avaria,
            false AS item_selecionado,
            e.status_item,
            e.status_disponibilidade,
            e.valor_inicial,
            e.valor_atual
        FROM estoque e
        LEFT JOIN reservas_ativas r ON r.id_produto_estoque = e.id_produto_estoque
        LEFT JOIN avarias av ON av.id_produto_estoque = e.id_produto_estoque
    )
    SELECT jsonb_agg(
        to_jsonb(final.*) ORDER BY final.id_produto_estoque
    )
    INTO v_result
    FROM final;

    RETURN COALESCE(v_result, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_estudantes_matriculados_turma(p_id_turma uuid, p_statuses text[] DEFAULT ARRAY['Ativa'::text])
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
declare
  v_ids uuid[];
begin
  select array_agg(m.id_aluno order by m.id_aluno)
    into v_ids
  from public.matriculas m
  where m.id_turma = p_id_turma
    and (p_statuses is null or m.status::text = any(p_statuses));

  return jsonb_build_object(
    'success', true,
    'turma_id', p_id_turma,
    'count', coalesce(array_length(v_ids, 1), 0),
    'ids', coalesce(to_jsonb(v_ids), '[]'::jsonb)
  );
exception
  when others then
    return jsonb_build_object(
      'success', false,
      'turma_id', p_id_turma,
      'error', sqlerrm
    );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_estudantes_matriculados_turma_filtros(p_ano_semestre text, p_turno text DEFAULT NULL::text, p_curso text DEFAULT NULL::text, p_busca text DEFAULT NULL::text, p_genero text DEFAULT NULL::text, p_raca text DEFAULT NULL::text, p_renda text DEFAULT NULL::text, p_id_turma uuid DEFAULT NULL::uuid, p_area text DEFAULT NULL::text, p_page integer DEFAULT 1, p_limit integer DEFAULT 20)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_result jsonb;
begin
  with dados as (
    select
      -- todas as colunas da matrícula
      m.*,

      -- turma
      t.nome_curso,
      t.area_curso,
      t.turno,
      t.ano_semestre,
      (t.nome_curso || ' - ' || t.turno) as nome_curso_turno,

      -- aluno
      u.id as aluno_id,
      u.nome,
      u.sobrenome,
      u.email,

      -- RA
      ra.ra,
      ra.ra_legado,

      -- respostas extras
      (select r.resposta from respostas r
         where r.user_expandido_id = u.id
           and r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'
         limit 1) as nome_social,
      (select r.resposta from respostas r
         where r.user_expandido_id = u.id
           and r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'
         limit 1) as genero,
      (select r.resposta from respostas r
         where r.user_expandido_id = u.id
           and r.id_pergunta = '9670c817-5db6-4055-8fc9-04cc15d6cd3e'
         limit 1) as raca,
      (select r.resposta from respostas r
         where r.user_expandido_id = u.id
           and r.id_pergunta = '98d09feb-ec9a-4a30-882d-7de8099c153f'
         limit 1) as renda,
      (select r.resposta from respostas r
         where r.user_expandido_id = u.id
           and r.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'
         limit 1) as foto_resposta

    from matriculas m
      join turmas t on t.id = m.id_turma
      join user_expandido u on u.id = m.id_aluno
      left join ra_alunos ra on ra.id_aluno = u.id

    where t.ano_semestre = p_ano_semestre
      and (p_turno is null or t.turno = p_turno)
      and (p_area is null or t.area_curso = p_area)
      and (p_curso is null or t.nome_curso ilike '%'||p_curso||'%')
      and (p_id_turma is null or t.id = p_id_turma)
      and (p_genero is null or exists (
        select 1 from respostas r
        where r.user_expandido_id = u.id
          and r.id_pergunta='25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'
          and r.resposta ilike '%'||p_genero||'%'
      ))
      and (p_raca is null or exists (
        select 1 from respostas r
        where r.user_expandido_id = u.id
          and r.id_pergunta='9670c817-5db6-4055-8fc9-04cc15d6cd3e'
          and r.resposta ilike '%'||p_raca||'%'
      ))
      and (p_renda is null or exists (
        select 1 from respostas r
        where r.user_expandido_id = u.id
          and r.id_pergunta='98d09feb-ec9a-4a30-882d-7de8099c153f'
          and r.resposta ilike '%'||p_renda||'%'
      ))
      and (p_busca is null or (
         u.nome ilike '%'||p_busca||'%' or
         u.sobrenome ilike '%'||p_busca||'%' or
         u.email ilike '%'||p_busca||'%' or
         exists (
           select 1 from respostas r
           where r.user_expandido_id=u.id
             and r.id_pergunta='32b1a387-a2a9-4f79-af30-d32026af64fe'
             and r.resposta ilike '%'||p_busca||'%'
         )
         or ra.ra ilike '%'||p_busca||'%'
         or ra.ra_legado ilike '%'||p_busca||'%'
      ))
  ),
  total as (
    select count(*) as total from dados
  ),
  paginado as (
    select * from dados
    order by nome, sobrenome
    limit p_limit offset (p_page-1)*p_limit
  )
  select jsonb_build_object(
    'total', (select total from total),
    'page', p_page,
    'limit', p_limit,
    'pages', ceil((select total from total)::numeric / p_limit),
    'alunos', coalesce(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
  )
  into v_result
  from paginado;

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_estudantes_matriculados_turma_filtros_v2(p_ano_semestre text, p_turno text DEFAULT NULL::text, p_curso text DEFAULT NULL::text, p_busca text DEFAULT NULL::text, p_genero text DEFAULT NULL::text, p_raca text DEFAULT NULL::text, p_renda text DEFAULT NULL::text, p_id_turma uuid DEFAULT NULL::uuid, p_area text DEFAULT NULL::text, p_status text DEFAULT NULL::text, p_page integer DEFAULT 1, p_limit integer DEFAULT 20)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_result jsonb;
BEGIN
  WITH dados AS (
    SELECT
      -- todas as colunas da matrícula
      m.*,
      m.rematricula,

      -- turma (dados agora vindos de CURSO)
      c.nome_curso AS nome_curso,
      c.area::text AS area_curso,
      t.turno,
      t.ano_semestre,
      (c.nome_curso || ' - ' || t.turno) AS nome_curso_turno,

      -- aluno
      u.id AS aluno_id,
      u.nome,
      u.sobrenome,
      u.email,

      -- RA
      ra.ra,
      ra.ra_legado,

      -- respostas extras
      (SELECT r.resposta FROM respostas r
         WHERE r.user_expandido_id = u.id
           AND r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'
         LIMIT 1) AS nome_social,
      (SELECT r.resposta FROM respostas r
         WHERE r.user_expandido_id = u.id
           AND r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'
         LIMIT 1) AS genero,
      (SELECT r.resposta FROM respostas r
         WHERE r.user_expandido_id = u.id
           AND r.id_pergunta = '9670c817-5db6-4055-8fc9-04cc15d6cd3e'
         LIMIT 1) AS raca,
      (SELECT r.resposta FROM respostas r
         WHERE r.user_expandido_id = u.id
           AND r.id_pergunta = '98d09feb-ec9a-4a30-882d-7de8099c153f'
         LIMIT 1) AS renda,
      (SELECT r.resposta FROM respostas r
         WHERE r.user_expandido_id = u.id
           AND r.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'
         LIMIT 1) AS foto_resposta

    FROM matriculas m
      JOIN turmas t ON t.id = m.id_turma
      JOIN curso c ON c.id = t.id_curso
      JOIN user_expandido u ON u.id = m.id_aluno
      LEFT JOIN ra_alunos ra ON ra.id_aluno = u.id

    WHERE t.ano_semestre = p_ano_semestre
      AND (p_turno IS NULL OR t.turno = p_turno)
      AND (p_area IS NULL OR public.normalizar_texto(c.area::text) = public.normalizar_texto(p_area))
      AND (p_status IS NULL 
           OR (p_status ILIKE 'ativa' AND m.status::text = 'Ativo') 
           OR m.status::text ILIKE p_status)
      AND (p_curso IS NULL OR public.normalizar_texto(c.nome_curso) ILIKE '%' || public.normalizar_texto(p_curso) || '%')
      AND (p_id_turma IS NULL OR t.id = p_id_turma)
      AND (p_genero IS NULL OR EXISTS (
        SELECT 1 FROM respostas r
        WHERE r.user_expandido_id = u.id
          AND r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'
          AND public.normalizar_texto(r.resposta) ILIKE '%' || public.normalizar_texto(p_genero) || '%'
      ))
      AND (p_raca IS NULL OR EXISTS (
        SELECT 1 FROM respostas r
        WHERE r.user_expandido_id = u.id
          AND r.id_pergunta = '9670c817-5db6-4055-8fc9-04cc15d6cd3e'
          AND public.normalizar_texto(r.resposta) ILIKE '%' || public.normalizar_texto(p_raca) || '%'
      ))
      AND (p_renda IS NULL OR EXISTS (
        SELECT 1 FROM respostas r
        WHERE r.user_expandido_id = u.id
          AND r.id_pergunta = '98d09feb-ec9a-4a30-882d-7de8099c153f'
          AND public.normalizar_texto(r.resposta) ILIKE '%' || public.normalizar_texto(p_renda) || '%'
      ))
      AND (p_busca IS NULL OR (
           public.normalizar_texto(u.nome) ILIKE '%' || public.normalizar_texto(p_busca) || '%'
        OR public.normalizar_texto(u.sobrenome) ILIKE '%' || public.normalizar_texto(p_busca) || '%'
        OR public.normalizar_texto(u.email) ILIKE '%' || public.normalizar_texto(p_busca) || '%'
        OR EXISTS (
             SELECT 1 FROM respostas r
             WHERE r.user_expandido_id = u.id
               AND r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'
               AND public.normalizar_texto(r.resposta) ILIKE '%' || public.normalizar_texto(p_busca) || '%'
           )
        OR ra.ra ILIKE '%' || p_busca || '%'
        OR ra.ra_legado ILIKE '%' || p_busca || '%'
      ))
  ),
  total AS (
    SELECT count(*) AS total FROM dados
  ),
  paginado AS (
    SELECT * FROM dados
    ORDER BY nome, sobrenome
    LIMIT p_limit OFFSET (p_page - 1) * p_limit
  )
  SELECT jsonb_build_object(
    'total', (SELECT total FROM total),
    'page', p_page,
    'limit', p_limit,
    'pages', ceil((SELECT total FROM total)::numeric / p_limit),
    'alunos', coalesce(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
  )
  INTO v_result
  FROM paginado;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_faltas_aluno_turma(p_id_aluno uuid, p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_result jsonb;
    v_inconsistencias text[] := '{}';
    v_minutos_faltados numeric := 0;
    v_minutos_modulo numeric := 0;
    v_padrao_encontros boolean;
    v_qtd_periodos int;
    v_qtd_minutos_periodo int;
    v_qtd_aulas_modulo int;
    v_id_curso uuid;

    v_row record;
    v_duracao_encontro int;
    v_minutos_por_periodo numeric;
    v_minutos_faltados_neste_dia numeric;

    v_registros jsonb := '[]'::jsonb;
BEGIN
    --------------------------------------------------------------------
    -- 1) Carrega dados do curso + turma
    --------------------------------------------------------------------
    SELECT 
        t.id_curso,
        c.padrao_encontros,
        c.qtd_periodos,
        c.qtd_minutos_periodo,
        c.qtd_minutos_modulo,
        c.qtd_aulas_modulo
    INTO 
        v_id_curso,
        v_padrao_encontros,
        v_qtd_periodos,
        v_qtd_minutos_periodo,
        v_minutos_modulo,
        v_qtd_aulas_modulo
    FROM turmas t
    JOIN curso c ON c.id = t.id_curso
    WHERE t.id = p_id_turma;

    IF v_id_curso IS NULL THEN
        RETURN jsonb_build_object('erro', 'Turma não encontrada');
    END IF;

    --------------------------------------------------------------------
    -- 2) Processar diário ordenado unicamente pela DATA
    --------------------------------------------------------------------
    FOR v_row IN
        SELECT 
            d.*,
            ROW_NUMBER() OVER (ORDER BY d.data ASC) AS encontro_real
        FROM diario d
        WHERE d.id_aluno = p_id_aluno
          AND d.id_turma = p_id_turma
        ORDER BY d.data ASC
    LOOP
        ----------------------------------------------------------------
        -- 3) Determinar a duração do encontro
        ----------------------------------------------------------------
        IF v_padrao_encontros THEN
            -- duração constante
            v_duracao_encontro := v_qtd_periodos * v_qtd_minutos_periodo;

        ELSE
            -- curso irregular → tentar achar a duração específica no curso_encontros
            SELECT ce.duracao_minutos
            INTO v_duracao_encontro
            FROM curso_encontros ce
            WHERE ce.id_curso = v_id_curso
              AND ce.numero_encontro = v_row.encontro_real;

            IF v_duracao_encontro IS NULL THEN
                -- Aula extra → usar fallback
                v_duracao_encontro := v_qtd_periodos * v_qtd_minutos_periodo;

                v_inconsistencias := array_append(
                    v_inconsistencias,
                    format('aula extra na data %s sem correspondência em curso_encontros', v_row.data::date)
                );
            END IF;

        END IF;

        ----------------------------------------------------------------
        -- 4) Calcular faltas do dia (dinâmico para p1–p4)
        ----------------------------------------------------------------
        v_minutos_faltados_neste_dia := 0;
        v_minutos_por_periodo := v_duracao_encontro::numeric / v_qtd_periodos;

        -- P1
        IF v_row.p1 = 'falta' THEN
            v_minutos_faltados_neste_dia := v_minutos_faltados_neste_dia + v_minutos_por_periodo;
        END IF;

        -- P2
        IF v_qtd_periodos >= 2 AND v_row.p2 = 'falta' THEN
            v_minutos_faltados_neste_dia := v_minutos_faltados_neste_dia + v_minutos_por_periodo;
        END IF;

        -- P3
        IF v_qtd_periodos >= 3 AND v_row.p3 = 'falta' THEN
            v_minutos_faltados_neste_dia := v_minutos_faltados_neste_dia + v_minutos_por_periodo;
        END IF;

        -- P4
        IF v_qtd_periodos >= 4 AND v_row.p4 = 'falta' THEN
            v_minutos_faltados_neste_dia := v_minutos_faltados_neste_dia + v_minutos_por_periodo;
        END IF;

        v_minutos_faltados := v_minutos_faltados + v_minutos_faltados_neste_dia;

        ----------------------------------------------------------------
        -- 5) inserir no array de registros
        ----------------------------------------------------------------
        v_registros := v_registros || jsonb_build_object(
            'data', v_row.data::date,
            'p1', v_row.p1,
            'p2', v_row.p2,
            'p3', v_row.p3,
            'p4', v_row.p4,
            'duracao_encontro', v_duracao_encontro,
            'minutos_faltados_neste_dia', v_minutos_faltados_neste_dia
        );
    END LOOP;

    --------------------------------------------------------------------
    -- 6) Cálculo final com cortes (máx 100%)
    --------------------------------------------------------------------
    IF v_minutos_modulo <= 0 THEN
        RETURN jsonb_build_object('erro', 'Módulo sem carga horária definida');
    END IF;

    -- percentual real
    -- ex: 0.24 → depois convertendo para % arredondado (24.00)
    DECLARE
        v_percentual_faltas numeric;
        v_percentual_presenca numeric;
    BEGIN
        v_percentual_faltas := v_minutos_faltados / v_minutos_modulo;
        v_percentual_presenca := 1 - v_percentual_faltas;

        -- cortes
        v_percentual_faltas := LEAST(v_percentual_faltas, 1);
        v_percentual_presenca := GREATEST(v_percentual_presenca, 0);

        -- conversão para porcentagem
        v_percentual_faltas := ROUND(v_percentual_faltas * 100, 2);
        v_percentual_presenca := ROUND(v_percentual_presenca * 100, 2);

        ----------------------------------------------------------------
        -- 7) Monta JSON final
        ----------------------------------------------------------------
        v_result := jsonb_build_object(
            'id_aluno', p_id_aluno,
            'id_turma', p_id_turma,
            'qtd_periodos', v_qtd_periodos,
            'padrao_encontros', v_padrao_encontros,
            'minutos_faltados', v_minutos_faltados,
            'horas_faltadas', ROUND(v_minutos_faltados / 60.0, 2),
            'horas_totais_modulo', (v_minutos_modulo / 60.0),
            'percentual_faltas', v_percentual_faltas,
            'percentual_presenca', v_percentual_presenca,
            'registros', v_registros,
            'inconsistencias', v_inconsistencias
        );
    END;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_listas_candidatos(p_area tipo_area, p_ano_semestre text, p_filtros jsonb DEFAULT '[]'::jsonb, p_tipo_processo tipo_processo DEFAULT NULL::tipo_processo, p_tipo_candidatura tipo_candidatura DEFAULT NULL::tipo_candidatura, p_status_processo text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    -- garante array
    IF p_filtros IS NULL OR jsonb_typeof(p_filtros) <> 'array' THEN
        p_filtros := '[]'::jsonb;
    END IF;

    WITH

    --------------------------------------------------------------------
    -- TURMAS
    --------------------------------------------------------------------
    turmas_filtradas AS (
        SELECT
            t.id AS turma_id,
            t.nome_curso AS nome_turma,
            t.turno,
            t.ano_semestre,
            c.id AS curso_id,
            c.nome_curso AS nome_curso_oficial,
            c.area,
            av.data_prova,
            av.hora_redacao,
            av.hora_pratica,
            av.cabecalho_texto,
            av.data_etapas
        FROM turmas t
        JOIN curso c ON c.id = t.id_curso
        JOIN textos_listas_selecao av ON av.id_turma = t.id
        WHERE c.area = p_area
          AND t.ano_semestre = p_ano_semestre
    ),

    --------------------------------------------------------------------
    -- RESPOSTAS BÁSICAS
    --------------------------------------------------------------------
    respostas_basicas AS (
        SELECT
            r.user_expandido_id,

            MAX(CASE WHEN r.id_pergunta = '29a21c21-b102-434e-a05b-08cc5e871de7'
                     THEN r.resposta END) AS rg,

            MAX(CASE WHEN r.id_pergunta = '20467206-19d9-4bb9-8a54-e6625f101282'
                     THEN r.resposta END) AS cpf,

            MAX(CASE WHEN r.id_pergunta = '9670c817-5db6-4055-8fc9-04cc15d6cd3e'
                     THEN r.resposta END) AS cor_raca,

            MAX(CASE WHEN r.id_pergunta = '25edf1cb-ed2f-4ae2-a85d-ef5c6f0af8ea'
                     THEN r.resposta END) AS identidade_genero,

            MAX(CASE WHEN r.id_pergunta = '32b1a387-a2a9-4f79-af30-d32026af64fe'
                     THEN r.resposta END) AS nome_social,

            MAX(CASE WHEN r.id_pergunta = 'd42f73a8-0a61-4f6a-acd1-767b06bd612e'
                     THEN r.resposta END) AS condicao_recever_bolsa,

            MAX(CASE WHEN r.id_pergunta = '98d09feb-ec9a-4a30-882d-7de8099c153f'
                     THEN r.resposta END) AS renda_per_capita

        FROM respostas r
        GROUP BY r.user_expandido_id
    ),

    --------------------------------------------------------------------
    -- CANDIDATOS BASE
    --------------------------------------------------------------------
    candidatos_base AS (
        SELECT
            tf.turma_id,
            pr.id AS processo_id,
            ux.id AS user_expandido_id,

            TRIM(COALESCE(ux.nome,'') || ' ' || COALESCE(ux.sobrenome,'')) AS nome_registro,
            ux.email,
            ux.imagem_user,

            rb.nome_social,
            rb.identidade_genero,
            rb.rg,
            rb.cpf,
            rb.cor_raca,
            rb.condicao_recever_bolsa,
            rb.renda_per_capita,

            pr.tipo_candidatura,

            ROW_NUMBER() OVER (
                PARTITION BY tf.turma_id
                ORDER BY pr.created_at ASC, pr.id ASC
            ) AS num_classificacao

        FROM turmas_filtradas tf
        JOIN processos pr
          ON pr.turma_id = tf.turma_id

        JOIN user_expandido ux
          ON ux.id = pr.user_expandido_id

        LEFT JOIN respostas_basicas rb
          ON rb.user_expandido_id = ux.id

        ----------------------------------------------------------------
        -- PATCH CRÍTICO — Garantir deferimento POR PROCESSO (e por turma)
        ----------------------------------------------------------------
        LEFT JOIN respostas_perguntas_avaliacao_processos resp_def
          ON resp_def.id_user = ux.id
         AND resp_def.id_processo = pr.id
         AND resp_def.id_pergunta_processo = '518e1943-1a84-4017-b283-67b3914e46e2'
         AND resp_def.resposta_texto = 'Inscrição Deferida'

        WHERE resp_def.id_user IS NOT NULL
          AND (p_tipo_candidatura IS NULL OR pr.tipo_candidatura = p_tipo_candidatura)
          AND (p_tipo_processo IS NULL OR pr.tipo_processo = p_tipo_processo)
          AND (p_status_processo IS NULL OR pr.status = p_status_processo)
    ),

    --------------------------------------------------------------------
    -- NOME FINAL
    --------------------------------------------------------------------
    candidatos_nome AS (
        SELECT
            cb.*,
            CASE 
                WHEN cb.identidade_genero IN 
                     ('Mulher Trans','Homem Trans','Travesti','Não Binário')
                     AND cb.nome_social IS NOT NULL AND cb.nome_social <> ''
                THEN cb.nome_social
                ELSE cb.nome_registro
            END AS nome_final
        FROM candidatos_base cb
    ),

    --------------------------------------------------------------------
    -- FILTROS DINÂMICOS
    --------------------------------------------------------------------
    filtros AS (
        SELECT
            (f->>'id_pergunta')::uuid AS id_pergunta,
            f->>'resposta' AS valor
        FROM jsonb_array_elements(p_filtros) f
    ),

    --------------------------------------------------------------------
    -- PERGUNTAS VÁLIDAS
    --------------------------------------------------------------------
    perguntas_validas AS (
        SELECT
            cn.turma_id,
            cn.user_expandido_id,
            pvp.id AS pergunta_id,
            pvp.pergunta,
            pvp.tipo,
            pvp.ordem,
            pvp.opcoes,
            pvp.opcao_default,
            pvp.escopo
        FROM candidatos_nome cn
        JOIN perguntas_avaliacao_processos pvp
           ON pvp.ativo = TRUE
          AND (
                (pvp.escopo = 'turma' AND pvp.id_turma = cn.turma_id)
             OR (pvp.escopo = 'area' AND pvp.area::text = (
                    SELECT tf.area::text
                    FROM turmas_filtradas tf
                    WHERE tf.turma_id = cn.turma_id
                    LIMIT 1
                 ))
          )
    ),

    --------------------------------------------------------------------
    -- RESPOSTAS NORMALIZADAS
    --------------------------------------------------------------------
    respostas_normalizadas AS (
        SELECT
            pv.turma_id AS turma_id_resp,
            pv.user_expandido_id,
            pv.pergunta_id,
            pv.pergunta,
            pv.tipo,
            pv.ordem,
            pv.opcoes,
            pv.opcao_default,
            rap.resposta_texto,
            CASE
                WHEN rap.resposta_texto IS NOT NULL THEN rap.resposta_texto
                WHEN pv.tipo = 'opcao' AND pv.opcao_default IS NOT NULL THEN pv.opcao_default
                WHEN pv.tipo = 'numero' THEN '0'
                ELSE NULL
            END AS resposta_normalizada
        FROM perguntas_validas pv
        LEFT JOIN respostas_perguntas_avaliacao_processos rap
               ON rap.id_pergunta_processo = pv.pergunta_id
              AND rap.id_user = pv.user_expandido_id
    ),

    --------------------------------------------------------------------
    -- CANDIDATOS FILTRADOS
    --------------------------------------------------------------------
    candidatos_filtrados AS (
        SELECT DISTINCT
            cn.turma_id,
            cn.processo_id,
            cn.user_expandido_id,
            cn.nome_final,
            cn.email,
            cn.imagem_user,

            cn.rg,
            cn.cpf,
            cn.cor_raca,
            cn.identidade_genero,
            cn.nome_social,
            cn.condicao_recever_bolsa,
            cn.renda_per_capita,

            cn.num_classificacao

        FROM candidatos_nome cn
        WHERE (
            jsonb_array_length(p_filtros) = 0
            OR NOT EXISTS (
                SELECT 1
                FROM filtros f
                LEFT JOIN respostas_normalizadas rn
                       ON rn.user_expandido_id = cn.user_expandido_id
                      AND rn.pergunta_id = f.id_pergunta
                WHERE f.id_pergunta IS NOT NULL
                  AND rn.resposta_normalizada IS DISTINCT FROM f.valor
            )
        )
    )

    --------------------------------------------------------------------
    -- JSON FINAL
    --------------------------------------------------------------------
    SELECT jsonb_agg(
        jsonb_build_object(
            'id_turma', tf.turma_id,
            'nome_turma', tf.nome_turma,
            'turno', tf.turno,
            'data_prova', tf.data_prova,
            'hora_redacao', tf.hora_redacao,
            'hora_pratica', tf.hora_pratica,
            'cabecalho', tf.cabecalho_texto,
            'data_etapas', tf.data_etapas,

            ----------------------------------------------------------------
            -- FICHA CONTINUA POR CURSO (MODELO ATUAL)
            ----------------------------------------------------------------
            'rodape_ficha', (
                SELECT cfa.rodape
                FROM curso_ficha_avaliacao cfa
                WHERE cfa.id_curso = tf.curso_id
                LIMIT 1
            ),

            'perguntas_ficha_avaliacao', (
                SELECT jsonb_agg(
                    jsonb_build_object('pergunta', pergunta)
                    ORDER BY ordem
                )
                FROM (
                    SELECT cfa.pergunta_1 AS pergunta, 1 AS ordem
                    FROM curso_ficha_avaliacao cfa
                    WHERE cfa.id_curso = tf.curso_id

                    UNION ALL

                    SELECT cfa.pergunta_2 AS pergunta, 2 AS ordem
                    FROM curso_ficha_avaliacao cfa
                    WHERE cfa.id_curso = tf.curso_id

                    UNION ALL

                    SELECT cfa.pergunta_3 AS pergunta, 3 AS ordem
                    FROM curso_ficha_avaliacao cfa
                    WHERE cfa.id_curso = tf.curso_id
                ) p
            ),

            ----------------------------------------------------------------
            -- ALUNOS POR TURMA
            ----------------------------------------------------------------
            'alunos', (
                SELECT COALESCE(
                    jsonb_agg(
                        jsonb_build_object(
                            'id_processo', cf.processo_id,
                            'id_user_expandido', cf.user_expandido_id,
                            'nome', cf.nome_final,
                            'email', cf.email,
                            'imagem_user', cf.imagem_user,

                            'rg', cf.rg,
                            'cpf', cf.cpf,
                            'cor_raca', cf.cor_raca,
                            'identidade_genero', cf.identidade_genero,
                            'nome_social', cf.nome_social,
                            'condicao_recever_bolsa', cf.condicao_recever_bolsa,
                            'renda_per_capita', cf.renda_per_capita,

                            'classificacao', LPAD(cf.num_classificacao::text, 3, '0'),

                            'avaliacao', (
                                SELECT jsonb_agg(
                                    jsonb_build_object(
                                        'id_pergunta', rn.pergunta_id,
                                        'pergunta', rn.pergunta,
                                        'tipo', rn.tipo,
                                        'ordem', rn.ordem,
                                        'opcoes', rn.opcoes,
                                        'resposta', rn.resposta_normalizada
                                    )
                                    ORDER BY rn.ordem
                                )
                                FROM respostas_normalizadas rn
                                WHERE rn.user_expandido_id = cf.user_expandido_id
                                  AND rn.turma_id_resp = cf.turma_id
                            )
                        )
                        ORDER BY cf.nome_final
                    ),
                    '[]'::jsonb
                )
                FROM candidatos_filtrados cf
                WHERE cf.turma_id = tf.turma_id
            )
        )
    )
    INTO v_result
    FROM turmas_filtradas tf;

    RETURN COALESCE(v_result, '[]'::jsonb);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_perguntas_avaliacao_com_respostas(p_area tipo_area, p_id_turma uuid DEFAULT NULL::uuid, p_id_user_expandido uuid DEFAULT NULL::uuid, p_id_processo uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result jsonb;
BEGIN
  
  IF p_id_user_expandido IS NOT NULL AND p_id_processo IS NULL THEN
    RAISE EXCEPTION 'p_id_processo não pode ser NULL quando p_id_user_expandido não é NULL';
  END IF;

  WITH perguntas_base AS (
    SELECT 
      p.id AS id_pergunta,
      p.pergunta,
      p.ordem,
      p.tipo,
      p.opcoes,
      p.opcao_default
    FROM public.perguntas_avaliacao_processos p
    WHERE p.area = p_area
      AND (
            p.id_turma IS NULL
            OR p.id_turma = p_id_turma
          )
  ),

  perguntas_ord AS (
    SELECT *
    FROM perguntas_base
    ORDER BY ordem NULLS LAST, pergunta
  ),

  respostas AS (
    SELECT 
      r.id_pergunta_processo,
      r.resposta_texto
    FROM public.respostas_perguntas_avaliacao_processos r
    WHERE p_id_user_expandido IS NOT NULL
      AND r.id_user = p_id_user_expandido
      AND r.id_processo = p_id_processo
  )

  SELECT jsonb_agg(
      jsonb_build_object(
        'id_pergunta',      q.id_pergunta,
        'pergunta',         q.pergunta,
        'tipo',             q.tipo,
        'opcoes',           q.opcoes,
        'opcao_default',    q.opcao_default,
        'ordem',            q.ordem,
        'id_user_expandido', p_id_user_expandido,
        'id_processo',      p_id_processo,

        ----------------------------------------------------------------
        -- 🟦 Resposta retornada (com defaults por tipo)
        ----------------------------------------------------------------
        'resposta',
          CASE
            WHEN p_id_user_expandido IS NULL THEN
                CASE
                  WHEN q.tipo = 'opcao'  THEN q.opcao_default
                  WHEN q.tipo = 'numero' THEN '0'
                  ELSE ''
                END
            ELSE
                CASE
                  WHEN q.tipo = 'opcao'  THEN COALESCE(r.resposta_texto, q.opcao_default)
                  WHEN q.tipo = 'numero' THEN COALESCE(r.resposta_texto, '0')
                  ELSE COALESCE(r.resposta_texto, '')
                END
          END
      )
  )
  INTO v_result
  FROM perguntas_ord q
  LEFT JOIN respostas r
        ON r.id_pergunta_processo = q.id_pergunta;

  RETURN COALESCE(v_result, '[]'::jsonb);

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_by_id(p_id uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    -- Caso p_id seja NULL, retorna o objeto "schema" vazio para popular formulário
    IF p_id IS NULL THEN
        SELECT jsonb_build_object(
            'id', NULL,
            'nome', NULL,
            'treshold', NULL,
            'codigo_barras', NULL,
            'observacoes', NULL,
            'criado_em', NULL,
            'atualizado_em', NULL,
            'valor_inicial', NULL,
            'imagem_produto', NULL,
            'mostrar_mais', NULL,
            'disponiveis_legacy', NULL,
            'categoria', NULL,
            'tipo', NULL,
            'unidade', NULL,
            'total_estoque', 0 -- Estoque inicial é 0 para novos itens
        ) INTO v_result;

    ELSE
        -- Busca o produto com os mesmos joins do get_produtos
        SELECT jsonb_build_object(
            'id', p.id,
            'nome', p.nome,
            'treshold', p.treshold,
            'codigo_barras', p.codigo_barras,
            'observacoes', p.observacoes,
            'criado_em', p.criado_em,
            'atualizado_em', p.atualizado_em,
            'valor_inicial', p.valor_inicial,
            'imagem_produto', p.imagem_produto,
            'mostrar_mais', p.mostrar_mais,
            'disponiveis_legacy', p.disponiveis,
            
            -- Categoria
            'categoria', CASE 
                WHEN c.id IS NULL THEN NULL
                ELSE jsonb_build_object(
                    'id', c.id,
                    'nome', c.nome
                ) 
            END,
            
            -- Tipo Produto
            'tipo', CASE 
                WHEN t.id IS NULL THEN NULL
                ELSE jsonb_build_object(
                    'id', t.id,
                    'nome', t.nome,
                    'descricao', t.descricao
                ) 
            END,
            
            -- Unidade
            'unidade', CASE 
                WHEN u.id IS NULL THEN NULL
                ELSE jsonb_build_object(
                    'id', u.id,
                    'nome', u.nome,
                    'numero', u.numero,
                    'sufixo', u.sufixo
                ) 
            END,
            
            -- Contagem dinâmica de estoque
            'total_estoque', (
                SELECT count(*) 
                FROM public.produto_estoque pe 
                WHERE pe.id_produto = p.id
            )
        )
        INTO v_result
        FROM public.produtos p
        LEFT JOIN public.produto_categoria c ON p.id_categoria_produto = c.id
        LEFT JOIN public.produto_unidade u ON p.id_unidade = u.id
        LEFT JOIN public.tipo_produto t ON p.id_tipo_produto = t.id
        WHERE p.id = p_id;
        
        -- Caso o ID passado não exista, retorna null (ou poderia retornar o schema vazio, mas null é mais semântico para "não encontrado")
        IF v_result IS NULL THEN
            v_result := NULL;
        END IF;

    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_dim_all()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    SELECT jsonb_build_object(
        'categorias', (
            SELECT COALESCE(jsonb_agg(sub), '[]'::jsonb)
            FROM (
                SELECT id, nome
                FROM public.produto_categoria
                ORDER BY nome ASC
            ) sub
        ),
        'tipos', (
            SELECT COALESCE(jsonb_agg(sub), '[]'::jsonb)
            FROM (
                SELECT id, nome, descricao
                FROM public.tipo_produto
                ORDER BY nome ASC
            ) sub
        ),
        'unidades', (
            SELECT COALESCE(jsonb_agg(sub), '[]'::jsonb)
            FROM (
                SELECT id, nome, numero, sufixo
                FROM public.produto_unidade
                ORDER BY nome ASC
            ) sub
        )
    )
    INTO v_result;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_dim_categoria(p_busca text DEFAULT NULL::text, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    WITH dados AS (
        SELECT
            c.id,
            c.nome
        FROM public.produto_categoria c
        WHERE
            (p_busca IS NULL OR c.nome ILIKE '%' || p_busca || '%')
        ORDER BY c.nome ASC
    ),
    contagem AS (
        SELECT count(*) AS total FROM dados
    ),
    paginado AS (
        SELECT *
        FROM dados
        LIMIT p_limite
        OFFSET (p_pagina - 1) * p_limite
    )
    SELECT jsonb_build_object(
        'qtd_itens', (SELECT total FROM contagem),
        'qtd_paginas', CEIL((SELECT total FROM contagem)::numeric / p_limite),
        'pagina_atual', p_pagina,
        'itens', COALESCE(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
    )
    INTO v_result
    FROM paginado;

    IF v_result IS NULL THEN
        SELECT jsonb_build_object(
            'qtd_itens', 0,
            'qtd_paginas', 0,
            'pagina_atual', p_pagina,
            'itens', '[]'::jsonb
        ) INTO v_result;
    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_dim_tipo(p_busca text DEFAULT NULL::text, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    WITH dados AS (
        SELECT
            t.id,
            t.nome,
            t.descricao
        FROM public.tipo_produto t
        WHERE
            (p_busca IS NULL OR t.nome ILIKE '%' || p_busca || '%')
        ORDER BY t.nome ASC
    ),
    contagem AS (
        SELECT count(*) AS total FROM dados
    ),
    paginado AS (
        SELECT *
        FROM dados
        LIMIT p_limite
        OFFSET (p_pagina - 1) * p_limite
    )
    SELECT jsonb_build_object(
        'qtd_itens', (SELECT total FROM contagem),
        'qtd_paginas', CEIL((SELECT total FROM contagem)::numeric / p_limite),
        'pagina_atual', p_pagina,
        'itens', COALESCE(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
    )
    INTO v_result
    FROM paginado;

    IF v_result IS NULL THEN
        SELECT jsonb_build_object(
            'qtd_itens', 0,
            'qtd_paginas', 0,
            'pagina_atual', p_pagina,
            'itens', '[]'::jsonb
        ) INTO v_result;
    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_dim_unidade(p_busca text DEFAULT NULL::text, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    WITH dados AS (
        SELECT
            u.id,
            u.nome,
            u.numero,
            u.sufixo
        FROM public.produto_unidade u
        WHERE
            (p_busca IS NULL OR u.nome ILIKE '%' || p_busca || '%')
        ORDER BY u.nome ASC
    ),
    contagem AS (
        SELECT count(*) AS total FROM dados
    ),
    paginado AS (
        SELECT *
        FROM dados
        LIMIT p_limite
        OFFSET (p_pagina - 1) * p_limite
    )
    SELECT jsonb_build_object(
        'qtd_itens', (SELECT total FROM contagem),
        'qtd_paginas', CEIL((SELECT total FROM contagem)::numeric / p_limite),
        'pagina_atual', p_pagina,
        'itens', COALESCE(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
    )
    INTO v_result
    FROM paginado;

    IF v_result IS NULL THEN
        SELECT jsonb_build_object(
            'qtd_itens', 0,
            'qtd_paginas', 0,
            'pagina_atual', p_pagina,
            'itens', '[]'::jsonb
        ) INTO v_result;
    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produto_reservas_paginada(p_nome_produto text DEFAULT NULL::text, p_nome_usuario text DEFAULT NULL::text, p_categoria text DEFAULT NULL::text, p_status text DEFAULT NULL::text, p_pagina integer DEFAULT 1, p_itens_por_pagina integer DEFAULT 20)
 RETURNS json
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
DECLARE
  v_total_grupos  integer;
  v_total_paginas integer;
  v_itens         json;
BEGIN

  WITH grupos AS (
    SELECT
      --------------------------------------------------------------------
      -- ⭐ Novo: UUID único por bloco
      --------------------------------------------------------------------
      gen_random_uuid() AS id_bloco,

      r.id_produto,
      r.id_usuario,
      r.data_reserva,
      r.status,

      COUNT(*) AS total_reservado,

      MAX(r.data_reserva) AS data_mais_recente,
      MAX(r.data_retirada)  AS data_retirada,
      MAX(r.data_devolucao) AS data_devolucao,
      MAX(r.data_devolvido) AS data_devolvido,

      json_agg(
        jsonb_build_object(
          'id_reserva',          r.id,
          'id_produto',          r.id_produto,
          'id_produto_estoque',  r.id_produto_estoque,
          'id_usuario',          r.id_usuario,
          'data_reserva',        r.data_reserva,
          'data_retirada',       r.data_retirada,
          'data_devolucao',      r.data_devolucao,
          'data_devolvido',      r.data_devolvido,
          'status',              r.status,
          'id_avaria',           r.id_avaria,
          'usuario_devolveu',    r.usuario_devolveu,
          'created_at',          r.created_at,
          'updated_at',          r.updated_at
        )
        ORDER BY r.data_reserva DESC
      ) AS reservas,

      p.nome AS nome_produto,
      p.imagem_produto,
      trim(u.nome || ' ' || coalesce(u.sobrenome, '')) AS nome_usuario,
      c.nome AS categoria,

      --------------------------------------------------------------------
      -- ⭐ Auxiliar do front
      --------------------------------------------------------------------
      false AS mostrar_itens

    FROM produto_reservas r
    LEFT JOIN produtos p ON p.id = r.id_produto
    LEFT JOIN user_expandido u ON u.id = r.id_usuario
    LEFT JOIN produto_categoria c ON c.id = p.id_categoria_produto

    WHERE
      (p_nome_produto  IS NULL OR p.nome ILIKE '%' || p_nome_produto  || '%')
      AND (p_nome_usuario IS NULL OR (u.nome || ' ' || coalesce(u.sobrenome,'')) ILIKE '%' || p_nome_usuario || '%')
      AND (p_categoria   IS NULL OR c.nome ILIKE '%' || p_categoria   || '%')

      --------------------------------------------------------------------
      -- ⭐ Novo filtro de status (aceita: reservado, retirado, devolvido, atrasado)
      --    OU: Todos, vazio, NULL → sem filtro
      --------------------------------------------------------------------
      AND (
            p_status IS NULL
            OR trim(lower(p_status)) IN ('', 'todos')
            OR r.status::text = trim(lower(p_status))
          )

    GROUP BY 
      r.id_produto,
      r.id_usuario,
      r.data_reserva,
      r.status,
      p.nome,
      p.imagem_produto,
      u.nome, u.sobrenome,
      c.nome
  ),

  contagem AS (
    SELECT COUNT(*) AS total FROM grupos
  ),

  paginado AS (
    SELECT *
    FROM grupos
    ORDER BY data_mais_recente DESC
    OFFSET (p_pagina - 1) * p_itens_por_pagina
    LIMIT  p_itens_por_pagina
  )

  SELECT
    (SELECT total FROM contagem),
    CEIL((SELECT total FROM contagem)::numeric / p_itens_por_pagina),
    json_agg(to_jsonb(paginado.*))
  INTO
    v_total_grupos,
    v_total_paginas,
    v_itens
  FROM paginado;

  RETURN json_build_object(
    'qtd_itens_total', COALESCE(v_total_grupos, 0),
    'paginas',         COALESCE(v_total_paginas, 1),
    'pagina_atual',    p_pagina,
    'itens',           COALESCE(v_itens, '[]'::json)
  );

END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produtos(p_busca text DEFAULT NULL::text, p_categoria uuid DEFAULT NULL::uuid, p_tipo uuid DEFAULT NULL::uuid, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 10)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
    WITH dados AS (
        SELECT
            p.id,
            p.nome,
            p.treshold,
            p.codigo_barras,
            p.observacoes,
            p.criado_em,
            p.atualizado_em,
            p.valor_inicial,
            p.imagem_produto,
            p.mostrar_mais,
            p.disponiveis AS disponiveis_legacy, -- Mantendo caso seja útil para debugging
            
            -- Categoria
            jsonb_build_object(
                'id', c.id,
                'nome', c.nome
            ) AS categoria,
            
            -- Tipo Produto
            jsonb_build_object(
                'id', t.id,
                'nome', t.nome,
                'descricao', t.descricao
            ) AS tipo,
            
            -- Unidade
            jsonb_build_object(
                'id', u.id,
                'nome', u.nome,
                'numero', u.numero,
                'sufixo', u.sufixo
            ) AS unidade,
            
            -- Contagem dinâmica de estoque
            (
                SELECT count(*) 
                FROM public.produto_estoque pe 
                WHERE pe.id_produto = p.id
                  AND pe.status_item != 'descartado'
            ) AS total_estoque,

            -- Campo auxiliar para frontend
            0 AS quantidade_a_adicionar
            
        FROM public.produtos p
        LEFT JOIN public.produto_categoria c ON p.id_categoria_produto = c.id
        LEFT JOIN public.produto_unidade u ON p.id_unidade = u.id
        LEFT JOIN public.tipo_produto t ON p.id_tipo_produto = t.id
        WHERE
            -- Filtro de Busca (Nome)
            (p_busca IS NULL OR p.nome ILIKE '%' || p_busca || '%')
            
            -- Filtro de Categoria
            AND (p_categoria IS NULL OR p.id_categoria_produto = p_categoria)
            
            -- Filtro de Tipo
            AND (p_tipo IS NULL OR p.id_tipo_produto = p_tipo)
            
        ORDER BY p.nome ASC
    ),
    contagem AS (
        SELECT count(*) AS total FROM dados
    ),
    paginado AS (
        SELECT *
        FROM dados
        LIMIT p_limite
        OFFSET (p_pagina - 1) * p_limite
    )
    SELECT jsonb_build_object(
        'qtd_itens', (SELECT total FROM contagem),
        'qtd_paginas', CEIL((SELECT total FROM contagem)::numeric / p_limite),
        'pagina_atual', p_pagina,
        'itens', COALESCE(jsonb_agg(to_jsonb(paginado)), '[]'::jsonb)
    )
    INTO v_result
    FROM paginado;

    -- Se não houver itens, retorna estrutura vazia com contadores zerados
    IF v_result IS NULL THEN
        SELECT jsonb_build_object(
            'qtd_itens', 0,
            'qtd_paginas', 0,
            'pagina_atual', p_pagina,
            'itens', '[]'::jsonb
        ) INTO v_result;
    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_produtos_detalhes(p_id_produto uuid)
 RETURNS TABLE(id uuid, nome text, treshold integer, codigo_barras text, observacoes text, criado_em timestamp with time zone, atualizado_em timestamp with time zone, id_tipo_produto uuid, nome_tipo_produto text, quantidade bigint, id_unidade uuid, nome_unidade text, valor_inicial integer, imagem_produto text, mostrar_mais boolean, id_categoria_produto uuid, nome_categoria text)
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  return query
  select
    p.id,
    p.nome,
    p.treshold,
    p.codigo_barras,
    p.observacoes,
    p.criado_em,
    p.atualizado_em,
    p.id_tipo_produto,
    tp.nome as nome_tipo_produto,
    p.quantidade,
    p.id_unidade,
    u.nome as nome_unidade,
    p.valor_inicial,
    p.imagem_produto,
    p.mostrar_mais,
    p.id_categoria_produto,
    c.nome as nome_categoria
  from produtos p
  left join produto_categoria c on c.id = p.id_categoria_produto
  left join tipo_produto tp on tp.id = p.id_tipo_produto
  left join produto_unidade u on u.id = p.id_unidade
  where p.id = p_id_produto;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_reservas_semana_full_calsala(p_ref date)
 RETURNS TABLE(id uuid, sala_horario_id uuid, data date, status text, observacoes text, created_at timestamp with time zone, updated_at timestamp with time zone, evento text, turma_id uuid, turma_nome text, turma_turno text, turma_modulo text, turma_area text, sala_nome text, cor text, horario_total text, hora_ini integer, minuto_ini integer, hora_fim integer, minuto_fim integer, turno_cod text, turno_nome text)
 LANGUAGE sql
 SET search_path TO 'public'
AS $function$
  with semana as (
    select (p_ref - ((extract(dow from p_ref)::int + 6) % 7))::date as segunda
  )
  select
    r.id,
    r.sala_horario_id,
    r.data,
    r.status,
    r.observacoes,
    r.created_at,
    r.updated_at,
    r.evento,
    r.turma_id,

    t.nome_curso     as turma_nome,
    t.turno          as turma_turno,
    t.cod_modulo     as turma_modulo,
    t.area_curso     as turma_area,

    sh.nome          as sala_nome,
    sh.cor,
    sh.horario_total,
    sh.hora_ini,
    sh.minuto_ini,
    sh.hora_fim,
    sh.minuto_fim,
    sh.turno_cod,
    sh.turno_nome

  from public.sala_reservas r
  join semana s on r.data between s.segunda and s.segunda + 6
  join public.salas_horarios sh on sh.id = r.sala_horario_id
  left join public.turmas t on t.id = r.turma_id
  where r.status <> 'cancelado'
  order by r.data, sh.nome, sh.hora_ini, sh.minuto_ini
$function$
;

CREATE OR REPLACE FUNCTION public.get_respostas_arquivos_area(p_tipo_processo tipo_processo, p_area tipo_area, p_tipo_candidatura tipo_candidatura, p_id_user_expandido uuid, p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_result jsonb;
BEGIN

  ------------------------------------------------------------------
  -- 1. CTE: respostas do usuário
  ------------------------------------------------------------------
  WITH respostas_usuario AS (
      SELECT 
         r.id AS id_resposta,
         r.id_pergunta,
         r.resposta,
         r.arquivo_original,
         r.aprovado_doc,
         r.id_turma,
         r.criado_em
      FROM respostas r
      WHERE r.user_expandido_id = p_id_user_expandido
      -- AND (r.id_turma = p_id_turma OR r.id_turma IS NULL) -- Removido para permitir Area scope ver outras turmas
  ),
  data_nasc AS (
      SELECT resposta::date AS dt_nasc FROM respostas_usuario WHERE id_pergunta = '8925bdc2-538a-408d-bd34-fb64b2638621' AND id_turma IS NULL
  ),
  idade_calc AS (
      SELECT CASE WHEN dt_nasc IS NULL THEN NULL ELSE EXTRACT(YEAR FROM age(current_date, dt_nasc))::int END AS idade FROM data_nasc
  ),
  doc_resp AS ( SELECT resposta FROM respostas_usuario WHERE id_pergunta = '172bf4c5-7609-40d0-a805-d5291fdec84a' AND id_turma IS NULL ),
  pcd AS ( SELECT resposta FROM respostas_usuario WHERE id_pergunta = 'eae93308-1e4d-4c67-9c53-c9abf6a31eaf' AND id_turma IS NULL ),
  laudo_pcd AS ( SELECT resposta FROM respostas_usuario WHERE id_pergunta = 'de76ebe6-38d2-44e1-a112-ee64ad604c4f' AND id_turma IS NULL ),

  ------------------------------------------------------------------
  -- OBRIGATORIAS (Híbrido corrigido)
  ------------------------------------------------------------------
  obrigatorias AS (
      SELECT
        pdo.id_pergunta, p.pergunta, p.label, p.tipo, pdo.bloco, pdo.obrigatorio, pdo.ordem, pdo.leitura, pdo.tipo_candidatura, pdo.largura_coluna, pdo.altura_coluna,
        false::boolean AS artificial, p.tipo AS tipo_resposta, pdo.escopo
      FROM processo_documentos_obrigatorios pdo
      JOIN perguntas p ON p.id = pdo.id_pergunta
      LEFT JOIN idade_calc ic ON TRUE
      LEFT JOIN doc_resp dr ON TRUE
      LEFT JOIN pcd pcdx ON TRUE
      LEFT JOIN laudo_pcd lp ON TRUE
      WHERE 
          pdo.tipo_processo = p_tipo_processo
          AND (
               (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
            OR (
                pdo.escopo = 'turma' 
                AND (
                       pdo.id_turma = p_id_turma 
                    OR (pdo.id_turma IS NULL AND pdo.id_area = p_area) -- Fix: somente fallback se id_turma for NULL
                )
            )
          )
          AND lower(p.tipo) IN ('arquivo', 'link')
          AND (p.id <> '172bf4c5-7609-40d0-a805-d5291fdec84a' OR (COALESCE(ic.idade, 0) < 18 OR dr.resposta IS NOT NULL))
          AND (p.id <> 'de76ebe6-38d2-44e1-a112-ee64ad604c4f' OR (pcdx.resposta ILIKE 'Sim' OR lp.resposta IS NOT NULL))
          AND (p_tipo_candidatura IS NULL OR pdo.tipo_candidatura IS NULL OR pdo.tipo_candidatura = p_tipo_candidatura)
  ),

  unificado AS (
      SELECT 
        o.*,
        ru.id_pergunta AS resp_pergunta, ru.id_resposta, ru.resposta, ru.arquivo_original, ru.aprovado_doc,
        ru.id_turma AS id_turma_resposta
      FROM obrigatorias o
      LEFT JOIN LATERAL (
        SELECT ru.*
        FROM respostas_usuario ru
        WHERE ru.id_pergunta = o.id_pergunta
        AND (
            -- REGRA DE OURO:
            -- 1. Se for escopo AREA: Aceita qualquer resposta (preferência pela mais antiga).
            (o.escopo = 'area')
            OR
            -- 2. Se for escopo TURMA: Exige que a resposta seja desta turma.
            (o.escopo = 'turma' AND ru.id_turma = p_id_turma)
        )
        ORDER BY ru.criado_em ASC
        LIMIT 1
      ) ru ON true
      -- Ordena pelo ID da pergunta apenas, pois a unicidade foi garantida pelo LATERAL
      ORDER BY o.id_pergunta
  ),
  
  finalizado AS (
      SELECT jsonb_set(jsonb_set(to_jsonb(u.*), '{uploading}', 'false'::jsonb), '{deleting}', 'false'::jsonb) AS item
      FROM unificado u
  )
  SELECT COALESCE(jsonb_agg(item ORDER BY (item->>'ordem')::int NULLS LAST), '[]'::jsonb) INTO v_result FROM finalizado;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_respostas_nao_arquivos_area(p_tipo_processo tipo_processo, p_area tipo_area, p_tipo_candidatura tipo_candidatura, p_id_user_expandido uuid, p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_result          jsonb;
  v_user_id         uuid;
  v_user_nome       text;
  v_user_sobrenome  text;
  v_user_email      text;
BEGIN
  SELECT ue.user_id, ue.nome, ue.sobrenome, ue.email
  INTO v_user_id, v_user_nome, v_user_sobrenome, v_user_email
  FROM public.user_expandido ue
  WHERE ue.id = p_id_user_expandido;

  WITH obrigatorias AS (
    SELECT
      pdo.id_pergunta, p.pergunta, p.label, p.tipo, pdo.bloco, pdo.obrigatorio, pdo.ordem, pdo.leitura, pdo.tipo_candidatura, pdo.largura_coluna, pdo.altura_coluna,
      false::boolean AS artificial, p.tipo AS tipo_resposta, pdo.escopo
    FROM public.processo_documentos_obrigatorios pdo
    JOIN public.perguntas p ON p.id = pdo.id_pergunta
    WHERE pdo.tipo_processo = p_tipo_processo
      AND lower(p.tipo) <> 'arquivo'
      AND lower(p.tipo) <> 'link'
      AND (
            (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
         OR (
                pdo.escopo = 'turma' 
                AND (
                       pdo.id_turma = p_id_turma 
                    OR (pdo.id_turma IS NULL AND pdo.id_area = p_area) -- Fix
                )
            )
          )
      AND (p_tipo_candidatura IS NULL OR pdo.tipo_candidatura IS NULL OR pdo.tipo_candidatura = p_tipo_candidatura)
  ),
  respostas_user AS (
    SELECT r.id AS id_resposta, r.id_pergunta, r.resposta, r.arquivo_original, r.aprovado_doc, r.id_turma, r.criado_em
    FROM public.respostas r
    WHERE r.user_expandido_id = p_id_user_expandido
    -- AND (r.id_turma = p_id_turma OR r.id_turma IS NULL) -- Removido para permitir Area scope ver outras turmas
  ),
  artificiais AS (
    SELECT * FROM (
      VALUES
        (NULL::uuid, 'nome', 'Nome', 'texto', 'dados_pessoais'::public.bloco_pergunta, true, 1::smallint, false, NULL::tipo_candidatura, NULL::largura_coluna_tipo, NULL::altura_coluna_tipo, true, 'texto', v_user_nome),
        (NULL::uuid, 'sobrenome', 'Sobrenome', 'texto', 'dados_pessoais'::public.bloco_pergunta, true, 2::smallint, false, NULL::tipo_candidatura, NULL::largura_coluna_tipo, NULL::altura_coluna_tipo, true, 'texto', v_user_sobrenome),
        (NULL::uuid, 'email', 'E-mail', 'texto', 'dados_pessoais'::public.bloco_pergunta, true, 3::smallint, false, NULL::tipo_candidatura, NULL::largura_coluna_tipo, NULL::altura_coluna_tipo, true, 'texto', v_user_email)
    ) AS t(id_pergunta, pergunta, label, tipo, bloco, obrigatorio, ordem, leitura, tipo_candidatura, largura_coluna, altura_coluna, artificial, tipo_resposta, resposta_artificial)
  ),
  base AS (
    SELECT id_pergunta, pergunta, label, tipo, bloco, obrigatorio, ordem, leitura, tipo_candidatura, largura_coluna, altura_coluna, artificial, tipo_resposta,
      NULL::uuid AS id_resposta, NULL::text AS resposta, NULL::text AS arquivo_original, NULL::boolean AS aprovado_doc, escopo
    FROM obrigatorias
    UNION ALL
    SELECT id_pergunta, pergunta, label, tipo, bloco, obrigatorio, ordem, leitura, tipo_candidatura, largura_coluna, altura_coluna, artificial, tipo_resposta,
      NULL::uuid, resposta_artificial, NULL, NULL, NULL::escopo_processo
    FROM artificiais
  ),
  unificado AS (
    SELECT 
      b.id_pergunta, b.pergunta, b.label, b.tipo, b.bloco, b.obrigatorio, b.ordem, b.leitura, b.tipo_candidatura, b.largura_coluna, b.altura_coluna, b.artificial, b.tipo_resposta,
      b.escopo,
      COALESCE(ru.id_resposta, b.id_resposta) AS id_resposta,
      COALESCE(ru.resposta, b.resposta)       AS resposta,
      COALESCE(ru.arquivo_original, b.arquivo_original) AS arquivo_original,
      COALESCE(ru.aprovado_doc, b.aprovado_doc) AS aprovado_doc,
      ru.id_turma AS id_turma_resposta
    FROM base b
    LEFT JOIN LATERAL (
      SELECT ru.*
      FROM respostas_user ru
      WHERE ru.id_pergunta = b.id_pergunta
      AND (
         -- REGRA DE OURO:
         -- 0. Se for artificial
         b.artificial = true
         -- 1. Se for escopo AREA: Aceita qualquer resposta (preferência pela mais antiga).
         OR (b.escopo = 'area') 
         -- 2. Se for escopo TURMA: Exige que a resposta seja desta turma.
         OR (b.escopo = 'turma' AND ru.id_turma = p_id_turma)
      )
      ORDER BY ru.criado_em ASC
      LIMIT 1
    ) ru ON true
    -- Ordena pelo ID da pergunta apenas, pois a unicidade foi garantida pelo LATERAL
    ORDER BY b.id_pergunta
  ),
  finalizado AS (
    SELECT jsonb_set(jsonb_set(jsonb_set(jsonb_set(to_jsonb(u.*), '{uploading}', 'false'::jsonb), '{deleting}', 'false'::jsonb), '{id_user_expandido}', to_jsonb(p_id_user_expandido)), '{user_id}', to_jsonb(v_user_id)) AS item
    FROM unificado u
  )
  SELECT COALESCE(jsonb_agg(item ORDER BY (item->>'ordem')::int NULLS LAST), '[]'::jsonb) INTO v_result FROM finalizado;
  RETURN v_result;
END
$function$
;

CREATE OR REPLACE FUNCTION public.get_respostas_usuario_turma(p_user_id uuid, p_turma_id uuid, p_tipo_processo tipo_processo DEFAULT NULL::tipo_processo, p_tipo_candidatura tipo_candidatura DEFAULT NULL::tipo_candidatura)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_turma RECORD;
    v_curso RECORD;
    v_area text;
    v_semestre_humanizado text;
    v_user_nascimento text;
    v_user_idade int;

    v_user_nome text;
    v_user_sobrenome text;
    v_user_email text;

    v_perguntas jsonb;
BEGIN
    -- 1) BUSCA TURMA
    SELECT * INTO v_turma FROM turmas WHERE id = p_turma_id;

    -- 2) BUSCA CURSO
    SELECT * INTO v_curso FROM curso WHERE id = v_turma.id_curso;

    -- 3) AREA
    v_area := (v_curso.area)::text;

    -- 4) SEMESTRE
    v_semestre_humanizado :=
        CASE
            WHEN v_turma.ano_semestre ~ '^[0-9]{2}Is$' THEN 'Primeiro semestre de 20' || substring(v_turma.ano_semestre, 1, 2)
            WHEN v_turma.ano_semestre ~ '^[0-9]{2}IIs$' THEN 'Segundo semestre de 20' || substring(v_turma.ano_semestre, 1, 2)
            ELSE v_turma.ano_semestre
        END;

    -- 5) USER EXPANDIDO
    SELECT ue.nome, ue.sobrenome, ue.email INTO v_user_nome, v_user_sobrenome, v_user_email FROM user_expandido ue WHERE ue.id = p_user_id;

    -- 6) IDADE
    SELECT r.resposta INTO v_user_nascimento FROM respostas r WHERE r.user_expandido_id = p_user_id AND r.id_pergunta = '8925bdc2-538a-408d-bd34-fb64b2638621' AND r.id_turma IS NULL LIMIT 1;
    IF v_user_nascimento IS NOT NULL THEN v_user_idade := date_part('year', age((v_user_nascimento)::timestamptz)); END IF;

    -- 7) PERGUNTAS OBRIGATÓRIAS (HÍBRIDO)
    WITH obrig AS (
        SELECT DISTINCT
            pdo.id, pdo.id_pergunta, pdo.bloco, pdo.ordem, pdo.obrigatorio, pdo.largura, pdo.altura,
            pdo.depende, pdo.depende_de, pdo.valor_depende, pdo.pergunta_gatilho, pdo.valor_gatilho,
            pdo.tipo_processo, pdo.tipo_candidatura,
            p.pergunta, p.label, p.tipo,
            pdo.escopo
        FROM processo_documentos_obrigatorios pdo
        JOIN perguntas p ON p.id = pdo.id_pergunta
        WHERE 
            (
                (pdo.escopo = 'area' AND pdo.id_area = v_area::public.tipo_area)
                OR
                (
                    pdo.escopo = 'turma' 
                    AND (
                           pdo.id_turma = p_turma_id 
                        OR (pdo.id_turma IS NULL AND pdo.id_area = v_area::public.tipo_area) -- Fix: só fallback se for template (turma is null)
                    )
                )
            )
            AND (pdo.tipo_processo = p_tipo_processo OR p_tipo_processo IS NULL)
            AND (pdo.tipo_candidatura = p_tipo_candidatura OR p_tipo_candidatura IS NULL)
    ),

    resp AS (
        SELECT id_pergunta, resposta, aprovado_doc, motivo_reprovacao_doc, arquivo_original, id_turma, criado_em
        FROM respostas
        WHERE user_expandido_id = p_user_id
        -- AND (id_turma = p_turma_id OR id_turma IS NULL) -- Removido para permitir Area scope ver outras turmas
    ),
    
    fake AS (
        SELECT * FROM (
            VALUES
            (gen_random_uuid(), 'nome', 'Nome', 'texto', 'dados_pessoais'::bloco_pergunta, 1, false, 1, 36, false, NULL, v_user_nome, true),
            (gen_random_uuid(), 'sobrenome', 'Sobrenome', 'texto', 'dados_pessoais'::bloco_pergunta, 2, false, 1, 36, false, NULL, v_user_sobrenome, true),
            (gen_random_uuid(), 'email', 'E-mail', 'texto', 'dados_pessoais'::bloco_pergunta, 3, false, 2, 36, false, NULL, v_user_email, true)
        ) AS t(id_pergunta, pergunta, label, tipo, bloco, ordem, obrigatorio, largura, altura, depende, depende_de, resposta, artificial)
    )

    SELECT jsonb_agg(
        jsonb_build_object(
            'id_pergunta', x.id_pergunta,
            'pergunta', x.pergunta,
            'label', x.label,
            'tipo', x.tipo,
            'bloco', x.bloco,
            'ordem', x.ordem,
            'obrigatorio', x.obrigatorio,
            'largura', x.largura,
            'altura', x.altura,
            'depende', x.depende,
            'depende_de', x.depende_de,
            'valor_depende', x.valor_depende,
            'pergunta_gatilho', x.pergunta_gatilho,
            'valor_gatilho', x.valor_gatilho,
            'tipo_processo', x.tipo_processo,
            'tipo_candidatura', x.tipo_candidatura,
            'resposta', x.resposta,
            'arquivo_original', x.arquivo_original,
            'aprovado_doc', x.aprovado_doc,
            'artificial', x.artificial,
            'escopo_original', x.escopo,
            'uploading', false,
            'deleting', false,
            'load', false
        )
        ORDER BY x.bloco, x.ordem
    )
    INTO v_perguntas
    FROM (
        SELECT 
            o.*, false AS artificial,
            r.resposta, r.arquivo_original, r.aprovado_doc
        FROM obrig o
        LEFT JOIN LATERAL (
            SELECT r.*
            FROM resp r
            WHERE r.id_pergunta = o.id_pergunta
            AND (
                -- AREA: Aceita qualquer resposta (preferência pela mais antiga como pedido)
                (o.escopo = 'area')
                OR
                -- TURMA: Exige match exato de turma
                (o.escopo = 'turma' AND r.id_turma = p_turma_id)
            )
            -- Ordenação para garantir consistência (mais antiga primeiro)
            ORDER BY r.criado_em ASC
            LIMIT 1
        ) r ON true

        UNION ALL
        
        SELECT
            NULL, f.id_pergunta, f.bloco, f.ordem, false, f.largura, f.altura, false, NULL, NULL, false, NULL, p_tipo_processo, p_tipo_candidatura,
            f.pergunta, f.label, f.tipo, NULL::escopo_processo, true, f.resposta, NULL, NULL
        FROM fake f
    ) x;

    IF v_user_idade IS NOT NULL AND v_user_idade >= 18 THEN
        v_perguntas := (SELECT jsonb_agg(elem) FROM jsonb_array_elements(v_perguntas) elem WHERE elem->>'bloco' <> 'responsavel_legal');
    END IF;

    RETURN jsonb_build_object(
        'curso', v_curso.nome_curso,
        'area', v_area,
        'semestre', v_semestre_humanizado,
        'data_inicio', v_turma.dt_ini_curso,
        'data_fim', v_turma.dt_fim_curso,
        'idade_usuario', v_user_idade,
        'perguntas', v_perguntas
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_status_foto_usuario(p_user_expandido_id uuid)
 RETURNS TABLE(tem_foto_user_expandido boolean, tem_resposta_foto_perfil boolean, arquivo_foto_user_expandido text, arquivo_foto_resposta text, id_resposta_foto uuid)
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  return query
  select
    -- Se há imagem_user no user_expandido
    (ue.imagem_user is not null and trim(ue.imagem_user) <> '') as tem_foto_user_expandido,

    -- Se existe resposta de foto (com conteúdo)
    exists (
      select 1
      from public.respostas r
      where r.user_expandido_id = p_user_expandido_id
        and r.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid
        and coalesce(nullif(trim(r.resposta), ''), r.arquivo_original) is not null
    ) as tem_resposta_foto_perfil,

    -- Caminho direto no user_expandido
    ue.imagem_user as arquivo_foto_user_expandido,

    -- Caminho do arquivo da resposta, se existir
    (
      select coalesce(nullif(trim(r.resposta), ''), r.arquivo_original)
      from public.respostas r
      where r.user_expandido_id = p_user_expandido_id
        and r.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid
      limit 1
    ) as arquivo_foto_resposta,

    -- ID da resposta correspondente, se existir
    (
      select r.id
      from public.respostas r
      where r.user_expandido_id = p_user_expandido_id
        and r.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid
      limit 1
    ) as id_resposta_foto
  from public.user_expandido ue
  where ue.id = p_user_expandido_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_turmas_admin(p_area text DEFAULT NULL::text, p_ano_semestre text DEFAULT NULL::text, p_nome_curso text DEFAULT NULL::text, p_pagina integer DEFAULT 1, p_limite integer DEFAULT 20)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result jsonb;
  v_offset int := (p_pagina - 1) * p_limite;
  v_total int;
  v_qtd_paginas int;
  v_itens jsonb;
BEGIN
  -- 🔹 Total de registros
  SELECT count(*)
  INTO v_total
  FROM public.turmas t
  JOIN public.curso c ON c.id = t.id_curso
  WHERE (p_area IS NULL OR lower(c.area::text) = lower(trim(p_area)))
    AND (p_ano_semestre IS NULL OR t.ano_semestre = p_ano_semestre)
    AND (p_nome_curso IS NULL OR c.nome_curso ILIKE '%' || p_nome_curso || '%');

  -- 🔹 Calcula total de páginas
  v_qtd_paginas := ceil(v_total::numeric / p_limite);

  -- 🔹 Dados da página atual
  WITH dados AS (
    SELECT
      -- 🔸 Campos principais (inalterados)
      t.id,
      c.id AS id_curso,
      c.nome_curso,
      (c.area)::text AS area_curso_int,
      CASE lower((c.area)::text)
        WHEN 'extensao' THEN 'Extensão'
        WHEN 'cursos_livres' THEN 'Cursos Livres'
        WHEN 'regulares' THEN 'Regulares'
        ELSE initcap((c.area)::text)
      END AS area_curso,
      t.turno,
      t.ano_semestre,
      c.cod_curso,
      t.cod_turma,
      t.cod_modulo,
      t.qtd_horastotais,

      -- 🕒 Horários
      t.hora_ini,
      t.hora_fim,

      -- 🗓️ Datas
      t.dt_ini_inscri,
      t.dt_fim_inscri,
      t.dt_ini_mat,
      t.dt_fim_mat,
      t.dt_ini_curso,
      t.dt_fim_curso,
      t.dt_ini_inscri_docente,
      t.dt_fim_inscri_docente,

      -- 📅 Dias
      (
        SELECT string_agg(d.dia_da_semana_text, ' | ' ORDER BY d.dia_da_semana_num)
        FROM public.turmas_dias d
        WHERE d.id_turma = t.id
      ) AS dias_semana,
      (
        SELECT coalesce(
          jsonb_agg(d.dia_da_semana_text ORDER BY d.dia_da_semana_num),
          '[]'::jsonb
        )
        FROM public.turmas_dias d
        WHERE d.id_turma = t.id
      ) AS dias_semana_array,

      -- 📎 Outras colunas de turma
      t.id_sharepoint,
      t.link_video,

      -- 📘 Dados adicionais do curso (tudo o que ainda não estava sendo trazido)
      jsonb_build_object(
        'modalidade', (c.modalidade)::text,
        'descricao', c.descricao,
        'status', c.status,
        'qtd_modulos', c.qtd_modulos,
        'qtd_aulas_modulo', c.qtd_aulas_modulo,
        'qtd_periodos', c.qtd_periodos,
        'qtd_minutos_periodo', c.qtd_minutos_periodo,
        'qtd_minutos_aula', c.qtd_minutos_aula,
        'qtd_minutos_modulo', c.qtd_minutos_modulo,
        'qtd_minutos_total', c.qtd_minutos_total,
        'padrao_encontros', c.padrao_encontros,
        'criado_em', c.criado_em,
        'modificado_em', c.modificado_em
      ) AS curso_dados_adicionais,

      -- 📛 Nome formatado
      (c.nome_curso || ' - ' || coalesce(t.turno, '')) AS nome_curso_turno

    FROM public.turmas t
    JOIN public.curso c ON c.id = t.id_curso
    WHERE (p_area IS NULL OR lower(c.area::text) = lower(trim(p_area)))
      AND (p_ano_semestre IS NULL OR t.ano_semestre = p_ano_semestre)
      AND (p_nome_curso IS NULL OR c.nome_curso ILIKE '%' || p_nome_curso || '%')
    ORDER BY t.dt_ini_curso DESC
    LIMIT p_limite OFFSET v_offset
  )
  SELECT jsonb_agg(to_jsonb(dados))
  INTO v_itens
  FROM dados;

  -- 🔹 Retorno final
  v_result := jsonb_build_object(
    'total', coalesce(v_total, 0),
    'pagina', p_pagina,
    'limite', p_limite,
    'qtd_paginas', coalesce(v_qtd_paginas, 1),
    'itens', coalesce(v_itens, '[]'::jsonb)
  );

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_turmas_filtradas(p_ano_semestre text, p_turno text DEFAULT NULL::text, p_area text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
BEGIN
  WITH dados AS (
      SELECT
        t.id,
        c.nome_curso,
        (c.area)::text AS area_curso,
        t.turno,
        t.ano_semestre,
        c.cod_curso,
        t.cod_turma,
        t.cod_modulo,
        t.dt_ini_curso,
        t.dt_fim_curso,
        (c.nome_curso || ' - ' || coalesce(t.turno, '')) AS nome_curso_turno
      FROM public.turmas t
      JOIN public.curso c ON c.id = t.id_curso
      WHERE 
        t.ano_semestre = p_ano_semestre

        -- 🔥 turno flexível (opcional)
        AND (
              p_turno IS NULL
              OR normalizar_texto(t.turno) = normalizar_texto(p_turno)
        )

        -- 🔥 área flexível (opcional)
        AND (
              p_area IS NULL
              OR normalizar_texto(c.area::text) = normalizar_texto(p_area)
        )

        AND c.status = TRUE
      ORDER BY c.nome_curso, t.cod_turma
  )
  SELECT jsonb_build_object(
      'total', COUNT(*),
      'turmas', COALESCE(jsonb_agg(to_jsonb(dados)), '[]'::jsonb)
  )
  INTO v_result
  FROM dados;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_turmas_por_aluno_processos(p_id_user_expandido uuid)
 RETURNS TABLE(id_processo uuid, id_turma uuid, nome_curso text, area_curso text, area_normalizada text, dt_ini_curso timestamp with time zone, dt_fim_curso timestamp with time zone, status_processo text, nome_aluno text, email_aluno text, id_user_expandido uuid, criado_em timestamp with time zone, documentos_pendentes boolean, dt_ini_inscri timestamp with time zone, dt_fim_inscri timestamp with time zone, dt_ini_mat timestamp with time zone, dt_fim_mat timestamp with time zone, dt_ini_inscri_docente timestamp with time zone, dt_fim_inscri_docente timestamp with time zone, hora_ini text, hora_fim text)
 LANGUAGE sql
AS $function$

WITH base AS (
    SELECT
        p.id              AS id_processo,
        t.id              AS id_turma,
        c.nome_curso,
        c.area::text      AS area_curso,
        CASE 
          WHEN c.area::text = 'regulares'     THEN 'Regulares'
          WHEN c.area::text = 'cursos_livres' THEN 'Cursos Livres'
          WHEN c.area::text = 'extensao'      THEN 'Extensão'
          ELSE initcap(c.area::text)
        END              AS area_normalizada,

        -- datas principais (já existiam)
        t.dt_ini_curso,
        t.dt_fim_curso,

        -- novas datas da turma
        t.dt_ini_inscri,
        t.dt_fim_inscri,
        t.dt_ini_mat,
        t.dt_fim_mat,
        t.dt_ini_inscri_docente,
        t.dt_fim_inscri_docente,

        -- horários
        t.hora_ini,
        t.hora_fim,

        p.status          AS status_processo,
        concat(ue.nome, ' ', coalesce(ue.sobrenome, '')) AS nome_aluno,
        ue.email          AS email_aluno,
        ue.id             AS id_user_expandido,
        p.created_at      AS criado_em,

        -- usado para filtrar os documentos obrigatórios
        p.tipo_processo,
        p.tipo_candidatura
    FROM processos p
    JOIN turmas t       ON t.id = p.turma_id
    JOIN curso c        ON c.id = t.id_curso
    JOIN user_expandido ue ON ue.id = p.user_expandido_id
    WHERE p.user_expandido_id = p_id_user_expandido
),

-- 🔍 resposta PCD (somente “Sim” conta)
resposta_pcd AS (
    SELECT 
        CASE 
            WHEN trim(r.resposta) = 'Sim'
                THEN 'sim'
            ELSE 'nao'
        END AS pcd_respondeu
    FROM respostas r
    WHERE r.user_expandido_id = p_id_user_expandido
      AND r.id_pergunta = 'eae93308-1e4d-4c67-9c53-c9abf6a31eaf'
    LIMIT 1
),

-- 🔹 Perguntas obrigatórias (arquivo ou link),
-- agora respeitando tipo_processo e tipo_candidatura do processo do aluno
obrigatorios_original AS (
    SELECT 
        b.id_turma,
        d.id_pergunta,
        prg.bloco
    FROM base b
    JOIN processo_documentos_obrigatorios d 
      ON (
           -- escopo por área
           (d.escopo = 'area'  AND public.normalizar_texto(d.id_area::text) = public.normalizar_texto(b.area_curso))
           -- escopo por turma (específico OU via área)
        OR (d.escopo = 'turma' AND (
                d.id_turma = b.id_turma 
                OR (d.id_turma IS NULL AND public.normalizar_texto(d.id_area::text) = public.normalizar_texto(b.area_curso))
           ))
      )
      -- 🔥 filtra pelo tipo de processo do próprio registro em processos
      AND d.tipo_processo = b.tipo_processo
      -- 🔥 filtra pela candidatura (NULL = vale para todas)
      AND (d.tipo_candidatura IS NULL OR d.tipo_candidatura = b.tipo_candidatura)
    JOIN perguntas prg ON prg.id = d.id_pergunta
    WHERE d.obrigatorio = TRUE
      AND lower(prg.tipo) IN ('arquivo','link')
),

-- ❌ Remover documentos do bloco PCD se aluno não respondeu “Sim”
obrigatorios_filtrados AS (
    SELECT *
    FROM obrigatorios_original o
    WHERE NOT (
        o.bloco = 'pcd'
        AND (SELECT pcd_respondeu FROM resposta_pcd) = 'nao'
    )
),

-- 🔹 Últimas respostas do aluno
respostas AS (
    SELECT r.id_pergunta, r.resposta
    FROM respostas r
    WHERE r.user_expandido_id = p_id_user_expandido
)

SELECT 
    -- colunas originais, na mesma ordem
    b.id_processo,
    b.id_turma,
    b.nome_curso,
    b.area_curso,
    b.area_normalizada,
    b.dt_ini_curso,
    b.dt_fim_curso,
    b.status_processo,
    b.nome_aluno,
    b.email_aluno,
    b.id_user_expandido,
    b.criado_em,

    -- mesma lógica de pendência que você já usava
    EXISTS (
        SELECT 1
        FROM obrigatorios_filtrados o
        WHERE o.id_turma = b.id_turma
          AND NOT EXISTS (
              SELECT 1 
              FROM public.respostas r
              WHERE r.user_expandido_id = b.id_user_expandido
                AND r.id_pergunta = o.id_pergunta
                AND (r.id_turma = b.id_turma OR r.id_turma IS NULL)
          )
    ) AS documentos_pendentes,

    -- novas datas (turma)
    b.dt_ini_inscri,
    b.dt_fim_inscri,
    b.dt_ini_mat,
    b.dt_fim_mat,
    b.dt_ini_inscri_docente,
    b.dt_fim_inscri_docente,

    -- horários
    b.hora_ini,
    b.hora_fim

FROM base b
ORDER BY b.criado_em DESC;

$function$
;

CREATE OR REPLACE FUNCTION public.get_turmas_por_area_vivas(p_area text, p_data timestamp with time zone)
 RETURNS TABLE(id uuid, id_curso uuid, nome_curso text, area_curso text, turno text, dt_ini_curso timestamp with time zone, dt_fim_curso timestamp with time zone, dt_ini_mat timestamp with time zone, dt_fim_mat timestamp with time zone, dt_ini_inscri timestamp with time zone, dt_fim_inscri timestamp with time zone, nome_turno text)
 LANGUAGE sql
 SET search_path TO 'extensions', 'public'
AS $function$
with params as (
  select
    case
      when p_area is null then null
      when lower(trim(p_area)) in ('extensão','extensao','extensão') then 'extensao'
      when lower(trim(p_area)) in ('cursos livres','curso livre','livres','livre') then 'cursos_livres'
      when lower(trim(p_area)) in ('regulares','regular') then 'regulares'
      else lower(replace(trim(p_area), ' ', '_'))
    end as area_norm,
    p_data as d
)
select 
  t.id,
  t.id_curso,
  c.nome_curso,
  (c.area)::text as area_curso,
  t.turno,
  t.dt_ini_curso,
  t.dt_fim_curso,
  t.dt_ini_mat,
  t.dt_fim_mat,
  t.dt_ini_inscri,
  t.dt_fim_inscri,
  (c.nome_curso || ' - ' || coalesce(t.turno, '')) as nome_turno
from public.turmas t
join public.curso c on c.id = t.id_curso
cross join params p
where 
  (p.area_norm is null or (c.area)::text = p.area_norm)
  and (
    t.dt_fim_curso is null
    or (t.dt_fim_curso at time zone 'America/Sao_Paulo') >= ((p.d at time zone 'America/Sao_Paulo') - interval '30 days')
  )
order by 
  coalesce(
    t.dt_ini_curso, 
    t.dt_ini_mat, 
    t.dt_ini_inscri
  ) at time zone 'America/Sao_Paulo',
  c.nome_curso;
$function$
;

CREATE OR REPLACE FUNCTION public.get_turmas_seletivo(p_area text DEFAULT NULL::text, p_ano_semestre text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_result jsonb;
begin
  with base as (
    select
      t.id as id_turma,
      (c.nome_curso || ' - ' || coalesce(t.turno, '')) as nome_curso_turno,
      case lower((c.area)::text)
        when 'extensao' then 'Extensão'
        when 'cursos_livres' then 'Cursos Livres'
        when 'regulares' then 'Regulares'
        else initcap((c.area)::text)
      end as area,
      t.ano_semestre,
      t.dt_ini_curso
    from public.turmas t
    join public.curso c on c.id = t.id_curso
    where (p_area is null or lower((c.area)::text) = lower(trim(p_area)))
      and (p_ano_semestre is null or t.ano_semestre = p_ano_semestre)
  ),
  andamento as (
    select id_turma, nome_curso_turno, area, ano_semestre
    from base
    where now() < dt_ini_curso
  ),
  encerrados as (
    select id_turma, nome_curso_turno, area, ano_semestre
    from base
    where now() >= dt_ini_curso
  )
  select jsonb_build_object(
    'em_andamento', coalesce(jsonb_agg(to_jsonb(andamento.*)) filter (where andamento.id_turma is not null), '[]'::jsonb),
    'encerrados', coalesce(jsonb_agg(to_jsonb(encerrados.*)) filter (where encerrados.id_turma is not null), '[]'::jsonb)
  )
  into v_result
  from andamento
  full join encerrados on false;

  return coalesce(v_result, '{}'::jsonb);
end $function$
;

CREATE OR REPLACE FUNCTION public.get_user_status(p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_status boolean;
BEGIN
    SELECT status INTO v_status
    FROM public.user_expandido
    WHERE user_id = p_user_id;

    RETURN v_status;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_users_por_papeis_paginado(p_pagina integer DEFAULT 1, p_limite integer DEFAULT 20, p_busca text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_result jsonb;
    v_papeis_ids uuid[] := ARRAY[
        'fbae2a34-8f84-464d-8f04-11e8f65443f9'::uuid, -- Analistas
        'e4a0f9c0-7612-4cf9-92c7-a6ab781dabf6'::uuid, -- Assistentes
        '65aaed43-f4cd-4b47-ac2d-aaab3a301c78'::uuid, -- Coordenadores
        '1ff10e30-3a2b-4a61-ba8c-0d74ba2cde6b'::uuid, -- Convidados
        '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid  -- Docentes
    ];
BEGIN
    WITH filtered_data AS (
        SELECT 
            u.*
        FROM public.user_expandido u
        LEFT JOIN auth.users au ON au.id = u.user_id
        WHERE u.papel_id = ANY(v_papeis_ids)
          AND (p_busca IS NULL OR (
               u.nome ILIKE '%' || p_busca || '%'
            OR u.sobrenome ILIKE '%' || p_busca || '%'
          ))
    ),
    total_count AS (
        SELECT count(*) AS qtd FROM filtered_data
    ),
    paginated_rows AS (
        SELECT 
            fd.*,
            au.created_at as auth_created_at
        FROM filtered_data fd
        LEFT JOIN auth.users au ON au.id = fd.user_id
        ORDER BY au.created_at DESC NULLS LAST
        LIMIT p_limite OFFSET (p_pagina - 1) * p_limite
    )
    SELECT jsonb_build_object(
        'qtd_itens', (SELECT qtd FROM total_count),
        'qtd_paginas', ceil((SELECT qtd FROM total_count)::numeric / GREATEST(p_limite, 1)),
        'itens', COALESCE(jsonb_agg(to_jsonb(pr.*) - 'auth_created_at'), '[]'::jsonb)
    )
    INTO v_result
    FROM paginated_rows pr;

    RETURN v_result;

EXCEPTION
    WHEN OTHERS THEN
         RETURN jsonb_build_object(
            'qtd_itens', 0,
            'qtd_paginas', 0,
            'itens', '[]'::jsonb,
            'erro', SQLERRM
         );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.inserir_sala_horarios(p_nome text, p_cor text)
 RETURNS void
 LANGUAGE sql
 SET search_path TO 'extensions', 'public'
AS $function$
  insert into public.salas_horarios (
    nome, cor,
    horario_total, hora_ini, minuto_ini, hora_fim, minuto_fim,
    turno_cod, turno_nome
  )
  select
    p_nome,
    p_cor,
    h.horario_total,
    h.hora_ini,
    h.minuto_ini,
    h.hora_fim,
    h.minuto_fim,
    h.turno_cod,
    h.turno_nome
  from public.slot_horarios h;
$function$
;

CREATE OR REPLACE FUNCTION public.listar_turmas_disponiveis(p_data timestamp with time zone DEFAULT NULL::timestamp with time zone, p_area text DEFAULT NULL::text, p_ano_semestre text DEFAULT NULL::text)
 RETURNS TABLE(id_turma uuid, nome_curso text, area_curso text, area_curso_int text, ano text, ano_semestre text, cod_modulo text, cod_turma text, turno text, dias_semana_array text[], dias_semana_str text, qtd_minutos_total integer, qtd_horas_total numeric, qtd_modulos integer, qtd_encontros_modulo integer, qtd_encontros_totais integer, qtd_minutos_encontro integer, qtd_horas_encontro numeric, qtd_minutos_periodo integer, qtd_horas_periodo numeric, dt_ini_inscri text, dt_fim_inscri text, dt_ini_curso text, dt_fim_curso text, link_video boolean)
 LANGUAGE sql
AS $function$
with params as (
  select
    case
      when p_area is null then null
      when lower(trim(p_area)) in ('extensão','extensao','extensão') then 'extensao'
      when lower(trim(p_area)) in ('cursos livres','curso livre','livres','livre') then 'cursos_livres'
      when lower(trim(p_area)) in ('regulares','regular') then 'regulares'
      else lower(replace(trim(p_area), ' ', '_'))
    end as area_norm,
    p_data as d,
    p_ano_semestre as as_key
)
select
  t.id                                           as id_turma,
  c.nome_curso                                   as nome_curso,

  -- nome "bonito" da área
  case c.area
    when 'extensao' then 'Extensão'
    when 'cursos_livres' then 'Cursos Livres'
    when 'regulares' then 'Regulares'
    else initcap(replace(c.area::text, '_', ' '))
  end                                             as area_curso,

  -- valor interno (enum / sem normalizar)
  (c.area)::text                                 as area_curso_int,

  t.ano::text                                    as ano,
  t.ano_semestre                                 as ano_semestre,
  t.cod_modulo                                   as cod_modulo,
  t.cod_turma                                    as cod_turma,
  t.turno                                        as turno,

  coalesce(array_agg(td.dia_da_semana_text order by td.dia_da_semana_num), '{}'::text[]) as dias_semana_array,
  coalesce(string_agg(td.dia_da_semana_text, ' | ' order by td.dia_da_semana_num), '')    as dias_semana_str,

  c.qtd_minutos_total                            as qtd_minutos_total,
  case when c.qtd_minutos_total is not null
       then round(c.qtd_minutos_total::numeric/60, 2)
       else null end                              as qtd_horas_total,

  c.qtd_modulos                                  as qtd_modulos,
  c.qtd_aulas_modulo                             as qtd_encontros_modulo,
  case when c.qtd_modulos is not null and c.qtd_aulas_modulo is not null
       then c.qtd_modulos * c.qtd_aulas_modulo
       else null end                              as qtd_encontros_totais,

  coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo)        as qtd_minutos_encontro,
  case when coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo) is not null
       then round(coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo)::numeric/60, 2)
       else null end                              as qtd_horas_encontro,

  c.qtd_minutos_periodo                          as qtd_minutos_periodo,
  case when c.qtd_minutos_periodo is not null
       then round(c.qtd_minutos_periodo::numeric/60, 2)
       else null end                              as qtd_horas_periodo,

  -- formato ISO (YYYY-MM-DD) compatível com WeWeb
  to_char(t.dt_ini_inscri at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_ini_inscri,
  to_char(t.dt_fim_inscri at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_fim_inscri,
  to_char(t.dt_ini_curso  at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_ini_curso,
  to_char(t.dt_fim_curso  at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_fim_curso,
  t.link_video                                   as link_video

from public.turmas t
join public.curso  c on c.id = t.id_curso
left join public.turmas_dias td on td.id_turma = t.id
cross join params p
where
  (p.area_norm is null or (c.area)::text = p.area_norm)
  and (p.as_key is null or t.ano_semestre = p.as_key)
  and (
    p.d is null
    or (
      -- UNICA ALTERAÇÃO: Cast para DATE garante que o dia 02/01 seja maior ou igual a 02/01 até o fim do dia
      (t.dt_ini_inscri at time zone 'America/Sao_Paulo')::date <= (p.d at time zone 'America/Sao_Paulo')::date
      and (t.dt_fim_inscri at time zone 'America/Sao_Paulo')::date >= (p.d at time zone 'America/Sao_Paulo')::date
    )
  )
group by
  t.id, c.nome_curso, c.area, t.ano, t.ano_semestre,
  t.cod_modulo, t.cod_turma, t.turno, c.qtd_minutos_total, c.qtd_modulos,
  c.qtd_aulas_modulo, c.qtd_minutos_aula, c.qtd_minutos_periodo,
  t.dt_ini_inscri, t.dt_fim_inscri, t.dt_ini_curso, t.dt_fim_curso,
  t.link_video
order by
  c.nome_curso, t.ano_semestre, t.cod_modulo, t.cod_turma;
$function$
;

CREATE OR REPLACE FUNCTION public.listar_turmas_disponiveis_v2(p_data timestamp with time zone DEFAULT NULL::timestamp with time zone, p_area text DEFAULT NULL::text, p_ano_semestre text DEFAULT NULL::text)
 RETURNS TABLE(id_turma uuid, nome_curso text, area_curso text, area_curso_int text, ano text, ano_semestre text, cod_modulo text, cod_turma text, turno text, dias_semana_array text[], dias_semana_str text, qtd_minutos_total integer, qtd_horas_total numeric, qtd_modulos integer, qtd_encontros_modulo integer, qtd_encontros_totais integer, qtd_minutos_encontro integer, qtd_horas_encontro numeric, qtd_minutos_periodo integer, qtd_horas_periodo numeric, dt_ini_inscri text, dt_fim_inscri text, dt_ini_curso text, dt_fim_curso text, link_video boolean)
 LANGUAGE sql
AS $function$
with params as (
  select
    case
      when p_area is null then null
      when lower(trim(p_area)) in ('extensão','extensao','extensão') then 'extensao'
      when lower(trim(p_area)) in ('cursos livres','curso livre','livres','livre') then 'cursos_livres'
      when lower(trim(p_area)) in ('regulares','regular') then 'regulares'
      else lower(replace(trim(p_area), ' ', '_'))
    end as area_norm,
    p_data as d,
    p_ano_semestre as as_key
)
select
  t.id                                           as id_turma,
  c.nome_curso                                   as nome_curso,

  -- nome "bonito" da área
  case c.area
    when 'extensao' then 'Extensão'
    when 'cursos_livres' then 'Cursos Livres'
    when 'regulares' then 'Regulares'
    else initcap(replace(c.area::text, '_', ' '))
  end                                             as area_curso,

  -- valor interno (enum / sem normalizar)
  (c.area)::text                                 as area_curso_int,

  t.ano::text                                    as ano,
  t.ano_semestre                                 as ano_semestre,
  t.cod_modulo                                   as cod_modulo,
  t.cod_turma                                    as cod_turma,
  t.turno                                        as turno,

  coalesce(array_agg(td.dia_da_semana_text order by td.dia_da_semana_num), '{}'::text[]) as dias_semana_array,
  coalesce(string_agg(td.dia_da_semana_text, ' | ' order by td.dia_da_semana_num), '')    as dias_semana_str,

  c.qtd_minutos_total                            as qtd_minutos_total,
  case when c.qtd_minutos_total is not null
       then round(c.qtd_minutos_total::numeric/60, 2)
       else null end                              as qtd_horas_total,

  c.qtd_modulos                                  as qtd_modulos,
  c.qtd_aulas_modulo                             as qtd_encontros_modulo,
  case when c.qtd_modulos is not null and c.qtd_aulas_modulo is not null
       then c.qtd_modulos * c.qtd_aulas_modulo
       else null end                              as qtd_encontros_totais,

  coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo)        as qtd_minutos_encontro,
  case when coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo) is not null
       then round(coalesce(c.qtd_minutos_aula, c.qtd_minutos_periodo)::numeric/60, 2)
       else null end                              as qtd_horas_encontro,

  c.qtd_minutos_periodo                          as qtd_minutos_periodo,
  case when c.qtd_minutos_periodo is not null
       then round(c.qtd_minutos_periodo::numeric/60, 2)
       else null end                              as qtd_horas_periodo,

  -- formato ISO (YYYY-MM-DD) compatível com WeWeb
  to_char(t.dt_ini_inscri at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_ini_inscri,
  to_char(t.dt_fim_inscri at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_fim_inscri,
  to_char(t.dt_ini_curso  at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_ini_curso,
  to_char(t.dt_fim_curso  at time zone 'America/Sao_Paulo', 'YYYY-MM-DD') as dt_fim_curso,
  t.link_video                                   as link_video

from public.turmas t
join public.curso  c on c.id = t.id_curso
left join public.turmas_dias td on td.id_turma = t.id
cross join params p
where
  (p.area_norm is null or (c.area)::text = p.area_norm)
  and (p.as_key is null or t.ano_semestre = p.as_key)
  and (
    p.d is null
    or (
      -- UNICA ALTERAÇÃO: Cast para DATE garante que o dia 02/01 seja maior ou igual a 02/01 até o fim do dia
      (t.dt_ini_inscri at time zone 'America/Sao_Paulo')::date <= (p.d at time zone 'America/Sao_Paulo')::date
      and (t.dt_fim_inscri at time zone 'America/Sao_Paulo')::date >= (p.d at time zone 'America/Sao_Paulo')::date
    )
  )
group by
  t.id, c.nome_curso, c.area, t.ano, t.ano_semestre,
  t.cod_modulo, t.cod_turma, t.turno, c.qtd_minutos_total, c.qtd_modulos,
  c.qtd_aulas_modulo, c.qtd_minutos_aula, c.qtd_minutos_periodo,
  t.dt_ini_inscri, t.dt_fim_inscri, t.dt_ini_curso, t.dt_fim_curso,
  t.link_video
order by
  c.nome_curso, t.ano_semestre, t.cod_modulo, t.cod_turma;
$function$
;

CREATE OR REPLACE FUNCTION public.normalizar_texto(p text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    v text;
BEGIN
    IF p IS NULL THEN
        RETURN NULL;
    END IF;

    -- 1) tira acentos
    v := unaccent(p);

    -- 2) tudo minúsculo
    v := lower(v);

    -- 3) remove tudo que NÃO é letra ou número
    --    MAS com conjunto unicode para garantir consistência visual
    v := regexp_replace(v, '[^a-z0-9]', '', 'g');

    RETURN v;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notificar_processo_enviado()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  perform public.enviar_dados_processo(NEW.id);
  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.operar_resposta_arquivo(p_id_user_expandido uuid, p_id_pergunta uuid, p_operacao text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_result jsonb;
  v_exists boolean;
BEGIN
  -- verificar se existe resposta
  SELECT EXISTS (
    SELECT 1
    FROM public.respostas
    WHERE user_expandido_id = p_id_user_expandido
      AND id_pergunta = p_id_pergunta
  )
  INTO v_exists;

  IF NOT v_exists THEN
    RETURN jsonb_build_object(
      'status', 'erro',
      'mensagem', 'Nenhuma resposta encontrada para este usuário/pergunta'
    );
  END IF;

  ---------------------------------------------------------------------
  -- 🧹 LIMPAR (mantém o registro mas apaga conteúdo)
  ---------------------------------------------------------------------
  IF lower(p_operacao) = 'limpar' THEN
    UPDATE public.respostas
    SET 
      resposta = NULL,
      arquivo_original = NULL,
      aprovado_doc = NULL,
      atualizado_em = now()
    WHERE user_expandido_id = p_id_user_expandido
      AND id_pergunta = p_id_pergunta;

    RETURN jsonb_build_object(
      'status', 'ok',
      'operacao', 'limpar',
      'mensagem', 'Conteúdo apagado com sucesso'
    );
  END IF;

  ---------------------------------------------------------------------
  -- ❌ DELETAR (remove a linha inteira)
  ---------------------------------------------------------------------
  IF lower(p_operacao) = 'deletar' THEN
    DELETE FROM public.respostas
    WHERE user_expandido_id = p_id_user_expandido
      AND id_pergunta = p_id_pergunta;

    RETURN jsonb_build_object(
      'status', 'ok',
      'operacao', 'deletar',
      'mensagem', 'Registro removido com sucesso'
    );
  END IF;

  ---------------------------------------------------------------------
  -- 🚫 Operação inválida
  ---------------------------------------------------------------------
  RETURN jsonb_build_object(
    'status', 'erro',
    'mensagem', 'Operação inválida. Use "limpar" ou "deletar".'
  );

END;
$function$
;

CREATE OR REPLACE FUNCTION public.par_trg_fila_email()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_normalized_area text;
    v_lock_result jsonb;
BEGIN
    -- 1. Scope: 'user'
    IF NEW.escopo = 'user' THEN
        INSERT INTO public.email_queue (
            id_thread,
            email_destino,
            assunto,
            mensagem,
            status_fila,
            tentativas,
            data_envio
        )
        SELECT
            NEW.id,
            u.email,
            NEW.assunto,
            NEW.mensagem,
            'aguardando',
            0,
            now()
        FROM public.user_expandido u
        WHERE u.id = NEW.id_user_destino
        AND u.email IS NOT NULL;

    -- 2. Scope: 'turma'
    ELSIF NEW.escopo = 'turma' THEN
        INSERT INTO public.email_queue (
            id_thread,
            email_destino,
            assunto,
            mensagem,
            status_fila,
            tentativas,
            data_envio
        )
        SELECT
            NEW.id,
            u.email,
            NEW.assunto,
            NEW.mensagem,
            'aguardando',
            0,
            now()
        FROM public.matriculas m
        JOIN public.user_expandido u ON u.id = m.id_aluno
        WHERE m.id_turma = NEW.id_turma
        AND u.email IS NOT NULL;

    -- 3. Scope: 'area'
    ELSIF NEW.escopo = 'area' THEN
        -- Normaliza o filtro de área recebido
        v_normalized_area := public.normalizar_texto(NEW.filtro_area);

        INSERT INTO public.email_queue (
            id_thread,
            email_destino,
            assunto,
            mensagem,
            status_fila,
            tentativas,
            data_envio
        )
        SELECT DISTINCT
            NEW.id,
            u.email,
            NEW.assunto,
            NEW.mensagem,
            'aguardando',
            0,
            now()
        FROM public.turmas t
        JOIN public.matriculas m ON m.id_turma = t.id
        JOIN public.user_expandido u ON u.id = m.id_aluno
        WHERE 
            -- Compara com a área do curso normalizada
            public.normalizar_texto(t.area_curso) = v_normalized_area
        AND (NEW.ano_semestre IS NULL OR t.ano_semestre = NEW.ano_semestre)
        AND u.email IS NOT NULL;
        
    END IF;

    -- 4. INICIA O CICLO IMEDIATAMENTE
    -- Chama a função de bloqueio para preparar o primeiro lote (10 itens)
    -- Isso já vai setar a thread como 'enviando', disparando o Webhook.
    PERFORM public.fn_email_queue_batch_lock(NEW.id, 10);

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.pergunta_arquivo_pivotada(jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
DECLARE
  resultado jsonb := '{}';
  reg record;
  user_id uuid := ($1->>'id_user')::uuid;
BEGIN
  FOR reg IN
    SELECT 
      lower(regexp_replace(p.pergunta, '[^a-zA-Z0-9_]', '_', 'g')) as chave,
      r.resposta
    FROM public.respostas r
    JOIN public.perguntas p ON p.id = r.id_pergunta
    WHERE r.user_expandido_id = user_id
      AND r.tipo_resposta = 'arquivo'
  LOOP
    resultado := resultado || jsonb_build_object(reg.chave, reg.resposta);
  END LOOP;
  
  RETURN resultado;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.pergunta_resposta_pivotada(jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
DECLARE
  resultado jsonb := '{}';
  reg record;
  user_id uuid := ($1->>'id_user')::uuid;
BEGIN
  FOR reg IN
    SELECT 
      lower(regexp_replace(p.pergunta, '[^a-zA-Z0-9_]', '_', 'g')) as chave,
      r.resposta
    FROM public.respostas r
    JOIN public.perguntas p ON p.id = r.id_pergunta
    WHERE r.user_expandido_id = user_id
      AND r.tipo_resposta != 'arquivo'
  LOOP
    resultado := resultado || jsonb_build_object(reg.chave, reg.resposta);
  END LOOP;
  
  RETURN resultado;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.perguntas_preencher_id_user_expandido_auth()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'pg_temp'
AS $function$
declare
  v_auth_id uuid;
begin
  v_auth_id := null;

  -- Lê user_id (ex.: processos)
  if (to_jsonb(new) ? 'user_id') then
    begin v_auth_id := (to_jsonb(new)->>'user_id')::uuid; exception when others then v_auth_id := null; end;
  end if;

  -- Lê id_usuario (ex.: respostas)
  if v_auth_id is null and (to_jsonb(new) ? 'id_usuario') then
    begin v_auth_id := (to_jsonb(new)->>'id_usuario')::uuid; exception when others then v_auth_id := null; end;
  end if;

  if new.user_expandido_id is null and v_auth_id is not null then
    select ue.id into new.user_expandido_id
    from public.user_expandido ue
    where ue.user_id = v_auth_id
    limit 1;
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.registrar_user_expandido(p_user_id uuid, p_email text, p_nome text, p_sobrenome text, p_papel_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'extensions', 'public'
AS $function$
BEGIN
  INSERT INTO user_expandido (user_id, email, nome, sobrenome, papel_id)
  VALUES (p_user_id, p_email, p_nome, p_sobrenome, p_papel_id);

  INSERT INTO papeis_user_auth (user_id, papel_id)
  VALUES (p_user_id, p_papel_id);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.salvar_respostas_usuario(p_id_usuario uuid, p_respostas jsonb, p_user_expandido_id uuid DEFAULT NULL::uuid, p_id_turma uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_expandido_id uuid;
    v_resposta_invalida jsonb;
BEGIN
    -------------------------------------------------------------------
    -- 0. Validação de Entrada (NULL ou Vazio)
    -------------------------------------------------------------------
    SELECT to_jsonb(r) INTO v_resposta_invalida
    FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text)
    WHERE r.resposta IS NULL OR trim(r.resposta) = '';

    IF v_resposta_invalida IS NOT NULL THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Não é permitido salvar respostas vazias ou nulas.', 'dado_invalido', v_resposta_invalida);
    END IF;

    -------------------------------------------------------------------
    -- 1. Resolver user_expandido_id
    -------------------------------------------------------------------
    IF p_user_expandido_id IS NOT NULL THEN
        v_user_expandido_id := p_user_expandido_id;
    ELSIF p_id_usuario IS NOT NULL THEN
        SELECT ue.id INTO v_user_expandido_id FROM public.user_expandido ue WHERE ue.user_id = p_id_usuario LIMIT 1;
        IF v_user_expandido_id IS NULL THEN
            RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Usuário expandido não encontrado.');
        END IF;
    ELSE
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Identificação do usuário necessária.');
    END IF;

    -------------------------------------------------------------------
    -- 2. Lógica Estrita da Rainha (PDO)
    -------------------------------------------------------------------
    BEGIN
        DECLARE
            v_area_turma text;
        BEGIN
            -- 2.1 Descobrir Área da Turma para o contexto da Rainha
            IF p_id_turma IS NOT NULL THEN
                SELECT c.area::text INTO v_area_turma -- Force cast to text here
                FROM public.turmas t
                JOIN public.curso c ON c.id = t.id_curso
                WHERE t.id = p_id_turma;
            END IF;

            -- 2.2 Preparar Lote de Salva Decidindo o ID_TURMA final
            CREATE TEMP TABLE tmp_save_final ON COMMIT DROP AS
            WITH raw_inputs AS (
                SELECT 
                    (r.id_pergunta)::uuid AS id_pergunta,
                    r.resposta,
                    NULLIF(r.nome_arquivo_original, '') AS arquivo_original
                FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text, nome_arquivo_original text)
            ),
            scope_decision AS (
                SELECT 
                    ri.*,
                    COALESCE(p.tipo, 'texto') AS tipo_resposta,
                    
                    -- AQUI ESTÁ A LÓGICA PEDIDA:
                    -- "A tabela processos_documentos_obrigatorios é quem diz"
                    CASE 
                        -- Se a Rainha diz que é TURMA para este contexto -> Salva com p_id_turma
                        WHEN pdo.escopo = 'turma' THEN p_id_turma
                        
                        -- Qualquer outro caso (Area, Curso, Não achou, p_id_turma nulo) -> Salva GLOBAL (NULL)
                        ELSE NULL 
                    END AS final_id_turma
                FROM raw_inputs ri
                LEFT JOIN public.perguntas p ON p.id = ri.id_pergunta
                LEFT JOIN public.processo_documentos_obrigatorios pdo 
                   ON pdo.id_pergunta = ri.id_pergunta
                   -- Match de Contexto:
                   -- 1. Existe config específica para a Turma?
                   -- 2. OU Existe config para a Área (template) e sem turma específica definida?
                   AND (
                       (pdo.id_turma = p_id_turma)
                       OR 
                       (
                           pdo.id_turma IS NULL 
                           AND v_area_turma IS NOT NULL 
                           -- ROBUST FIX: Usar normalizacao para comparar Area
                           AND public.normalizar_texto(pdo.id_area::text) = public.normalizar_texto(v_area_turma)
                       )
                   )
                
                -- Se houver ambiguidade (ex: configs de Área e Turma ao mesmo tempo),
                -- a ordenação deve garantir que a regra mais específica (turma) ganhe.
                -- (Isso depende de como a tabela está populada, mas o LEFT JOIN pega tudo)
            )
            -- DISTINCT ON para desambiguar caso venha mais de um registro do PDO
            -- Se vier um 'turma' e um 'area', priorizamos 'turma' na ordem abaixo
            SELECT DISTINCT ON (id_pergunta) * 
            FROM scope_decision
            ORDER BY id_pergunta, 
                     (CASE WHEN final_id_turma IS NOT NULL THEN 1 ELSE 2 END); -- Prioriza quem resolveu ID de turma

            ---------------------------------------------------------------
            -- 2.3 Executar Upserts (Separados para evitar erro de sintaxe)
            ---------------------------------------------------------------

            -- LOTE 1: GLOBAIS (final_id_turma IS NULL)
            INSERT INTO public.respostas (
                user_expandido_id, id_usuario, id_pergunta, id_turma,
                resposta, arquivo_original, tipo_resposta, criado_em, atualizado_em
            )
            SELECT 
                v_user_expandido_id, p_id_usuario, id_pergunta, NULL, 
                resposta, arquivo_original, tipo_resposta, NOW(), NULL
            FROM tmp_save_final
            WHERE final_id_turma IS NULL
            ON CONFLICT (user_expandido_id, id_pergunta) WHERE id_turma IS NULL
            DO UPDATE SET
                resposta         = EXCLUDED.resposta,
                arquivo_original = EXCLUDED.arquivo_original,
                tipo_resposta    = EXCLUDED.tipo_resposta,
                atualizado_em    = NOW(),
                id_usuario       = EXCLUDED.id_usuario;

            -- LOTE 2: TURMA (final_id_turma IS NOT NULL)
            INSERT INTO public.respostas (
                user_expandido_id, id_usuario, id_pergunta, id_turma,
                resposta, arquivo_original, tipo_resposta, criado_em, atualizado_em
            )
            SELECT 
                v_user_expandido_id, p_id_usuario, id_pergunta, final_id_turma,
                resposta, arquivo_original, tipo_resposta, NOW(), NULL
            FROM tmp_save_final
            WHERE final_id_turma IS NOT NULL
            ON CONFLICT (user_expandido_id, id_pergunta, id_turma) WHERE id_turma IS NOT NULL
            DO UPDATE SET
                resposta         = EXCLUDED.resposta,
                arquivo_original = EXCLUDED.arquivo_original,
                tipo_resposta    = EXCLUDED.tipo_resposta,
                atualizado_em    = NOW(),
                id_usuario       = EXCLUDED.id_usuario;

        END;

        RETURN jsonb_build_object('sucesso', true, 'mensagem', 'Respostas salvas com sucesso.');

    EXCEPTION WHEN OTHERS THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Erro ao salvar respostas: ' || SQLERRM);
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.salvar_respostas_usuario_expandido(p_user_expandido_id uuid, p_respostas jsonb)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  -- Atualiza se já existir
  update public.respostas r
  set 
    resposta = t.value ->> 'resposta',
    arquivo_original = t.value ->> 'nome_arquivo_original',
    tipo_resposta = coalesce(p.tipo, 'texto'),
    atualizado_em = now()
  from jsonb_array_elements(p_respostas) as t(value)
  join public.perguntas p on p.id = (t.value ->> 'id_pergunta')::uuid
  where 
    r.user_expandido_id = p_user_expandido_id
    and r.id_pergunta = p.id;

  -- Insere se não existir
  insert into public.respostas (
    id_pergunta,
    user_expandido_id,
    resposta,
    arquivo_original,
    tipo_resposta,
    criado_em
  )
  select
    p.id,
    p_user_expandido_id,
    t.value ->> 'resposta',
    t.value ->> 'nome_arquivo_original',
    coalesce(p.tipo, 'texto'),
    now()
  from jsonb_array_elements(p_respostas) as t(value)
  join public.perguntas p on p.id = (t.value ->> 'id_pergunta')::uuid
  where not exists (
    select 1 from public.respostas r
    where 
      r.user_expandido_id = p_user_expandido_id
      and r.id_pergunta = p.id
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.salvar_respostas_usuario_turma(p_id_usuario uuid, p_respostas jsonb, p_user_expandido_id uuid DEFAULT NULL::uuid, p_id_turma uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_expandido_id uuid;
    v_resposta_invalida jsonb;
BEGIN
    -------------------------------------------------------------------
    -- 0. Validação de Entrada (NULL ou Vazio)
    -------------------------------------------------------------------
    SELECT to_jsonb(r) INTO v_resposta_invalida
    FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text)
    WHERE r.resposta IS NULL OR trim(r.resposta) = '';

    IF v_resposta_invalida IS NOT NULL THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Não é permitido salvar respostas vazias ou nulas.', 'dado_invalido', v_resposta_invalida);
    END IF;

    -------------------------------------------------------------------
    -- 1. Resolver user_expandido_id
    -------------------------------------------------------------------
    IF p_user_expandido_id IS NOT NULL THEN
        v_user_expandido_id := p_user_expandido_id;
    ELSIF p_id_usuario IS NOT NULL THEN
        SELECT ue.id INTO v_user_expandido_id FROM public.user_expandido ue WHERE ue.user_id = p_id_usuario LIMIT 1;
        IF v_user_expandido_id IS NULL THEN
            RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Usuário expandido não encontrado.');
        END IF;
    ELSE
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Identificação do usuário necessária.');
    END IF;

    -------------------------------------------------------------------
    -- 2. Lógica Estrita da Rainha (PDO)
    -------------------------------------------------------------------
    BEGIN
        DECLARE
            v_area_turma text;
        BEGIN
            -- 2.1 Descobrir Área da Turma para o contexto da Rainha
            IF p_id_turma IS NOT NULL THEN
                SELECT c.area::text INTO v_area_turma -- Force cast to text here
                FROM public.turmas t
                JOIN public.curso c ON c.id = t.id_curso
                WHERE t.id = p_id_turma;
            END IF;

            -- 2.2 Preparar Lote de Salva Decidindo o ID_TURMA final
            CREATE TEMP TABLE tmp_save_final ON COMMIT DROP AS
            WITH raw_inputs AS (
                SELECT 
                    (r.id_pergunta)::uuid AS id_pergunta,
                    r.resposta,
                    NULLIF(r.nome_arquivo_original, '') AS arquivo_original
                FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text, nome_arquivo_original text)
            ),
            scope_decision AS (
                SELECT 
                    ri.*,
                    COALESCE(p.tipo, 'texto') AS tipo_resposta,
                    
                    -- AQUI ESTÁ A LÓGICA PEDIDA:
                    -- "A tabela processos_documentos_obrigatorios é quem diz"
                    CASE 
                        -- Se a Rainha diz que é TURMA para este contexto -> Salva com p_id_turma
                        WHEN pdo.escopo = 'turma' THEN p_id_turma
                        
                        -- Qualquer outro caso (Area, Curso, Não achou, p_id_turma nulo) -> Salva GLOBAL (NULL)
                        ELSE NULL 
                    END AS final_id_turma
                FROM raw_inputs ri
                LEFT JOIN public.perguntas p ON p.id = ri.id_pergunta
                LEFT JOIN public.processo_documentos_obrigatorios pdo 
                   ON pdo.id_pergunta = ri.id_pergunta
                   -- Match de Contexto:
                   -- 1. Existe config específica para a Turma?
                   -- 2. OU Existe config para a Área (template) e sem turma específica definida?
                   AND (
                       (pdo.id_turma = p_id_turma)
                       OR 
                       (
                           pdo.id_turma IS NULL 
                           AND v_area_turma IS NOT NULL 
                           -- ROBUST FIX: Usar normalizacao para comparar Area
                           AND public.normalizar_texto(pdo.id_area::text) = public.normalizar_texto(v_area_turma)
                       )
                   )
                
                -- Se houver ambiguidade (ex: configs de Área e Turma ao mesmo tempo),
                -- a ordenação deve garantir que a regra mais específica (turma) ganhe.
                -- (Isso depende de como a tabela está populada, mas o LEFT JOIN pega tudo)
            )
            -- DISTINCT ON para desambiguar caso venha mais de um registro do PDO
            -- Se vier um 'turma' e um 'area', priorizamos 'turma' na ordem abaixo
            SELECT DISTINCT ON (id_pergunta) * 
            FROM scope_decision
            ORDER BY id_pergunta, 
                     (CASE WHEN final_id_turma IS NOT NULL THEN 1 ELSE 2 END); -- Prioriza quem resolveu ID de turma

            ---------------------------------------------------------------
            -- 2.3 Executar Upserts (Separados para evitar erro de sintaxe)
            ---------------------------------------------------------------

            -- LOTE 1: GLOBAIS (final_id_turma IS NULL)
            INSERT INTO public.respostas (
                user_expandido_id, id_usuario, id_pergunta, id_turma,
                resposta, arquivo_original, tipo_resposta, criado_em, atualizado_em
            )
            SELECT 
                v_user_expandido_id, p_id_usuario, id_pergunta, NULL, 
                resposta, arquivo_original, tipo_resposta, NOW(), NULL
            FROM tmp_save_final
            WHERE final_id_turma IS NULL
            ON CONFLICT (user_expandido_id, id_pergunta) WHERE id_turma IS NULL
            DO UPDATE SET
                resposta         = EXCLUDED.resposta,
                arquivo_original = EXCLUDED.arquivo_original,
                tipo_resposta    = EXCLUDED.tipo_resposta,
                atualizado_em    = NOW(),
                id_usuario       = EXCLUDED.id_usuario;

            -- LOTE 2: TURMA (final_id_turma IS NOT NULL)
            INSERT INTO public.respostas (
                user_expandido_id, id_usuario, id_pergunta, id_turma,
                resposta, arquivo_original, tipo_resposta, criado_em, atualizado_em
            )
            SELECT 
                v_user_expandido_id, p_id_usuario, id_pergunta, final_id_turma,
                resposta, arquivo_original, tipo_resposta, NOW(), NULL
            FROM tmp_save_final
            WHERE final_id_turma IS NOT NULL
            ON CONFLICT (user_expandido_id, id_pergunta, id_turma) WHERE id_turma IS NOT NULL
            DO UPDATE SET
                resposta         = EXCLUDED.resposta,
                arquivo_original = EXCLUDED.arquivo_original,
                tipo_resposta    = EXCLUDED.tipo_resposta,
                atualizado_em    = NOW(),
                id_usuario       = EXCLUDED.id_usuario;

        END;

        RETURN jsonb_build_object('sucesso', true, 'mensagem', 'Respostas salvas com sucesso.');

    EXCEPTION WHEN OTHERS THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Erro ao salvar respostas: ' || SQLERRM);
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.salvar_respostas_usuario_v2(p_id_usuario uuid, p_respostas jsonb, p_user_expandido_id uuid DEFAULT NULL::uuid, p_id_turma uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_expandido_id uuid;
    v_resposta_invalida jsonb;
BEGIN
    -- 0. Validação
    SELECT to_jsonb(r) INTO v_resposta_invalida
    FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text)
    WHERE r.resposta IS NULL OR trim(r.resposta) = '' LIMIT 1;

    IF v_resposta_invalida IS NOT NULL THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Respostas vazias não permitidas.', 'dado_invalido', v_resposta_invalida);
    END IF;

    -- 1. Resolver User
    IF p_user_expandido_id IS NOT NULL THEN v_user_expandido_id := p_user_expandido_id;
    ELSIF p_id_usuario IS NOT NULL THEN
        SELECT ue.id INTO v_user_expandido_id FROM public.user_expandido ue WHERE ue.user_id = p_id_usuario LIMIT 1;
        IF v_user_expandido_id IS NULL THEN RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Usuário não encontrado.'); END IF;
    ELSE RETURN jsonb_build_object('sucesso', false, 'mensagem', 'ID de usuário obrigatório.'); END IF;

    -- 2. Persistência
    BEGIN
        IF p_id_turma IS NOT NULL THEN
            -- INSERT TURMA
            WITH dados AS (
                SELECT v_user_expandido_id AS user_expandido_id, p_id_usuario AS id_usuario, (r.id_pergunta)::uuid AS id_pergunta, r.resposta, NULLIF(r.nome_arquivo_original, '') AS arquivo_original
                FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text, nome_arquivo_original text)
            ), com_tipo AS (
                SELECT d.*, COALESCE(pg.tipo, 'texto') AS tipo_resposta FROM dados d LEFT JOIN public.perguntas pg ON pg.id = d.id_pergunta
            )
            INSERT INTO public.respostas (user_expandido_id, id_usuario, id_pergunta, id_turma, resposta, arquivo_original, tipo_resposta, criado_em)
            SELECT user_expandido_id, id_usuario, id_pergunta, p_id_turma, resposta, arquivo_original, tipo_resposta, NOW() FROM com_tipo
            ON CONFLICT (user_expandido_id, id_pergunta, id_turma) WHERE id_turma IS NOT NULL
            DO UPDATE SET resposta = EXCLUDED.resposta, arquivo_original = EXCLUDED.arquivo_original, tipo_resposta = EXCLUDED.tipo_resposta, atualizado_em = NOW(), id_usuario = EXCLUDED.id_usuario;
        ELSE
            -- INSERT GLOBAL
             WITH dados AS (
                SELECT v_user_expandido_id AS user_expandido_id, p_id_usuario AS id_usuario, (r.id_pergunta)::uuid AS id_pergunta, r.resposta, NULLIF(r.nome_arquivo_original, '') AS arquivo_original
                FROM jsonb_to_recordset(p_respostas) AS r(id_pergunta text, resposta text, nome_arquivo_original text)
            ), com_tipo AS (
                SELECT d.*, COALESCE(pg.tipo, 'texto') AS tipo_resposta FROM dados d LEFT JOIN public.perguntas pg ON pg.id = d.id_pergunta
            )
            INSERT INTO public.respostas (user_expandido_id, id_usuario, id_pergunta, id_turma, resposta, arquivo_original, tipo_resposta, criado_em)
            SELECT user_expandido_id, id_usuario, id_pergunta, NULL, resposta, arquivo_original, tipo_resposta, NOW() FROM com_tipo
            ON CONFLICT (user_expandido_id, id_pergunta) WHERE id_turma IS NULL
            DO UPDATE SET resposta = EXCLUDED.resposta, arquivo_original = EXCLUDED.arquivo_original, tipo_resposta = EXCLUDED.tipo_resposta, atualizado_em = NOW(), id_usuario = EXCLUDED.id_usuario;
        END IF;

        RETURN jsonb_build_object('sucesso', true, 'mensagem', 'Respostas salvas com sucesso.');
    EXCEPTION WHEN OTHERS THEN
        RETURN jsonb_build_object('sucesso', false, 'mensagem', 'Erro ao salvar: ' || SQLERRM);
    END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_status_reservas_grupo(p_id_produto uuid, p_id_usuario uuid, p_data_reserva timestamp with time zone, p_status_pipeline text DEFAULT NULL::text, p_status_compulsorio text DEFAULT NULL::text, p_data_retirada timestamp with time zone DEFAULT NULL::timestamp with time zone, p_data_devolvido timestamp with time zone DEFAULT NULL::timestamp with time zone)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_novo_status text;
  v_count integer;
BEGIN

  ------------------------------------------------------------------
  -- 🔸 VALIDAÇÕES DE DATAS PARA EVITAR ERROS DE NEGÓCIO
  ------------------------------------------------------------------

  -- Se o status for virar RETIRADO → precisamos de p_data_retirada
  IF p_status_compulsorio = 'retirado' AND p_data_retirada IS NULL THEN
      RAISE EXCEPTION 'Para mudar para "retirado", envie p_data_retirada';
  END IF;

  IF p_status_pipeline = 'reservado' AND p_data_retirada IS NULL THEN
      RAISE EXCEPTION 'Para mudar para "retirado", envie p_data_retirada';
  END IF;

  -- Se o status for virar DEVOLVIDO → precisamos de p_data_devolvido
  IF p_status_compulsorio = 'devolvido' AND p_data_devolvido IS NULL THEN
      RAISE EXCEPTION 'Para mudar para "devolvido", envie p_data_devolvido';
  END IF;

  IF p_status_pipeline = 'retirado' AND p_data_devolvido IS NULL THEN
      RAISE EXCEPTION 'Para mudar para "devolvido", envie p_data_devolvido';
  END IF;



  ------------------------------------------------------------------
  -- 1) STATUS COMPULSÓRIO (sem pipeline)
  ------------------------------------------------------------------
  IF p_status_compulsorio IS NOT NULL THEN

    UPDATE produto_reservas
    SET 
      status = p_status_compulsorio::status_reserva,

      -- Se virar retirado → grava data_retirada
      data_retirada =
        CASE WHEN p_status_compulsorio = 'retirado'
             THEN p_data_retirada
             ELSE data_retirada END,

      -- Se virar devolvido → grava data_devolvido
      data_devolvido =
        CASE WHEN p_status_compulsorio = 'devolvido'
             THEN p_data_devolvido
             ELSE data_devolvido END,

      updated_at = now()

    WHERE
      id_produto   = p_id_produto AND
      id_usuario   = p_id_usuario AND
      data_reserva = p_data_reserva;

    GET DIAGNOSTICS v_count = ROW_COUNT;

    RETURN json_build_object(
      'modo', 'compulsorio',
      'novo_status', p_status_compulsorio,
      'itens_atualizados', v_count
    );
  END IF;



  ------------------------------------------------------------------
  -- 2) PIPELINE (reservado → retirado → devolvido)
  ------------------------------------------------------------------
  IF p_status_pipeline IS NOT NULL THEN

    IF p_status_pipeline NOT IN ('reservado','retirado') THEN
      RAISE EXCEPTION 'Pipeline só aceita "reservado" ou "retirado"';
    END IF;

    v_novo_status := CASE p_status_pipeline
      WHEN 'reservado' THEN 'retirado'
      WHEN 'retirado'  THEN 'devolvido'
    END;

    UPDATE produto_reservas
    SET
      status = v_novo_status::status_reserva,

      -- se virar retirado → grava data_retirada enviada
      data_retirada =
        CASE WHEN v_novo_status = 'retirado'
             THEN p_data_retirada
             ELSE data_retirada END,

      -- se virar devolvido → grava data_devolvido enviada
      data_devolvido =
        CASE WHEN v_novo_status = 'devolvido'
             THEN p_data_devolvido
             ELSE data_devolvido END,

      updated_at = now()

    WHERE
      id_produto   = p_id_produto AND
      id_usuario   = p_id_usuario AND
      data_reserva = p_data_reserva AND
      status       = p_status_pipeline::status_reserva;

    GET DIAGNOSTICS v_count = ROW_COUNT;

    RETURN json_build_object(
      'modo', 'pipeline',
      'status_antigo', p_status_pipeline,
      'status_novo', v_novo_status,
      'itens_atualizados', v_count
    );
  END IF;


  ------------------------------------------------------------------
  -- 3) Sem status enviado → erro
  ------------------------------------------------------------------
  RAISE EXCEPTION 'Envie p_status_pipeline OU p_status_compulsorio';

END;
$function$
;

CREATE OR REPLACE FUNCTION public.stg_matriculas_set_flags()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_dummy int;
begin
  -- Verifica se existe user_expandido com esse e-mail
  select 1 into v_dummy
  from public.user_expandido ue
  where ue.email = new.email_aluno
  limit 1;

  new.email_existe_user_expandido := found;

  -- Verifica se existe turma com esse código
  select 1 into v_dummy
  from public.turmas t
  where t.cod_turma = new.codigo_turma
  limit 1;

  new.existe_em_turmas := found;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.total_estoque_ativos()
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  total integer;
begin
  select count(*) into total 
  from public.produto_estoque
  where status_item != 'descartado';

  return total;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.total_estoque_manutencao()
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  total integer;
begin
  select count(*) into total 
  from public.produto_estoque
  where status_item = 'manutenção';

  return total;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.total_estoque_reservado()
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  total integer;
begin
  select count(*) into total 
  from public.produto_estoque
  where status_item = 'reservado';

  return total;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.total_produtos()
 RETURNS integer
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  total integer;
begin
  select count(*) into total from public.produtos;
  return total;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_atualiza_imagem_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  -- 1️⃣ Só age se for a pergunta certa
  if new.id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid then
    
    -- 2️⃣ Só atualiza se imagem_user estiver vazia
    update public.user_expandido
    set imagem_user = new.resposta
    where 
      id = new.user_expandido_id
      and (imagem_user is null or trim(imagem_user) = '');
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_diario_maintain_consistency()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_matricula_aluno uuid;
    v_matricula_turma uuid;
    v_found_matricula_id uuid;
BEGIN
    -- Case 1: id_matricula is provided (Source of Truth)
    IF NEW.id_matricula IS NOT NULL THEN
        SELECT id_aluno, id_turma INTO v_matricula_aluno, v_matricula_turma
        FROM public.matriculas
        WHERE id = NEW.id_matricula;

        IF FOUND THEN
            -- Sync legacy columns from the matricula
            NEW.id_aluno := v_matricula_aluno;
            NEW.id_turma := v_matricula_turma; -- Reflects the CURRENT class of the matricula
        END IF;

    -- Case 2: id_matricula is NULL (Legacy Fallback)
    ELSE
        -- Try to find a matching matricula based on student
        -- Priority: Match Student AND Class (Perfect legacy match)
        SELECT id INTO v_found_matricula_id
        FROM public.matriculas
        WHERE id_aluno = NEW.id_aluno
        AND id_turma = NEW.id_turma
        LIMIT 1;

        -- If not found, try matching just the student (Handling transfers?)
        -- In a transfer, NEW.id_turma (legacy input) might be the OLD class.
        -- We want the matricula that owns this student.
        IF v_found_matricula_id IS NULL THEN
             SELECT id INTO v_found_matricula_id
             FROM public.matriculas
             WHERE id_aluno = NEW.id_aluno
             ORDER BY criado_em DESC
             LIMIT 1;
        END IF;

        IF v_found_matricula_id IS NOT NULL THEN
            NEW.id_matricula := v_found_matricula_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_diario_sync()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
begin
  -- Se for INSERT, sempre cria controle
  if TG_OP = 'INSERT' then
    insert into public.diario_controle_sync (id_diario, status)
    values (new.id, 'pendente');
    return new;
  end if;

  -- Se for UPDATE, só reage se mudaram p1..p4
  if TG_OP = 'UPDATE' then
    if (new.p1 is distinct from old.p1)
       or (new.p2 is distinct from old.p2)
       or (new.p3 is distinct from old.p3)
       or (new.p4 is distinct from old.p4) then

       -- antes de inserir novo, marca pendentes anteriores como ignorados
       update public.diario_controle_sync
          set status = 'ignorado'
        where id_diario = new.id
          and status = 'pendente';

       insert into public.diario_controle_sync (id_diario, status)
       values (new.id, 'pendente');
    end if;
  end if;

  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_estoque_after_delete()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Diminui quantidade total
  UPDATE produtos
  SET quantidade = quantidade - 1,
      disponiveis = GREATEST(disponiveis - 1, 0)
  WHERE id = OLD.id_produto;

  RETURN OLD;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_estoque_after_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Aumenta quantidade total
  UPDATE produtos
  SET quantidade = quantidade + 1,
      disponiveis = disponiveis + 1   -- novo item sempre começa disponível
  WHERE id = NEW.id_produto;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_processos_set_modificado()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Atualiza timestamp com timezone SP
  NEW.modificado_em := (now() AT TIME ZONE 'America/Sao_Paulo');

  -- Tenta capturar o usuário se vier via JWT
  BEGIN
    NEW.modificado_por := auth.uid();
  EXCEPTION WHEN OTHERS THEN
    NEW.modificado_por := NULL;
  END;

  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_reservas_status()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_produto uuid;
  was_active boolean;
  is_active boolean;
BEGIN
  -- Produto do item
  v_produto := COALESCE(NEW.id_produto, OLD.id_produto);

  -- status ANTES (no caso de UPDATE/DELETE)
  was_active :=
    OLD.status IN ('reservado','retirado','atrasado');

  -- status DEPOIS (no caso de INSERT/UPDATE)
  is_active :=
    NEW.status IN ('reservado','retirado','atrasado');

  -- Caso INSERT
  IF TG_OP = 'INSERT' THEN
    IF is_active THEN
      UPDATE produtos
      SET disponiveis = GREATEST(disponiveis - 1, 0)
      WHERE id = v_produto;
    END IF;
    RETURN NEW;
  END IF;

  -- Caso DELETE
  IF TG_OP = 'DELETE' THEN
    IF was_active THEN
      UPDATE produtos
      SET disponiveis = disponiveis + 1
      WHERE id = v_produto;
    END IF;
    RETURN OLD;
  END IF;

  -- Caso UPDATE
  IF TG_OP = 'UPDATE' THEN
    -- entrou em reserva ativa
    IF NOT was_active AND is_active THEN
      UPDATE produtos
      SET disponiveis = GREATEST(disponiveis - 1, 0)
      WHERE id = v_produto;
    END IF;

    -- saiu de reserva ativa
    IF was_active AND NOT is_active THEN
      UPDATE produtos
      SET disponiveis = disponiveis + 1
      WHERE id = v_produto;
    END IF;

    RETURN NEW;
  END IF;

  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_set_updated_at_curso_ficha()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.modificado_em := now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_vincular_papel()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  -- BYPASS: se não tem user_id, não tenta vincular papel
  if NEW.user_id is null then
    return NEW;
  end if;

  -- Garantia extra: só tenta se houver papel_id
  if NEW.papel_id is null then
    return NEW;
  end if;

  -- Só cria o vínculo se ainda não existir
  insert into public.papeis_user_auth (user_id, papel_id)
  select NEW.user_id, NEW.papel_id
  where not exists (
    select 1
    from public.papeis_user_auth
    where user_id = NEW.user_id
      and papel_id = NEW.papel_id
  );

  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trocar_turno_aluno(p_id_aluno uuid, p_id_matricula uuid, p_id_turma_nova uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_matricula RECORD;
    v_turma_nova RECORD;
    v_turma_user_old RECORD;
BEGIN
    -- 1. Verificar se a matrícula existe e pertence ao aluno
    SELECT * INTO v_matricula 
    FROM public.matriculas 
    WHERE id = p_id_matricula;

    IF v_matricula IS NULL THEN
        RETURN jsonb_build_object(
            'sucesso', false,
            'mensagem', 'Matrícula não encontrada.'
        );
    END IF;

    IF v_matricula.id_aluno <> p_id_aluno THEN
        RETURN jsonb_build_object(
            'sucesso', false,
            'mensagem', 'A matrícula não pertence ao aluno informado.'
        );
    END IF;

    -- (Opcional) Verificar se a turma nova existe
    SELECT * INTO v_turma_nova FROM public.turmas WHERE id = p_id_turma_nova;
    IF v_turma_nova IS NULL THEN
         RETURN jsonb_build_object(
            'sucesso', false,
            'mensagem', 'Turma de destino não encontrada.'
        );
    END IF;

    -- (Opcional) Poderia verificar se a turma nova é do mesmo semestre/curso da turma atual da matrícula
    -- Mas como o user só pediu para trocar, vamos confiar ou fazer check mínimo?
    -- Vamos fazer a troca direta conforme pedido: "deve trocar estes ids o que está lá pelo novo"

    -- 2. Atualizar a matrícula
    UPDATE public.matriculas
    SET 
        id_turma = p_id_turma_nova,
        atualizado_em = now()
    WHERE id = p_id_matricula;

    RETURN jsonb_build_object(
        'sucesso', true,
        'mensagem', 'Troca de turno realizada com sucesso.'
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'sucesso', false,
        'mensagem', 'Erro ao realizar a troca: ' || SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_status_envio_infos_doc_pedente(p_id_user_expandido uuid, p_array_turmas uuid[], p_tipo_campo text, p_valor text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
    v_result jsonb;
    v_qtd_atualizados int;
    v_sql text;
BEGIN
  ----------------------------------------------------------------
  -- 🧪 Validar campo
  ----------------------------------------------------------------
  IF p_tipo_campo NOT IN ('email', 'whatsapp') THEN
      RAISE EXCEPTION 'Tipo inválido: %, use email ou whatsapp', p_tipo_campo;
  END IF;

  ----------------------------------------------------------------
  -- 🧩 Construção dinâmica do SQL
  ----------------------------------------------------------------
  v_sql := format(
      'UPDATE public.processos
       SET envio_%I = $1,
           modificado_em = now(),
           modificado_por = $2
       WHERE user_expandido_id = $3
         AND turma_id = ANY($4)
       RETURNING 1;',
       p_tipo_campo
  );

  EXECUTE v_sql
  USING p_valor, p_id_user_expandido, p_id_user_expandido, p_array_turmas
  INTO v_qtd_atualizados;

  ----------------------------------------------------------------
  -- 📦 Retorno estruturado
  ----------------------------------------------------------------
  v_result := jsonb_build_object(
      'user_expandido', p_id_user_expandido,
      'turmas_atualizadas', p_array_turmas,
      'campo', p_tipo_campo,
      'novo_valor', p_valor,
      'qtd_processos_atualizados', COALESCE(v_qtd_atualizados, 0),
      'status', 'OK'
  );

  RETURN v_result;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_textos_listas_selecao_global(p_ano_semestre text, p_area text, p_data_prova date DEFAULT NULL::date, p_hora_redacao text DEFAULT NULL::text, p_hora_pratica text DEFAULT NULL::text, p_cabecalho_texto text DEFAULT NULL::text, p_data_etapas text DEFAULT NULL::text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    r RECORD;
    v_area tipo_area;
    v_count int := 0;
    v_sel_count int := 0;
BEGIN
    RAISE NOTICE '-------------------------------';
    RAISE NOTICE 'PARAMETROS RECEBIDOS:';
    RAISE NOTICE 'p_ano_semestre = "%"', p_ano_semestre;
    RAISE NOTICE 'p_area = "%"', p_area;
    RAISE NOTICE 'p_data_etapas = "%"', p_data_etapas;

    -- cast explícito
    BEGIN
        v_area := p_area::tipo_area;
        RAISE NOTICE 'v_area (enum) = "%"', v_area;
    EXCEPTION WHEN others THEN
        RAISE NOTICE 'ERRO AO CONVERTER AREA PARA ENUM!';
        RAISE EXCEPTION '%', SQLERRM;
    END;

    RAISE NOTICE 'INICIANDO SELECT DE IDs...';

    ------------------------------------------------------------------
    -- Teste: contar quantas linhas achou
    ------------------------------------------------------------------
    SELECT COUNT(*)
    INTO v_sel_count
    FROM textos_listas_selecao
    WHERE ano_semestre = p_ano_semestre
      AND area = v_area;

    RAISE NOTICE 'SELECT encontrou % linha(s).', v_sel_count;

    ------------------------------------------------------------------
    -- Loop
    ------------------------------------------------------------------
    FOR r IN 
        SELECT id
        FROM textos_listas_selecao
        WHERE ano_semestre = p_ano_semestre
          AND area = v_area
    LOOP
        RAISE NOTICE 'Atualizando ID: %', r.id;

        UPDATE textos_listas_selecao
        SET
            data_prova      = COALESCE(p_data_prova, data_prova),
            hora_redacao    = COALESCE(p_hora_redacao, hora_redacao),
            hora_pratica    = COALESCE(p_hora_pratica, hora_pratica),
            cabecalho_texto = COALESCE(p_cabecalho_texto, cabecalho_texto),
            data_etapas     = COALESCE(p_data_etapas, data_etapas)
        WHERE id = r.id;

        v_count := v_count + 1;
    END LOOP;

    RAISE NOTICE 'TOTAL ATUALIZADOS: %', v_count;
    RAISE NOTICE '-------------------------------';

    RETURN jsonb_build_object(
        'modo', 'global_debug',
        'ano_semestre', p_ano_semestre,
        'area', v_area,
        'selecionados', v_sel_count,
        'atualizados', v_count
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_calendario_turma(p_id_turma uuid, p_resultado jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_existe boolean;
  v_eventos jsonb;
  v_qtd int := 0;

  v_ajuste text;
  v_info jsonb;
begin
  -- 0) valida a turma
  select exists(select 1 from public.turmas where id = p_id_turma)
  into v_existe;

  if not v_existe then
    return jsonb_build_object('success', false, 'mensagem', 'Turma não encontrada.');
  end if;

  -- 1) extrai eventos do payload
  v_eventos := coalesce(p_resultado->'eventos', '[]'::jsonb);
  if jsonb_typeof(v_eventos) <> 'array' then
    return jsonb_build_object('success', false, 'mensagem', 'Payload inválido: "eventos" deve ser array.');
  end if;

  -- 2) limpa calendário anterior da turma (comportamento "substituir")
  delete from public.turmas_calendario
  where id_turma = p_id_turma;

  -- 3) insere os novos eventos
  insert into public.turmas_calendario (
    id_turma, start, "end", title, content, color
    -- "data" será preenchido pela trigger fn_turmas_calendario_set_data(), se você criou ela
  )
  select
    p_id_turma,
    (e->>'start')::timestamptz,
    (e->>'end')::timestamptz,
    coalesce(e->>'title', ''),
    -- guarda um "resumo" no content; se preferir, dá pra trocar a coluna para jsonb no schema
    coalesce(e->'data'->>'tipo', null),
    e->>'color'
  from jsonb_array_elements(v_eventos) as e;

  get diagnostics v_qtd = row_count;

  -- 4) log e info para a tabela turmas
  v_ajuste := coalesce(p_resultado->>'ajuste', ''); -- ex.: "Gerados 108 encontros (95 regulares + 13 extras)."
  v_info := jsonb_build_object(
    'encontros_extras',     coalesce((p_resultado->>'encontros_extras')::int, 0),
    'encontros_totais',     coalesce((p_resultado->>'encontros_totais')::int, 0),
    'encontros_previstos',  coalesce((p_resultado->>'encontros_previstos')::int, 0),
    'encontros_regulares',  coalesce((p_resultado->>'encontros_regulares')::int, 0)
  );

  update public.turmas
  set
    possui_calendario = true,
    log_calendario    = v_ajuste,
    info_calendario   = v_info
  where id = p_id_turma;

  -- 5) retorno amigável
  return jsonb_build_object(
    'success',       true,
    'id_turma',      p_id_turma,
    'qtd_eventos',   v_qtd,
    'ajuste',        v_ajuste,
    'info_calendario', v_info
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_curso(p_dados jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_curso jsonb := p_dados->'dados_curso';
  v_encontros jsonb := p_dados->'encontros_curso';
  v_id_curso uuid;
  v_operacao text;
  v_padrao boolean;
begin
  -- 1️⃣ Define operação
  if v_curso->>'criar_editar' = 'criar' then
    v_id_curso := gen_random_uuid();
    v_operacao := 'inserido';
  else
    v_id_curso := (v_curso->>'id')::uuid;
    v_operacao := 'atualizado';
  end if;

  -- 2️⃣ Guarda o valor de padrao_encontros (pra decidir depois)
  v_padrao := coalesce((v_curso->>'padrao_encontros')::boolean, true);

  -- 3️⃣ UPSERT em curso
  insert into public.curso (
    id, nome_curso, area, modalidade, cod_curso, descricao,
    padrao_encontros, qtd_modulos, qtd_aulas_modulo, qtd_periodos,
    qtd_minutos_periodo, qtd_minutos_aula, qtd_minutos_modulo,
    qtd_minutos_total, status, criado_em, modificado_em
  )
  values (
    v_id_curso,
    v_curso->>'nome_curso',
    (v_curso->>'area')::public.tipo_area,
    (v_curso->>'modalidade')::public.modalidade_curso,
    nullif(v_curso->>'cod_curso',''),
    nullif(v_curso->>'descricao',''),
    v_padrao,
    (v_curso->>'modulos')::int,
    (v_curso->>'encontros_modulo')::int,
    (v_curso->>'periodos')::int,
    ((v_curso->'c_carga_horaria_periodo'->>2)::int),
    ((v_curso->'c_carga_horaria_encontro'->>2)::int),
    ((v_curso->'c_carga_horaria_modulo'->>2)::int),
    ((v_curso->'carga_horaria_total'->>2)::int),
    true,
    now(),
    now()
  )
  on conflict (id)
  do update set
    nome_curso = excluded.nome_curso,
    area = excluded.area,
    modalidade = excluded.modalidade,
    cod_curso = excluded.cod_curso,
    descricao = excluded.descricao,
    padrao_encontros = excluded.padrao_encontros,
    qtd_modulos = excluded.qtd_modulos,
    qtd_aulas_modulo = excluded.qtd_aulas_modulo,
    qtd_periodos = excluded.qtd_periodos,
    qtd_minutos_periodo = excluded.qtd_minutos_periodo,
    qtd_minutos_aula = excluded.qtd_minutos_aula,
    qtd_minutos_modulo = excluded.qtd_minutos_modulo,
    qtd_minutos_total = excluded.qtd_minutos_total,
    modificado_em = now();

  -- 4️⃣ Só atualiza encontros se padrao_encontros = false
  if (not v_padrao) and jsonb_typeof(v_encontros) = 'array' then
    delete from public.curso_encontros where id_curso = v_id_curso;

    insert into public.curso_encontros (
      id, id_curso, numero_encontro, qtd_periodos, duracao_minutos, observacao
    )
    select
      gen_random_uuid(),
      v_id_curso,
      (e->>'numero_encontro')::int,
      coalesce((e->>'qtd_periodos')::int, 1),
      (e->>'duracao_somente_minutos')::int,
      e->>'observacao'
    from jsonb_array_elements(v_encontros) e;
  end if;

  return jsonb_build_object(
    'status', 'ok',
    'operacao', v_operacao,
    'id_curso', v_id_curso,
    'padrao_encontros', v_padrao,
    'qtd_encontros_inseridos', 
      case when v_padrao then 0 else jsonb_array_length(v_encontros) end
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_produto(p_id uuid DEFAULT NULL::uuid, p_nome text DEFAULT NULL::text, p_treshold integer DEFAULT NULL::integer, p_codigo_barras text DEFAULT NULL::text, p_observacoes text DEFAULT NULL::text, p_id_tipo_produto uuid DEFAULT NULL::uuid, p_quantidade integer DEFAULT NULL::integer, p_id_unidade uuid DEFAULT NULL::uuid, p_valor_inicial integer DEFAULT NULL::integer, p_imagem_produto text DEFAULT NULL::text, p_mostrar_mais boolean DEFAULT NULL::boolean, p_id_categoria_produto uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_id uuid;
    v_action text;
    v_qtd_inserir integer;
    v_valor_init integer;
BEGIN
    -- Definição do valor inicial padrão caso não venha informado
    v_valor_init := COALESCE(p_valor_inicial, 0);

    -- ========================================================================
    -- INSERT (Se p_id for NULL)
    -- ========================================================================
    IF p_id IS NULL THEN
        v_action := 'created';
        
        -- 1. Inserir Produto
        INSERT INTO public.produtos (
            nome,
            treshold,
            codigo_barras,
            observacoes,
            id_tipo_produto,
            id_unidade,
            valor_inicial,
            imagem_produto,
            mostrar_mais,
            id_categoria_produto,
            -- A coluna quantidade será ignorada/descontinuada, 
            -- mas se existir not-null constraint, usamos 0 ou a qtd passada.
            -- Vamos passar 0 pois o estoque real estará na tabela produto_estoque
            quantidade
        ) VALUES (
            p_nome,
            COALESCE(p_treshold, 0),
            p_codigo_barras,
            p_observacoes,
            p_id_tipo_produto,
            p_id_unidade,
            v_valor_init,
            p_imagem_produto,
            COALESCE(p_mostrar_mais, false),
            p_id_categoria_produto,
            0 
        )
        RETURNING id INTO v_id;

        -- 2. Gerar Estoque Inicial
        -- Se p_quantidade for informado e maior que 0, cria N registros em produto_estoque
        v_qtd_inserir := COALESCE(p_quantidade, 0);

        IF v_qtd_inserir > 0 THEN
            INSERT INTO public.produto_estoque (
                id_produto,
                valor_inicial,
                valor_atual,
                status_item,
                status_disponibilidade
            )
            SELECT 
                v_id,
                v_valor_init,
                v_valor_init,
                'disponível',
                true
            FROM generate_series(1, v_qtd_inserir);
        END IF;

    -- ========================================================================
    -- UPDATE (Se p_id for informado)
    -- ========================================================================
    ELSE
        v_action := 'updated';
        v_id := p_id;

        UPDATE public.produtos
        SET
            nome = COALESCE(p_nome, nome),
            treshold = COALESCE(p_treshold, treshold),
            codigo_barras = COALESCE(p_codigo_barras, codigo_barras),
            observacoes = COALESCE(p_observacoes, observacoes),
            id_tipo_produto = COALESCE(p_id_tipo_produto, id_tipo_produto),
            id_unidade = COALESCE(p_id_unidade, id_unidade),
            valor_inicial = COALESCE(p_valor_inicial, valor_inicial),
            imagem_produto = COALESCE(p_imagem_produto, imagem_produto),
            mostrar_mais = COALESCE(p_mostrar_mais, mostrar_mais),
            id_categoria_produto = COALESCE(p_id_categoria_produto, id_categoria_produto),
            atualizado_em = now()
        WHERE id = v_id;

        -- Nota: No UPDATE não mexemos no estoque com base em p_quantidade.
        -- Ajustes de quantidade devem ser feitos via funções específicas de inventário.
    END IF;

    RETURN jsonb_build_object(
        'ok', true,
        'action', v_action,
        'id', v_id
    );

EXCEPTION WHEN OTHERS THEN
    RETURN jsonb_build_object(
        'ok', false,
        'message', SQLERRM
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_professor_turma_atribuicao(p_user_id uuid, p_turmas uuid[])
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_auth_id uuid;
    v_executor_id uuid;
    v_turma_id uuid;
    v_inserted_count int := 0;
    v_updated_count int := 0;
BEGIN
    -- 1. Obter o auth_id do professor (para redundância/RLS)
    SELECT user_id INTO v_auth_id
    FROM public.user_expandido
    WHERE id = p_user_id;

    IF v_auth_id IS NULL THEN
        RETURN jsonb_build_object(
            'status', 'erro',
            'mensagem', 'Professor não encontrado em user_expandido.'
        );
    END IF;

    -- 2. Obter o ID do executor (quem está rodando a função) para auditoria (criado_por/modificado_por)
    SELECT id INTO v_executor_id
    FROM public.user_expandido
    WHERE user_id = auth.uid();
    
    -- Se quem executa não tem user_expandido (ex: service role ou erro), v_executor_id será NULL.
    -- Opcional: tratar esse caso ou deixar NULL.

    -- 3. Loop pelas turmas
    IF p_turmas IS NOT NULL THEN
        FOREACH v_turma_id IN ARRAY p_turmas
        LOOP
            -- Tenta inserir. Se houver conflito (constraint única), faz update (ou nada).
            -- Como a constraint unique (user_id, id_turmas) foi criada, podemos usar ON CONFLICT.
            -- Caso a constraint não exista no momento da execução, esse codigo falhará se houver duplicidade.
            -- Mas o passo a passo indicou a criação da constraint.
            
            INSERT INTO public.professor_turma_atribuicao (
                user_id,
                id_turmas,
                status,
                avaliador,
                criado_por,
                criado_em,
                auth_id
            ) VALUES (
                p_user_id,
                v_turma_id,
                true,  -- Default status
                false, -- Default avaliador
                v_executor_id,
                timezone('utc'::text, now()),
                v_auth_id
            )
            ON CONFLICT (user_id, id_turmas) 
            DO UPDATE SET
                modificado_por = v_executor_id,
                modificado_em = timezone('utc'::text, now());
                -- Não atualizamos status ou avaliador no conflito para preservar configs manuais,
                -- a menos que seja requisito resetar. Assumo preservar.
            
            IF FOUND THEN
                 -- FOUND é setado true se insert ou update ocorreu com sucesso
                 -- Como não temos como distinguir facilmente insert de update no count simples sem xmax,
                 -- vamos apenas contar como processado.
                 v_inserted_count := v_inserted_count + 1;
            END IF;
            
        END LOOP;
    END IF;

    RETURN jsonb_build_object(
        'status', 'sucesso',
        'mensagem', 'Atribuições processadas.',
        'total_processado', v_inserted_count
    );

EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object('status', 'erro', 'mensagem', SQLERRM);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_rematricula(p_id_user_expandido uuid, p_id_turma_atual uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_turma_atual RECORD;
    v_proximo_semestre TEXT;
    v_ano_atual INT;
    v_id_proxima_turma UUID;
    v_id_matricula UUID;
    v_existe_matricula BOOLEAN;
    v_nome_proxima_turma TEXT;
    v_turno_proxima_turma TEXT;
    v_nome_composto_proxima_turma TEXT;
    v_existe_matricula_destino BOOLEAN;
BEGIN
    -- 1. Verificar a matrícula deste usuário na turma informada
    SELECT EXISTS (
        SELECT 1 
        FROM public.matriculas 
        WHERE id_aluno = p_id_user_expandido 
          AND id_turma = p_id_turma_atual
    ) INTO v_existe_matricula;

    IF NOT v_existe_matricula THEN
        RETURN jsonb_build_object(
            'success', false, 
            'message', 'Aluno não possui matrícula ativa na turma informada.'
        );
    END IF;

    -- 2. Obter dados da turma atual
    SELECT * INTO v_turma_atual FROM public.turmas WHERE id = p_id_turma_atual;
    
    IF v_turma_atual IS NULL THEN
        RETURN jsonb_build_object(
            'success', false, 
            'message', 'Turma atual não encontrada.'
        );
    END IF;

    -- 3. Calcular o próximo semestre
    -- Lógica: Se termina em 'Is', muda para 'IIs'. Se termina em 'IIs', incrementa ano e muda para 'Is'.
    IF v_turma_atual.ano_semestre LIKE '%Is' AND v_turma_atual.ano_semestre NOT LIKE '%IIs' THEN
        v_proximo_semestre := REPLACE(v_turma_atual.ano_semestre, 'Is', 'IIs');
    ELSIF v_turma_atual.ano_semestre LIKE '%IIs' THEN
        -- Extrai a parte numérica do início
        v_ano_atual := (substring(v_turma_atual.ano_semestre FROM '^(\d+)')::INT);
        v_proximo_semestre := (v_ano_atual + 1)::TEXT || 'Is';
    ELSE
         RETURN jsonb_build_object(
            'success', false, 
            'message', 'Formato de semestre desconhecido: ' || COALESCE(v_turma_atual.ano_semestre, 'null')
        );
    END IF;

    -- 4. Achar a turma do mesmo curso/turno mas do semestre seguinte
    SELECT id, cod_turma, turno, cod_turma || ' - ' || turno AS nome_composto
    INTO v_id_proxima_turma, v_nome_proxima_turma, v_turno_proxima_turma, v_nome_composto_proxima_turma
    FROM public.turmas
    WHERE id_curso = v_turma_atual.id_curso
      AND turno = v_turma_atual.turno
      AND ano_semestre = v_proximo_semestre
    LIMIT 1;

    IF v_id_proxima_turma IS NULL THEN
        RETURN jsonb_build_object(
            'success', false, 
            'message', 'Nenhuma turma encontrada para o semestre seguinte: ' || v_proximo_semestre,
            'proximo_semestre', v_proximo_semestre
        );
    END IF;

    -- 5. Verificar se JÁ existe matrícula na turma de destino
    SELECT EXISTS (
        SELECT 1 
        FROM public.matriculas 
        WHERE id_aluno = p_id_user_expandido 
          AND id_turma = v_id_proxima_turma
    ) INTO v_existe_matricula_destino;

    IF v_existe_matricula_destino THEN
        -- Retorna mensagem avisando que já existe
        RETURN jsonb_build_object(
            'success', true, 
             -- O usuário pediu: "Já foi realizada uma matrícula para este estudante na turma ..."
            'message', 'Já foi realizada uma matrícula para este estudante na turma ' || COALESCE(v_nome_composto_proxima_turma, 'Sem Nome'),
            'id_matricula', (SELECT id FROM public.matriculas WHERE id_aluno = p_id_user_expandido AND id_turma = v_id_proxima_turma LIMIT 1),
            'proxima_turma_id', v_id_proxima_turma,
            'proximo_semestre', v_proximo_semestre,
            'nome_turma', v_nome_proxima_turma,
            'turno', v_turno_proxima_turma,
            'nome_composto', v_nome_composto_proxima_turma
        );
    ELSE
        -- 6. Criar a matrícula para este aluno na turma SEGUINTE (sem marcar rematricula=true nela)
        INSERT INTO public.matriculas (id_aluno, id_turma, status)
        VALUES (p_id_user_expandido, v_id_proxima_turma, 'Ativa')
        RETURNING id INTO v_id_matricula;

        -- 7. Marcar a matrícula ATUAL (origem) como re-matriculada
        UPDATE public.matriculas 
        SET rematricula = true,
            atualizado_em = now()
        WHERE id_aluno = p_id_user_expandido 
          AND id_turma = p_id_turma_atual;

        RETURN jsonb_build_object(
            'success', true, 
            'message', 'Rematricula realizada com sucesso na turma: ' || COALESCE(v_nome_composto_proxima_turma, 'Sem Nome'),
            'id_matricula', v_id_matricula, 
            'proxima_turma_id', v_id_proxima_turma,
            'proximo_semestre', v_proximo_semestre,
            'nome_turma', v_nome_proxima_turma,
            'turno', v_turno_proxima_turma,
            'nome_composto', v_nome_composto_proxima_turma
        );
    END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_resposta_avaliacao(p_id_user uuid, p_id_pergunta uuid, p_id_processo uuid, p_resposta_texto text, p_criado_por uuid DEFAULT NULL::uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_row public.respostas_perguntas_avaliacao_processos;
  v_tipo_pergunta text;
  v_soma_notas numeric;
BEGIN

  --------------------------------------------------------------------
  -- ⚠ GARANTIA: id_processo não pode ser nulo
  --------------------------------------------------------------------
  IF p_id_processo IS NULL THEN
    RAISE EXCEPTION 'id_processo não pode ser NULL no upsert_resposta_avaliacao_v2';
  END IF;

  --------------------------------------------------------------------
  -- UPSERT REAL com ON CONFLICT
  -- Baseado na chave lógica: (id_user, id_pergunta_processo, id_processo)
  --------------------------------------------------------------------
  INSERT INTO public.respostas_perguntas_avaliacao_processos (
    id_user,
    id_pergunta_processo,
    id_processo,
    resposta_texto,
    criado_por
  )
  VALUES (
    p_id_user,
    p_id_pergunta,
    p_id_processo,
    p_resposta_texto,
    p_criado_por
  )
  ON CONFLICT (id_user, id_pergunta_processo, id_processo)
  DO UPDATE SET
      resposta_texto = EXCLUDED.resposta_texto,
      criado_por     = EXCLUDED.criado_por,
      criado_em      = now()   -- opcional: marcar atualização
  RETURNING * INTO v_row;

  --------------------------------------------------------------------
  -- LÓGICA DE SOMA DE NOTAS
  -- Verifica o tipo da pergunta atual
  --------------------------------------------------------------------
  SELECT tipo INTO v_tipo_pergunta
  FROM public.perguntas_avaliacao_processos
  WHERE id = p_id_pergunta;

  -- Se for do tipo 'numero', calcula a soma total e atualiza o processo
  IF v_tipo_pergunta = 'numero' THEN
    
    -- Calcula a soma de TODAS as respostas do tipo 'numero' para este processo
    SELECT COALESCE(SUM(r.resposta_texto::numeric), 0)
    INTO v_soma_notas
    FROM public.respostas_perguntas_avaliacao_processos r
    JOIN public.perguntas_avaliacao_processos p ON r.id_pergunta_processo = p.id
    WHERE r.id_processo = p_id_processo
      AND p.tipo = 'numero';

    -- Atualiza o processo com a soma * 100
    UPDATE public.processos
    SET nota_total_processo = (v_soma_notas * 100)::int8
    WHERE id = p_id_processo;

  END IF;

  --------------------------------------------------------------------
  -- Retorno em JSON
  --------------------------------------------------------------------
  RETURN jsonb_build_object(
    'id',                   v_row.id,
    'id_user',              v_row.id_user,
    'id_pergunta',          v_row.id_pergunta_processo,
    'id_processo',          v_row.id_processo,
    'resposta',             v_row.resposta_texto,
    'criado_por',           v_row.criado_por,
    'criado_em',            v_row.criado_em,
    'nota_total_processo',  (SELECT nota_total_processo FROM public.processos WHERE id = p_id_processo) -- Opcional: retornar o novo total
  );

END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_status_matricula(p_id_matricula uuid, p_status text)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result jsonb;
    v_new_status status_matricula;
BEGIN
    -- Tenta converter o status recebido para o enum
    BEGIN
        v_new_status := p_status::status_matricula;
    EXCEPTION WHEN OTHERS THEN
        RAISE EXCEPTION 'Status inválido: %', p_status;
    END;

    UPDATE public.matriculas
    SET 
        status = v_new_status,
        atualizado_em = now()
    WHERE id = p_id_matricula
    RETURNING jsonb_build_object(
        'id', id,
        'status', status,
        'atualizado_em', atualizado_em
    ) INTO v_result;

    IF v_result IS NULL THEN
        RAISE EXCEPTION 'Matrícula não encontrada: %', p_id_matricula;
    END IF;

    RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_textos_listas_selecao_array(p_itens jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    r jsonb;
    v_id_turma uuid;
    v_exists boolean;
    v_updates int := 0;
    v_inserts int := 0;
BEGIN
    ------------------------------------------------------------------
    -- Validar que recebemos realmente um array JSON
    ------------------------------------------------------------------
    IF p_itens IS NULL OR jsonb_typeof(p_itens) <> 'array' THEN
        RAISE EXCEPTION 'p_itens deve ser um array JSON';
    END IF;

    ------------------------------------------------------------------
    -- LOOP nos itens enviados
    ------------------------------------------------------------------
    FOR r IN SELECT * FROM jsonb_array_elements(p_itens)
    LOOP
        v_id_turma := (r->>'id_turma')::uuid;

        ------------------------------------------------------------------
        -- Verifica se já existe
        ------------------------------------------------------------------
        SELECT EXISTS(
            SELECT 1
            FROM textos_listas_selecao
            WHERE id_turma = v_id_turma
        )
        INTO v_exists;

        ------------------------------------------------------------------
        -- UPSERT
        ------------------------------------------------------------------
        IF v_exists THEN
            UPDATE textos_listas_selecao
            SET
                data_prova       = COALESCE((r->>'data_prova')::date, data_prova),
                hora_redacao     = COALESCE(r->>'hora_redacao', hora_redacao),
                hora_pratica     = COALESCE(r->>'hora_pratica', hora_pratica),
                cabecalho_texto  = COALESCE(r->>'cabecalho', cabecalho_texto),
                data_etapas      = COALESCE(r->>'data_etapas', data_etapas)
            WHERE id_turma = v_id_turma;

            v_updates := v_updates + 1;

        ELSE
            INSERT INTO textos_listas_selecao (
                id_turma,
                data_prova,
                hora_redacao,
                hora_pratica,
                cabecalho_texto,
                data_etapas
            )
            VALUES (
                v_id_turma,
                (r->>'data_prova')::date,
                r->>'hora_redacao',
                r->>'hora_pratica',
                r->>'cabecalho',
                r->>'data_etapas'
            );

            v_inserts := v_inserts + 1;
        END IF;

    END LOOP;

    RETURN jsonb_build_object(
        'modo', 'array_upsert',
        'inseridos', v_inserts,
        'atualizados', v_updates,
        'total_processados', v_inserts + v_updates
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_turma_admin(p_dados jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_id uuid := nullif(p_dados->>'id','')::uuid;
  v_id_curso uuid := (p_dados->>'id_curso')::uuid;
  v_turno text := trim(p_dados->>'turno');
  v_ano_semestre text := trim(p_dados->>'ano_semestre');

  v_nome_curso text;
  v_area_curso text;
  v_cod_curso text;
  v_cod_turma text;
  v_cod_modulo text;
  v_ano text;
  v_semestre text;

  v_dias_semana_arr text[] := '{}';
  v_dias_semana_txt text;

  v_link_video boolean := coalesce((p_dados->>'link_video')::boolean, false);
  v_operacao text;
  v_result jsonb;

  -- dados extra do curso (retorno)
  v_modalidade text; v_descricao text; v_status boolean;
  v_qtd_modulos int; v_qtd_aulas_modulo int; v_qtd_periodos int;
  v_qtd_minutos_periodo int; v_qtd_minutos_aula int; v_qtd_minutos_modulo int;
  v_qtd_minutos_total int; v_padrao_encontros boolean;
  v_criado_em timestamptz; v_modificado_em timestamptz;
  v_title_sharepoint_curso text; v_id_sharepoint_curso bigint;

  -- horários
  v_hora_ini text := nullif(trim(p_dados->>'hora_ini'),'');
  v_hora_fim text := nullif(trim(p_dados->>'hora_fim'),'');
BEGIN
  -- 1️⃣ Buscar dados do curso
  SELECT
    c.nome_curso, (c.area)::text, c.cod_curso,
    (c.modalidade)::text, c.descricao, c.status,
    c.qtd_modulos, c.qtd_aulas_modulo, c.qtd_periodos,
    c.qtd_minutos_periodo, c.qtd_minutos_aula, c.qtd_minutos_modulo,
    c.qtd_minutos_total, c.padrao_encontros,
    c.criado_em, c.modificado_em, c.title_sharepoint, c.id_sharepoint
  INTO
    v_nome_curso, v_area_curso, v_cod_curso,
    v_modalidade, v_descricao, v_status,
    v_qtd_modulos, v_qtd_aulas_modulo, v_qtd_periodos,
    v_qtd_minutos_periodo, v_qtd_minutos_aula, v_qtd_minutos_modulo,
    v_qtd_minutos_total, v_padrao_encontros,
    v_criado_em, v_modificado_em, v_title_sharepoint_curso, v_id_sharepoint_curso
  FROM public.curso c
  WHERE c.id = v_id_curso;

  IF v_nome_curso IS NULL THEN
    RAISE EXCEPTION 'Curso não encontrado para o id %', v_id_curso;
  END IF;

  -- 2️⃣ Ano/Semestre + códigos
  v_ano := '20' || left(v_ano_semestre, 2);
  v_semestre := regexp_replace(v_ano_semestre, '[0-9]', '', 'g');
  v_cod_turma  := v_cod_curso || '-' || v_ano_semestre || substring(v_turno from 1 for 1);
  v_cod_modulo := v_ano_semestre || substring(v_turno from 1 for 1) || '-' || v_cod_curso;

  -- 3️⃣ Dias da semana
  IF p_dados ? 'dias_semana' AND p_dados->'dias_semana' IS NOT NULL THEN
    IF jsonb_typeof(p_dados->'dias_semana') = 'array' THEN
      v_dias_semana_arr := ARRAY(
        SELECT upper(trim(x)) FROM jsonb_array_elements_text(p_dados->'dias_semana') AS x
        WHERE coalesce(trim(x),'') <> ''
      );
    ELSE
      v_dias_semana_arr := ARRAY(
        SELECT upper(trim(val)) FROM jsonb_each_text(p_dados->'dias_semana') AS kv(key,val)
        WHERE coalesce(trim(val),'') <> ''
      );
    END IF;
  END IF;
  v_dias_semana_txt := array_to_string(v_dias_semana_arr, ' | ');

  -- 4️⃣ Inserção ou atualização
  IF v_id IS NULL THEN
    v_id := gen_random_uuid();
    v_operacao := 'criada';
    INSERT INTO public.turmas (
      id, id_curso, nome_curso, area_curso, ano_semestre, ano, semestre, turno,
      cod_curso, cod_turma, cod_modulo,
      dt_ini_inscri, dt_fim_inscri, dt_ini_mat, dt_fim_mat,
      dt_ini_curso, dt_fim_curso,
      dt_ini_inscri_docente, dt_fim_inscri_docente,
      dias_semana, link_video, hora_ini, hora_fim
    )
    VALUES (
      v_id, v_id_curso, v_nome_curso, v_area_curso, v_ano_semestre, v_ano, v_semestre, v_turno,
      v_cod_curso, v_cod_turma, v_cod_modulo,
      (p_dados->>'dt_ini_inscri')::timestamptz, (p_dados->>'dt_fim_inscri')::timestamptz,
      (p_dados->>'dt_ini_mat')::timestamptz, (p_dados->>'dt_fim_mat')::timestamptz,
      (p_dados->>'dt_ini_curso')::timestamptz, (p_dados->>'dt_fim_curso')::timestamptz,
      (p_dados->>'dt_ini_inscri_docente')::timestamptz, (p_dados->>'dt_fim_inscri_docente')::timestamptz,
      v_dias_semana_txt, v_link_video, v_hora_ini, v_hora_fim
    );
  ELSE
    v_operacao := 'atualizada';
    UPDATE public.turmas
    SET id_curso = v_id_curso,
        nome_curso = v_nome_curso,
        area_curso = v_area_curso,
        ano_semestre = v_ano_semestre,
        ano = v_ano,
        semestre = v_semestre,
        turno = v_turno,
        cod_curso = v_cod_curso,
        cod_turma = v_cod_turma,
        cod_modulo = v_cod_modulo,
        dt_ini_inscri = (p_dados->>'dt_ini_inscri')::timestamptz,
        dt_fim_inscri = (p_dados->>'dt_fim_inscri')::timestamptz,
        dt_ini_mat = (p_dados->>'dt_ini_mat')::timestamptz,
        dt_fim_mat = (p_dados->>'dt_fim_mat')::timestamptz,
        dt_ini_curso = (p_dados->>'dt_ini_curso')::timestamptz,
        dt_fim_curso = (p_dados->>'dt_fim_curso')::timestamptz,
        dt_ini_inscri_docente = (p_dados->>'dt_ini_inscri_docente')::timestamptz,
        dt_fim_inscri_docente = (p_dados->>'dt_fim_inscri_docente')::timestamptz,
        dias_semana = v_dias_semana_txt,
        link_video = v_link_video,
        hora_ini = v_hora_ini,
        hora_fim = v_hora_fim
    WHERE id = v_id;
  END IF;

  -- 5️⃣ Reconstruir turmas_dias
  DELETE FROM public.turmas_dias WHERE id_turma = v_id;
  INSERT INTO public.turmas_dias (id_turma, dia_da_semana_num, dia_da_semana_text)
  SELECT v_id,
         CASE d
           WHEN 'SEG' THEN 1 WHEN 'TER' THEN 2 WHEN 'QUA' THEN 3
           WHEN 'QUI' THEN 4 WHEN 'SEX' THEN 5 WHEN 'SAB' THEN 6 WHEN 'DOM' THEN 7
         END AS dia_da_semana_num,
         d AS dia_da_semana_text
  FROM unnest(coalesce(v_dias_semana_arr, '{}')) AS d
  WHERE d IN ('SEG','TER','QUA','QUI','SEX','SAB','DOM');

  -- 6️⃣ Retorno completo da turma
  SELECT jsonb_build_object(
    'success', true,
    'acao', v_operacao,
    'turma', to_jsonb(t.*),
    'curso_dados_adicionais', jsonb_build_object(
      'modalidade', v_modalidade,
      'descricao', v_descricao,
      'status', v_status,
      'qtd_modulos', v_qtd_modulos,
      'qtd_aulas_modulo', v_qtd_aulas_modulo,
      'qtd_periodos', v_qtd_periodos,
      'qtd_minutos_periodo', v_qtd_minutos_periodo,
      'qtd_minutos_aula', v_qtd_minutos_aula,
      'qtd_minutos_modulo', v_qtd_minutos_modulo,
      'qtd_minutos_total', v_qtd_minutos_total,
      'padrao_encontros', v_padrao_encontros,
      'criado_em', v_criado_em,
      'modificado_em', v_modificado_em,
      'title_sharepoint_curso', v_title_sharepoint_curso,
      'id_sharepoint_curso', v_id_sharepoint_curso
    )
  )
  INTO v_result
  FROM public.turmas t
  WHERE t.id = v_id;

  RETURN v_result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.validar_acesso_matricula(p_id_processo uuid)
 RETURNS jsonb
 LANGUAGE sql
 SECURITY DEFINER
AS $function$

SELECT
  CASE 
    WHEN p.id IS NULL THEN
      jsonb_build_object('ok', false, 'motivo', 'processo_inexistente')

    WHEN p.user_id <> auth.uid() THEN
      jsonb_build_object('ok', false, 'motivo', 'processo_nao_e_do_usuario')

    WHEN p.status <> 'Aprovado' THEN
      jsonb_build_object('ok', false, 'motivo', 'status_nao_aprovado')

    WHEN t.dt_ini_mat IS NOT NULL AND now() < t.dt_ini_mat THEN
      jsonb_build_object('ok', false, 'motivo', 'antes_do_periodo')

    WHEN t.dt_fim_mat IS NOT NULL AND now() > (t.dt_fim_mat + INTERVAL '1 day') THEN
      jsonb_build_object('ok', false, 'motivo', 'apos_periodo')

    ELSE
      jsonb_build_object('ok', true)
  END AS resultado

FROM processos p
LEFT JOIN turmas t ON t.id = p.turma_id
WHERE p.id = p_id_processo;

$function$
;

CREATE OR REPLACE FUNCTION public.verifica_cpf_regular(user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
    v_cpf text;
    v_existe boolean := false;
begin
    -- Busca o CPF deste user_id
    select resposta into v_cpf
      from respostas
     where id_usuario = user_id
       and id_pergunta = '20467206-19d9-4bb9-8a54-e6625f101282'
     limit 1;

    if v_cpf is null then
        return false;
    end if;

    select exists (
        select 1
          from respostas r
          join processos p on p.user_id = r.id_usuario
          join turmas t on t.id = p.turma_id
         where r.id_pergunta = '20467206-19d9-4bb9-8a54-e6625f101282'
           and r.resposta = v_cpf
           and t.area_curso = 'Regulares'
           and p.created_at >= (now() - interval '90 days')
    ) into v_existe;

    return v_existe;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.verificar_aula_turma_por_data(p_id_turma uuid, p_data date)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_turma record;
  v_is_feriado boolean := false;
  v_is_extra boolean := false;
  v_dia_semana int;
  v_tem_dia_semana boolean := false;
  v_resultado text;
begin
  -- 1️⃣ valida turma
  select 
    id, dt_ini_curso::date as ini, dt_fim_curso::date as fim
  into v_turma
  from public.turmas
  where id = p_id_turma;

  if not found then
    return jsonb_build_object('success', false, 'mensagem', 'Turma não encontrada.');
  end if;

  -- 2️⃣ feriado
  select exists(
    select 1 from public.feriados f where f.data_feriado::date = p_data
  ) into v_is_feriado;

  if v_is_feriado then
    return jsonb_build_object(
      'success', true,
      'tem_aula', false,
      'motivo', 'FERIADO'
    );
  end if;

  -- 3️⃣ intervalo da turma
  if p_data < v_turma.ini or p_data > v_turma.fim then
    return jsonb_build_object(
      'success', true,
      'tem_aula', false,
      'motivo', 'Fora do período do curso'
    );
  end if;

  -- 4️⃣ dia extra
  select exists(
    select 1
    from public.turmas_dias_extra_calendario tec
    where tec.id_turma = p_id_turma
      and tec.data::date = p_data
  ) into v_is_extra;

  if v_is_extra then
    return jsonb_build_object(
      'success', true,
      'tem_aula', true,
      'motivo', 'Aula Extra'
    );
  end if;

  -- 5️⃣ dia regular
  v_dia_semana := extract(isodow from p_data)::int;

  select exists(
    select 1
    from public.turmas_dias td
    where td.id_turma = p_id_turma
      and td.dia_da_semana_num = v_dia_semana
  ) into v_tem_dia_semana;

  if v_tem_dia_semana then
    v_resultado := 'Dia Regular de Aula';
  else
    v_resultado := 'Não há aula';
  end if;

  return jsonb_build_object(
    'success', true,
    'tem_aula', v_tem_dia_semana,
    'motivo', v_resultado
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.verificar_calendario_turma(p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  v_possui boolean;
  v_log text;
  v_info jsonb;
  v_result jsonb;
begin
  select 
    possui_calendario, 
    coalesce(log_calendario, '') as log_calendario, 
    coalesce(info_calendario, '{}'::jsonb)
  into 
    v_possui, v_log, v_info
  from public.turmas
  where id = p_id_turma;

  if not found then
    return jsonb_build_object(
      'success', false,
      'mensagem', 'Turma não encontrada.'
    );
  end if;

  v_result := jsonb_build_object(
    'success', true,
    'id_turma', p_id_turma,
    'possui_calendario', coalesce(v_possui, false),
    'log_calendario', v_log,
    'info_calendario', v_info
  );

  return v_result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.verificar_reservas_por_sala(p_sala_horario_id uuid, p_data date, p_turno_cod text, p_horario_total text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SET search_path TO 'extensions', 'public'
AS $function$
declare
  v_id_sala uuid;
  v_registro_no_horario boolean := false;
  v_registro_no_periodo boolean := false;
  v_registro_no_dia boolean := false;
begin
  -- 1. Descobrir a sala relacionada ao sala_horario enviado
  select id_sala into v_id_sala
  from salas_horarios
  where id = p_sala_horario_id;

  -- Verifica se existe reserva nesse horário exato (mesmo sala + mesmo horário)
  v_registro_no_horario := exists (
    select 1
    from sala_reservas sr
    join salas_horarios sh on sh.id = sr.sala_horario_id
    where sr.data = p_data
      and sh.horario_total = p_horario_total
      and sh.id_sala = v_id_sala
      and sr.status != 'cancelado'
  );

  -- Verifica se há alguma reserva no mesmo turno (mesma sala)
  v_registro_no_periodo := exists (
    select 1
    from sala_reservas sr
    join salas_horarios sh on sh.id = sr.sala_horario_id
    where sr.data = p_data
      and sh.turno_cod = p_turno_cod
      and sh.id_sala = v_id_sala
      and sr.status != 'cancelado'
  );

  -- Verifica se há qualquer reserva nesse dia (na mesma sala)
  v_registro_no_dia := exists (
    select 1
    from sala_reservas sr
    join salas_horarios sh on sh.id = sr.sala_horario_id
    where sr.data = p_data
      and sh.id_sala = v_id_sala
      and sr.status != 'cancelado'
  );

  return jsonb_build_object(
    'registro_no_horario', v_registro_no_horario,
    'registro_no_periodo', v_registro_no_periodo,
    'registro_no_dia', v_registro_no_dia
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.verificar_respostas_bloco(p_id_user_expandido uuid, p_id_turma uuid, p_area tipo_area, p_bloco_partida text, p_bloco_destino text DEFAULT NULL::text, p_idade integer DEFAULT NULL::integer, p_tipo_processo tipo_processo DEFAULT 'seletivo'::tipo_processo)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_op int;
    v_od int;
    v_blocos text[];
    v_bloco text;
    v_check jsonb;
BEGIN
    --------------------------------------------------------------------
    -- 1) Buscar ordem_bloco da PARTIDA (no contexto area/turma)
    --------------------------------------------------------------------
    SELECT ordem_bloco
    INTO v_op
    FROM processo_documentos_obrigatorios pdo
    WHERE pdo.bloco::text = p_bloco_partida
      AND pdo.tipo_processo = p_tipo_processo -- FIX: Filtro por processo
      AND (
            (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
         OR (
                pdo.escopo = 'turma' 
                AND (
                       pdo.id_turma = p_id_turma 
                    OR (pdo.id_turma IS NULL AND pdo.id_area = p_area) -- FIX: Hibrido
                )
            )
      )
    ORDER BY ordem_bloco
    LIMIT 1;

    --------------------------------------------------------------------
    -- Se tiver DESTINO, buscar ordem_bloco dele tb (mesmo contexto)
    --------------------------------------------------------------------
    IF p_bloco_destino IS NOT NULL THEN
        SELECT ordem_bloco
        INTO v_od
        FROM processo_documentos_obrigatorios pdo
        WHERE pdo.bloco::text = p_bloco_destino
          AND pdo.tipo_processo = p_tipo_processo -- FIX: Filtro por processo
          AND (
                (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
             OR (
                    pdo.escopo = 'turma' 
                    AND (
                           pdo.id_turma = p_id_turma 
                        OR (pdo.id_turma IS NULL AND pdo.id_area = p_area)
                    )
                )
          )
        ORDER BY ordem_bloco
        LIMIT 1;
    END IF;

    --------------------------------------------------------------------
    -- CASO 1 — MODO ANTIGO: só verifica um bloco
    --------------------------------------------------------------------
    IF p_bloco_destino IS NULL THEN
        RETURN (
            SELECT public._verificar_um_bloco(
                p_id_user_expandido,
                p_id_turma,
                p_area,
                p_bloco_partida,
                p_idade,
                p_tipo_processo -- Repassa
            )
        );
    END IF;

    --------------------------------------------------------------------
    -- CASO 2 — NOVO: validar caminho entre os blocos
    --------------------------------------------------------------------
    IF v_op IS NULL OR v_od IS NULL THEN
        RETURN jsonb_build_object(
            'ok', false,
            'erro', 'Bloco de partida ou destino não encontrado no contexto da área/turma.'
        );
    END IF;

    IF v_op <= v_od THEN
        SELECT array_agg(bloco ORDER BY ordem_bloco)
        INTO v_blocos
        FROM (
            SELECT DISTINCT pdo.bloco::text AS bloco, pdo.ordem_bloco
            FROM processo_documentos_obrigatorios pdo
            WHERE pdo.ordem_bloco BETWEEN v_op AND v_od
              AND pdo.tipo_processo = p_tipo_processo -- FIX
              AND (
                    (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
                 OR (
                        pdo.escopo = 'turma' 
                        AND (
                               pdo.id_turma = p_id_turma 
                            OR (pdo.id_turma IS NULL AND pdo.id_area = p_area)
                        )
                    )
              )
            ORDER BY pdo.ordem_bloco
        ) sub;
    ELSE
        SELECT array_agg(bloco ORDER BY ordem_bloco DESC)
        INTO v_blocos
        FROM (
            SELECT DISTINCT pdo.bloco::text AS bloco, pdo.ordem_bloco
            FROM processo_documentos_obrigatorios pdo
            WHERE pdo.ordem_bloco BETWEEN v_od AND v_op
              AND pdo.tipo_processo = p_tipo_processo -- FIX
              AND (
                    (pdo.escopo = 'area'  AND pdo.id_area  = p_area)
                 OR (
                        pdo.escopo = 'turma' 
                        AND (
                               pdo.id_turma = p_id_turma 
                            OR (pdo.id_turma IS NULL AND pdo.id_area = p_area)
                        )
                    )
              )
            ORDER BY pdo.ordem_bloco DESC
        ) sub;
    END IF;

    --------------------------------------------------------------------
    -- valida bloco por bloco
    --------------------------------------------------------------------
    FOREACH v_bloco IN ARRAY v_blocos LOOP
        v_check := public._verificar_um_bloco(
            p_id_user_expandido,
            p_id_turma,
            p_area,
            v_bloco,
            p_idade,
            p_tipo_processo -- Repassa
        );

        IF (v_check->>'ok')::boolean = false THEN
            RETURN v_check;
        END IF;
    END LOOP;

    RETURN jsonb_build_object('ok', true);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.verificar_turnos_disponiveis(p_id_turma uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_turma_atual RECORD;
    v_dados jsonb;
    v_count INT;
BEGIN
    -- 1. Obter dados da turma atual
    SELECT * INTO v_turma_atual FROM public.turmas WHERE id = p_id_turma;

    IF v_turma_atual IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'mensagem', 'Turma não encontrada'
        );
    END IF;

    -- 2. Buscar outras turmas do mesmo curso, mesmo semestre, mas turnos diferentes
    -- O user pediu campos: id, nome da turma (nome_curso?), turno e nome + turno
    WITH turmas_disponiveis AS (
        SELECT 
            t.id,
            t.nome_curso AS nome, -- assumindo nome_curso como 'nome' curto, ou talvez precise join com curso se quiser nome do curso
            t.turno,
            (t.nome_curso || ' - ' || t.turno) AS "nome_composto" 
        FROM public.turmas t
        WHERE t.id_curso = v_turma_atual.id_curso
          AND t.ano_semestre = v_turma_atual.ano_semestre
          AND t.id <> p_id_turma -- exclui a própria turma
          AND t.turno <> v_turma_atual.turno -- Garante que é outro turno
    )
    SELECT 
        count(*),
        coalesce(jsonb_agg(to_jsonb(td)), '[]'::jsonb)
    INTO v_count, v_dados
    FROM turmas_disponiveis td;

    -- 3. Retorno
    IF v_count > 0 THEN
        RETURN jsonb_build_object(
            'sucesso', true,
            'mensagem', 'Turmas encontradas em outros turnos',
            'dados', v_dados
        );
    ELSE
        RETURN jsonb_build_object(
            'sucesso', false,
            'mensagem', 'Não há turmas para este curso em outro turno este semestre'
        );
    END IF;
END;
$function$
;

create or replace view "public"."view_bloco_pergunta" as  SELECT unnest(enum_range(NULL::bloco_pergunta)) AS bloco;


create or replace view "public"."view_estoque_ultimos_movimentos" as  SELECT pe.id AS id_estoque,
    pe.id_produto,
    p.nome AS nome_produto,
    pe.status_item,
    pe.updated_at,
        CASE
            WHEN (pe.status_item = 'descartado'::status_item) THEN (p.nome || ' foi descartado em '::text)
            WHEN (pe.status_item = 'reservado'::status_item) THEN (p.nome || ' foi reservado em '::text)
            WHEN (pe.status_item = 'manutenção'::status_item) THEN (p.nome || ' entrou em manutenção em '::text)
            WHEN (pe.status_item = 'disponível'::status_item) THEN (p.nome || ' ficou disponível em '::text)
            ELSE NULL::text
        END AS mensagem,
        CASE
            WHEN (pe.status_item = 'descartado'::status_item) THEN 'trash-2'::text
            WHEN (pe.status_item = 'reservado'::status_item) THEN 'calendar-days'::text
            WHEN (pe.status_item = 'manutenção'::status_item) THEN 'wrench'::text
            WHEN (pe.status_item = 'disponível'::status_item) THEN 'circle-check'::text
            ELSE NULL::text
        END AS icone,
        CASE
            WHEN (pe.status_item = 'descartado'::status_item) THEN '#EE3D49'::text
            WHEN (pe.status_item = 'manutenção'::status_item) THEN '#FED55C'::text
            WHEN (pe.status_item = 'reservado'::status_item) THEN '#009C82'::text
            WHEN (pe.status_item = 'disponível'::status_item) THEN '#5D2E86'::text
            ELSE NULL::text
        END AS cor
   FROM (produto_estoque pe
     JOIN produtos p ON ((p.id = pe.id_produto)))
  ORDER BY pe.updated_at DESC
 LIMIT 5;


create or replace view "public"."view_produtos_estoque" as  SELECT p.id AS produto_id,
    p.nome AS produto_nome,
    tp.nome AS tipo_produto_nome,
    pu.nome AS unidade_nome,
    p.quantidade AS quantidade_estoque,
    p.valor_inicial,
    p.treshold,
    p.codigo_barras,
    p.observacoes,
    p.imagem_produto
   FROM (((produtos p
     JOIN tipo_produto tp ON ((p.id_tipo_produto = tp.id)))
     JOIN produto_unidade pu ON ((p.id_unidade = pu.id)))
     LEFT JOIN produto_estoque pe ON ((p.id = pe.id_produto)))
  GROUP BY p.id, p.nome, tp.nome, pu.nome, p.valor_inicial, p.treshold, p.codigo_barras, p.observacoes, p.imagem_produto;


CREATE OR REPLACE FUNCTION public.vincular_user_expandido_auth(p_email text, p_papel_id uuid)
 RETURNS TABLE(user_expandido_id uuid, auth_user_id uuid, papel_id uuid)
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
DECLARE
  v_auth_id uuid;
  v_user_expandido_id uuid;
  v_existing_user_id uuid;
BEGIN
  -----------------------------------------------------------------------
  -- 1. Busca ID no auth.users
  -----------------------------------------------------------------------
  SELECT u.id INTO v_auth_id
  FROM auth.users u
  WHERE u.email = p_email
  LIMIT 1;

  IF v_auth_id IS NULL THEN
    RAISE EXCEPTION 'Usuário não encontrado em auth.users para o email: %', p_email;
  END IF;

  -----------------------------------------------------------------------
  -- 2. Busca user_expandido correspondente
  -----------------------------------------------------------------------
  SELECT ue.id, ue.user_id
  INTO v_user_expandido_id, v_existing_user_id
  FROM public.user_expandido ue
  WHERE ue.email = p_email
  LIMIT 1;

  IF v_user_expandido_id IS NULL THEN
    RAISE EXCEPTION 'Nenhum user_expandido encontrado para o email: %', p_email;
  END IF;

  -----------------------------------------------------------------------
  -- 3. SE user_expandido.user_id ESTIVER NULL → vincular
  -----------------------------------------------------------------------
  IF v_existing_user_id IS NULL THEN

    UPDATE public.user_expandido ue
       SET user_id = v_auth_id
     WHERE ue.id = v_user_expandido_id;

  END IF;

  -----------------------------------------------------------------------
  -- 4. Corrigir respostas antigas sem id_usuario
  -----------------------------------------------------------------------
  UPDATE public.respostas r
     SET id_usuario = v_auth_id
   WHERE r.user_expandido_id = v_user_expandido_id
     AND r.id_usuario IS NULL;

  -----------------------------------------------------------------------
  -- 5. Criar vínculo em papeis_user_auth (idempotente)
  -----------------------------------------------------------------------
  INSERT INTO public.papeis_user_auth (user_id, papel_id)
  VALUES (v_auth_id, p_papel_id)
  ON CONFLICT DO NOTHING;

  -----------------------------------------------------------------------
  -- 6. Retorno
  -----------------------------------------------------------------------
  RETURN QUERY
  SELECT v_user_expandido_id, v_auth_id, p_papel_id;

END;
$function$
;

grant delete on table "public"."bloco_perguntas" to "anon";

grant insert on table "public"."bloco_perguntas" to "anon";

grant references on table "public"."bloco_perguntas" to "anon";

grant select on table "public"."bloco_perguntas" to "anon";

grant trigger on table "public"."bloco_perguntas" to "anon";

grant truncate on table "public"."bloco_perguntas" to "anon";

grant update on table "public"."bloco_perguntas" to "anon";

grant delete on table "public"."bloco_perguntas" to "authenticated";

grant insert on table "public"."bloco_perguntas" to "authenticated";

grant references on table "public"."bloco_perguntas" to "authenticated";

grant select on table "public"."bloco_perguntas" to "authenticated";

grant trigger on table "public"."bloco_perguntas" to "authenticated";

grant truncate on table "public"."bloco_perguntas" to "authenticated";

grant update on table "public"."bloco_perguntas" to "authenticated";

grant delete on table "public"."bloco_perguntas" to "service_role";

grant insert on table "public"."bloco_perguntas" to "service_role";

grant references on table "public"."bloco_perguntas" to "service_role";

grant select on table "public"."bloco_perguntas" to "service_role";

grant trigger on table "public"."bloco_perguntas" to "service_role";

grant truncate on table "public"."bloco_perguntas" to "service_role";

grant update on table "public"."bloco_perguntas" to "service_role";

grant delete on table "public"."curso" to "anon";

grant insert on table "public"."curso" to "anon";

grant references on table "public"."curso" to "anon";

grant select on table "public"."curso" to "anon";

grant trigger on table "public"."curso" to "anon";

grant truncate on table "public"."curso" to "anon";

grant update on table "public"."curso" to "anon";

grant delete on table "public"."curso" to "authenticated";

grant insert on table "public"."curso" to "authenticated";

grant references on table "public"."curso" to "authenticated";

grant select on table "public"."curso" to "authenticated";

grant trigger on table "public"."curso" to "authenticated";

grant truncate on table "public"."curso" to "authenticated";

grant update on table "public"."curso" to "authenticated";

grant delete on table "public"."curso" to "service_role";

grant insert on table "public"."curso" to "service_role";

grant references on table "public"."curso" to "service_role";

grant select on table "public"."curso" to "service_role";

grant trigger on table "public"."curso" to "service_role";

grant truncate on table "public"."curso" to "service_role";

grant update on table "public"."curso" to "service_role";

grant delete on table "public"."curso_encontros" to "anon";

grant insert on table "public"."curso_encontros" to "anon";

grant references on table "public"."curso_encontros" to "anon";

grant select on table "public"."curso_encontros" to "anon";

grant trigger on table "public"."curso_encontros" to "anon";

grant truncate on table "public"."curso_encontros" to "anon";

grant update on table "public"."curso_encontros" to "anon";

grant delete on table "public"."curso_encontros" to "authenticated";

grant insert on table "public"."curso_encontros" to "authenticated";

grant references on table "public"."curso_encontros" to "authenticated";

grant select on table "public"."curso_encontros" to "authenticated";

grant trigger on table "public"."curso_encontros" to "authenticated";

grant truncate on table "public"."curso_encontros" to "authenticated";

grant update on table "public"."curso_encontros" to "authenticated";

grant delete on table "public"."curso_encontros" to "service_role";

grant insert on table "public"."curso_encontros" to "service_role";

grant references on table "public"."curso_encontros" to "service_role";

grant select on table "public"."curso_encontros" to "service_role";

grant trigger on table "public"."curso_encontros" to "service_role";

grant truncate on table "public"."curso_encontros" to "service_role";

grant update on table "public"."curso_encontros" to "service_role";

grant delete on table "public"."curso_ficha_avaliacao" to "anon";

grant insert on table "public"."curso_ficha_avaliacao" to "anon";

grant references on table "public"."curso_ficha_avaliacao" to "anon";

grant select on table "public"."curso_ficha_avaliacao" to "anon";

grant trigger on table "public"."curso_ficha_avaliacao" to "anon";

grant truncate on table "public"."curso_ficha_avaliacao" to "anon";

grant update on table "public"."curso_ficha_avaliacao" to "anon";

grant delete on table "public"."curso_ficha_avaliacao" to "authenticated";

grant insert on table "public"."curso_ficha_avaliacao" to "authenticated";

grant references on table "public"."curso_ficha_avaliacao" to "authenticated";

grant select on table "public"."curso_ficha_avaliacao" to "authenticated";

grant trigger on table "public"."curso_ficha_avaliacao" to "authenticated";

grant truncate on table "public"."curso_ficha_avaliacao" to "authenticated";

grant update on table "public"."curso_ficha_avaliacao" to "authenticated";

grant delete on table "public"."curso_ficha_avaliacao" to "service_role";

grant insert on table "public"."curso_ficha_avaliacao" to "service_role";

grant references on table "public"."curso_ficha_avaliacao" to "service_role";

grant select on table "public"."curso_ficha_avaliacao" to "service_role";

grant trigger on table "public"."curso_ficha_avaliacao" to "service_role";

grant truncate on table "public"."curso_ficha_avaliacao" to "service_role";

grant update on table "public"."curso_ficha_avaliacao" to "service_role";

grant insert on table "public"."diario" to "anon";

grant references on table "public"."diario" to "anon";

grant select on table "public"."diario" to "anon";

grant trigger on table "public"."diario" to "anon";

grant truncate on table "public"."diario" to "anon";

grant update on table "public"."diario" to "anon";

grant delete on table "public"."diario" to "authenticated";

grant insert on table "public"."diario" to "authenticated";

grant references on table "public"."diario" to "authenticated";

grant select on table "public"."diario" to "authenticated";

grant trigger on table "public"."diario" to "authenticated";

grant truncate on table "public"."diario" to "authenticated";

grant update on table "public"."diario" to "authenticated";

grant delete on table "public"."diario" to "service_role";

grant insert on table "public"."diario" to "service_role";

grant references on table "public"."diario" to "service_role";

grant select on table "public"."diario" to "service_role";

grant trigger on table "public"."diario" to "service_role";

grant truncate on table "public"."diario" to "service_role";

grant update on table "public"."diario" to "service_role";

grant insert on table "public"."diario_controle_sync" to "anon";

grant references on table "public"."diario_controle_sync" to "anon";

grant select on table "public"."diario_controle_sync" to "anon";

grant trigger on table "public"."diario_controle_sync" to "anon";

grant truncate on table "public"."diario_controle_sync" to "anon";

grant update on table "public"."diario_controle_sync" to "anon";

grant delete on table "public"."diario_controle_sync" to "authenticated";

grant insert on table "public"."diario_controle_sync" to "authenticated";

grant references on table "public"."diario_controle_sync" to "authenticated";

grant select on table "public"."diario_controle_sync" to "authenticated";

grant trigger on table "public"."diario_controle_sync" to "authenticated";

grant truncate on table "public"."diario_controle_sync" to "authenticated";

grant update on table "public"."diario_controle_sync" to "authenticated";

grant delete on table "public"."diario_controle_sync" to "service_role";

grant insert on table "public"."diario_controle_sync" to "service_role";

grant references on table "public"."diario_controle_sync" to "service_role";

grant select on table "public"."diario_controle_sync" to "service_role";

grant trigger on table "public"."diario_controle_sync" to "service_role";

grant truncate on table "public"."diario_controle_sync" to "service_role";

grant update on table "public"."diario_controle_sync" to "service_role";

grant insert on table "public"."diario_sync_sessao" to "anon";

grant references on table "public"."diario_sync_sessao" to "anon";

grant select on table "public"."diario_sync_sessao" to "anon";

grant trigger on table "public"."diario_sync_sessao" to "anon";

grant truncate on table "public"."diario_sync_sessao" to "anon";

grant update on table "public"."diario_sync_sessao" to "anon";

grant delete on table "public"."diario_sync_sessao" to "authenticated";

grant insert on table "public"."diario_sync_sessao" to "authenticated";

grant references on table "public"."diario_sync_sessao" to "authenticated";

grant select on table "public"."diario_sync_sessao" to "authenticated";

grant trigger on table "public"."diario_sync_sessao" to "authenticated";

grant truncate on table "public"."diario_sync_sessao" to "authenticated";

grant update on table "public"."diario_sync_sessao" to "authenticated";

grant delete on table "public"."diario_sync_sessao" to "service_role";

grant insert on table "public"."diario_sync_sessao" to "service_role";

grant references on table "public"."diario_sync_sessao" to "service_role";

grant select on table "public"."diario_sync_sessao" to "service_role";

grant trigger on table "public"."diario_sync_sessao" to "service_role";

grant truncate on table "public"."diario_sync_sessao" to "service_role";

grant update on table "public"."diario_sync_sessao" to "service_role";

grant delete on table "public"."email_queue" to "anon";

grant insert on table "public"."email_queue" to "anon";

grant references on table "public"."email_queue" to "anon";

grant select on table "public"."email_queue" to "anon";

grant trigger on table "public"."email_queue" to "anon";

grant truncate on table "public"."email_queue" to "anon";

grant update on table "public"."email_queue" to "anon";

grant delete on table "public"."email_queue" to "authenticated";

grant insert on table "public"."email_queue" to "authenticated";

grant references on table "public"."email_queue" to "authenticated";

grant select on table "public"."email_queue" to "authenticated";

grant trigger on table "public"."email_queue" to "authenticated";

grant truncate on table "public"."email_queue" to "authenticated";

grant update on table "public"."email_queue" to "authenticated";

grant delete on table "public"."email_queue" to "service_role";

grant insert on table "public"."email_queue" to "service_role";

grant references on table "public"."email_queue" to "service_role";

grant select on table "public"."email_queue" to "service_role";

grant trigger on table "public"."email_queue" to "service_role";

grant truncate on table "public"."email_queue" to "service_role";

grant update on table "public"."email_queue" to "service_role";

grant delete on table "public"."email_threads" to "anon";

grant insert on table "public"."email_threads" to "anon";

grant references on table "public"."email_threads" to "anon";

grant select on table "public"."email_threads" to "anon";

grant trigger on table "public"."email_threads" to "anon";

grant truncate on table "public"."email_threads" to "anon";

grant update on table "public"."email_threads" to "anon";

grant delete on table "public"."email_threads" to "authenticated";

grant insert on table "public"."email_threads" to "authenticated";

grant references on table "public"."email_threads" to "authenticated";

grant select on table "public"."email_threads" to "authenticated";

grant trigger on table "public"."email_threads" to "authenticated";

grant truncate on table "public"."email_threads" to "authenticated";

grant update on table "public"."email_threads" to "authenticated";

grant delete on table "public"."email_threads" to "service_role";

grant insert on table "public"."email_threads" to "service_role";

grant references on table "public"."email_threads" to "service_role";

grant select on table "public"."email_threads" to "service_role";

grant trigger on table "public"."email_threads" to "service_role";

grant truncate on table "public"."email_threads" to "service_role";

grant update on table "public"."email_threads" to "service_role";

grant delete on table "public"."feriados" to "anon";

grant insert on table "public"."feriados" to "anon";

grant references on table "public"."feriados" to "anon";

grant select on table "public"."feriados" to "anon";

grant trigger on table "public"."feriados" to "anon";

grant truncate on table "public"."feriados" to "anon";

grant update on table "public"."feriados" to "anon";

grant delete on table "public"."feriados" to "authenticated";

grant insert on table "public"."feriados" to "authenticated";

grant references on table "public"."feriados" to "authenticated";

grant select on table "public"."feriados" to "authenticated";

grant trigger on table "public"."feriados" to "authenticated";

grant truncate on table "public"."feriados" to "authenticated";

grant update on table "public"."feriados" to "authenticated";

grant delete on table "public"."feriados" to "service_role";

grant insert on table "public"."feriados" to "service_role";

grant references on table "public"."feriados" to "service_role";

grant select on table "public"."feriados" to "service_role";

grant trigger on table "public"."feriados" to "service_role";

grant truncate on table "public"."feriados" to "service_role";

grant update on table "public"."feriados" to "service_role";

grant delete on table "public"."matriculas" to "anon";

grant insert on table "public"."matriculas" to "anon";

grant references on table "public"."matriculas" to "anon";

grant select on table "public"."matriculas" to "anon";

grant trigger on table "public"."matriculas" to "anon";

grant truncate on table "public"."matriculas" to "anon";

grant update on table "public"."matriculas" to "anon";

grant delete on table "public"."matriculas" to "authenticated";

grant insert on table "public"."matriculas" to "authenticated";

grant references on table "public"."matriculas" to "authenticated";

grant select on table "public"."matriculas" to "authenticated";

grant trigger on table "public"."matriculas" to "authenticated";

grant truncate on table "public"."matriculas" to "authenticated";

grant update on table "public"."matriculas" to "authenticated";

grant delete on table "public"."matriculas" to "service_role";

grant insert on table "public"."matriculas" to "service_role";

grant references on table "public"."matriculas" to "service_role";

grant select on table "public"."matriculas" to "service_role";

grant trigger on table "public"."matriculas" to "service_role";

grant truncate on table "public"."matriculas" to "service_role";

grant update on table "public"."matriculas" to "service_role";

grant select on table "public"."papeis_user" to "authenticated";

grant delete on table "public"."papeis_user" to "service_role";

grant insert on table "public"."papeis_user" to "service_role";

grant references on table "public"."papeis_user" to "service_role";

grant select on table "public"."papeis_user" to "service_role";

grant trigger on table "public"."papeis_user" to "service_role";

grant truncate on table "public"."papeis_user" to "service_role";

grant update on table "public"."papeis_user" to "service_role";

grant select on table "public"."papeis_user" to "supabase_auth_admin";

grant delete on table "public"."papeis_user_auth" to "authenticated";

grant insert on table "public"."papeis_user_auth" to "authenticated";

grant select on table "public"."papeis_user_auth" to "authenticated";

grant update on table "public"."papeis_user_auth" to "authenticated";

grant delete on table "public"."papeis_user_auth" to "service_role";

grant insert on table "public"."papeis_user_auth" to "service_role";

grant references on table "public"."papeis_user_auth" to "service_role";

grant select on table "public"."papeis_user_auth" to "service_role";

grant trigger on table "public"."papeis_user_auth" to "service_role";

grant truncate on table "public"."papeis_user_auth" to "service_role";

grant update on table "public"."papeis_user_auth" to "service_role";

grant select on table "public"."papeis_user_auth" to "supabase_auth_admin";

grant delete on table "public"."perguntas" to "anon";

grant insert on table "public"."perguntas" to "anon";

grant references on table "public"."perguntas" to "anon";

grant select on table "public"."perguntas" to "anon";

grant trigger on table "public"."perguntas" to "anon";

grant truncate on table "public"."perguntas" to "anon";

grant update on table "public"."perguntas" to "anon";

grant delete on table "public"."perguntas" to "authenticated";

grant insert on table "public"."perguntas" to "authenticated";

grant references on table "public"."perguntas" to "authenticated";

grant select on table "public"."perguntas" to "authenticated";

grant trigger on table "public"."perguntas" to "authenticated";

grant truncate on table "public"."perguntas" to "authenticated";

grant update on table "public"."perguntas" to "authenticated";

grant delete on table "public"."perguntas" to "service_role";

grant insert on table "public"."perguntas" to "service_role";

grant references on table "public"."perguntas" to "service_role";

grant select on table "public"."perguntas" to "service_role";

grant trigger on table "public"."perguntas" to "service_role";

grant truncate on table "public"."perguntas" to "service_role";

grant update on table "public"."perguntas" to "service_role";

grant delete on table "public"."perguntas_avaliacao_processos" to "anon";

grant insert on table "public"."perguntas_avaliacao_processos" to "anon";

grant references on table "public"."perguntas_avaliacao_processos" to "anon";

grant select on table "public"."perguntas_avaliacao_processos" to "anon";

grant trigger on table "public"."perguntas_avaliacao_processos" to "anon";

grant truncate on table "public"."perguntas_avaliacao_processos" to "anon";

grant update on table "public"."perguntas_avaliacao_processos" to "anon";

grant delete on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant insert on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant references on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant select on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant trigger on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant truncate on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant update on table "public"."perguntas_avaliacao_processos" to "authenticated";

grant delete on table "public"."perguntas_avaliacao_processos" to "service_role";

grant insert on table "public"."perguntas_avaliacao_processos" to "service_role";

grant references on table "public"."perguntas_avaliacao_processos" to "service_role";

grant select on table "public"."perguntas_avaliacao_processos" to "service_role";

grant trigger on table "public"."perguntas_avaliacao_processos" to "service_role";

grant truncate on table "public"."perguntas_avaliacao_processos" to "service_role";

grant update on table "public"."perguntas_avaliacao_processos" to "service_role";

grant delete on table "public"."processo_documentos_obrigatorios" to "anon";

grant insert on table "public"."processo_documentos_obrigatorios" to "anon";

grant references on table "public"."processo_documentos_obrigatorios" to "anon";

grant select on table "public"."processo_documentos_obrigatorios" to "anon";

grant trigger on table "public"."processo_documentos_obrigatorios" to "anon";

grant truncate on table "public"."processo_documentos_obrigatorios" to "anon";

grant update on table "public"."processo_documentos_obrigatorios" to "anon";

grant delete on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant insert on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant references on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant select on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant trigger on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant truncate on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant update on table "public"."processo_documentos_obrigatorios" to "authenticated";

grant delete on table "public"."processo_documentos_obrigatorios" to "service_role";

grant insert on table "public"."processo_documentos_obrigatorios" to "service_role";

grant references on table "public"."processo_documentos_obrigatorios" to "service_role";

grant select on table "public"."processo_documentos_obrigatorios" to "service_role";

grant trigger on table "public"."processo_documentos_obrigatorios" to "service_role";

grant truncate on table "public"."processo_documentos_obrigatorios" to "service_role";

grant update on table "public"."processo_documentos_obrigatorios" to "service_role";

grant delete on table "public"."processos" to "anon";

grant insert on table "public"."processos" to "anon";

grant references on table "public"."processos" to "anon";

grant select on table "public"."processos" to "anon";

grant trigger on table "public"."processos" to "anon";

grant truncate on table "public"."processos" to "anon";

grant update on table "public"."processos" to "anon";

grant delete on table "public"."processos" to "authenticated";

grant insert on table "public"."processos" to "authenticated";

grant references on table "public"."processos" to "authenticated";

grant select on table "public"."processos" to "authenticated";

grant trigger on table "public"."processos" to "authenticated";

grant truncate on table "public"."processos" to "authenticated";

grant update on table "public"."processos" to "authenticated";

grant delete on table "public"."processos" to "service_role";

grant insert on table "public"."processos" to "service_role";

grant references on table "public"."processos" to "service_role";

grant select on table "public"."processos" to "service_role";

grant trigger on table "public"."processos" to "service_role";

grant truncate on table "public"."processos" to "service_role";

grant update on table "public"."processos" to "service_role";

grant delete on table "public"."processos_antigos" to "anon";

grant insert on table "public"."processos_antigos" to "anon";

grant references on table "public"."processos_antigos" to "anon";

grant select on table "public"."processos_antigos" to "anon";

grant trigger on table "public"."processos_antigos" to "anon";

grant truncate on table "public"."processos_antigos" to "anon";

grant update on table "public"."processos_antigos" to "anon";

grant delete on table "public"."processos_antigos" to "authenticated";

grant insert on table "public"."processos_antigos" to "authenticated";

grant references on table "public"."processos_antigos" to "authenticated";

grant select on table "public"."processos_antigos" to "authenticated";

grant trigger on table "public"."processos_antigos" to "authenticated";

grant truncate on table "public"."processos_antigos" to "authenticated";

grant update on table "public"."processos_antigos" to "authenticated";

grant delete on table "public"."processos_antigos" to "service_role";

grant insert on table "public"."processos_antigos" to "service_role";

grant references on table "public"."processos_antigos" to "service_role";

grant select on table "public"."processos_antigos" to "service_role";

grant trigger on table "public"."processos_antigos" to "service_role";

grant truncate on table "public"."processos_antigos" to "service_role";

grant update on table "public"."processos_antigos" to "service_role";

grant delete on table "public"."produto_avarias" to "anon";

grant insert on table "public"."produto_avarias" to "anon";

grant references on table "public"."produto_avarias" to "anon";

grant select on table "public"."produto_avarias" to "anon";

grant trigger on table "public"."produto_avarias" to "anon";

grant truncate on table "public"."produto_avarias" to "anon";

grant update on table "public"."produto_avarias" to "anon";

grant delete on table "public"."produto_avarias" to "authenticated";

grant insert on table "public"."produto_avarias" to "authenticated";

grant references on table "public"."produto_avarias" to "authenticated";

grant select on table "public"."produto_avarias" to "authenticated";

grant trigger on table "public"."produto_avarias" to "authenticated";

grant truncate on table "public"."produto_avarias" to "authenticated";

grant update on table "public"."produto_avarias" to "authenticated";

grant delete on table "public"."produto_avarias" to "service_role";

grant insert on table "public"."produto_avarias" to "service_role";

grant references on table "public"."produto_avarias" to "service_role";

grant select on table "public"."produto_avarias" to "service_role";

grant trigger on table "public"."produto_avarias" to "service_role";

grant truncate on table "public"."produto_avarias" to "service_role";

grant update on table "public"."produto_avarias" to "service_role";

grant delete on table "public"."produto_categoria" to "anon";

grant insert on table "public"."produto_categoria" to "anon";

grant references on table "public"."produto_categoria" to "anon";

grant select on table "public"."produto_categoria" to "anon";

grant trigger on table "public"."produto_categoria" to "anon";

grant truncate on table "public"."produto_categoria" to "anon";

grant update on table "public"."produto_categoria" to "anon";

grant delete on table "public"."produto_categoria" to "authenticated";

grant insert on table "public"."produto_categoria" to "authenticated";

grant references on table "public"."produto_categoria" to "authenticated";

grant select on table "public"."produto_categoria" to "authenticated";

grant trigger on table "public"."produto_categoria" to "authenticated";

grant truncate on table "public"."produto_categoria" to "authenticated";

grant update on table "public"."produto_categoria" to "authenticated";

grant delete on table "public"."produto_categoria" to "service_role";

grant insert on table "public"."produto_categoria" to "service_role";

grant references on table "public"."produto_categoria" to "service_role";

grant select on table "public"."produto_categoria" to "service_role";

grant trigger on table "public"."produto_categoria" to "service_role";

grant truncate on table "public"."produto_categoria" to "service_role";

grant update on table "public"."produto_categoria" to "service_role";

grant delete on table "public"."produto_estoque" to "anon";

grant insert on table "public"."produto_estoque" to "anon";

grant references on table "public"."produto_estoque" to "anon";

grant select on table "public"."produto_estoque" to "anon";

grant trigger on table "public"."produto_estoque" to "anon";

grant truncate on table "public"."produto_estoque" to "anon";

grant update on table "public"."produto_estoque" to "anon";

grant delete on table "public"."produto_estoque" to "authenticated";

grant insert on table "public"."produto_estoque" to "authenticated";

grant references on table "public"."produto_estoque" to "authenticated";

grant select on table "public"."produto_estoque" to "authenticated";

grant trigger on table "public"."produto_estoque" to "authenticated";

grant truncate on table "public"."produto_estoque" to "authenticated";

grant update on table "public"."produto_estoque" to "authenticated";

grant delete on table "public"."produto_estoque" to "service_role";

grant insert on table "public"."produto_estoque" to "service_role";

grant references on table "public"."produto_estoque" to "service_role";

grant select on table "public"."produto_estoque" to "service_role";

grant trigger on table "public"."produto_estoque" to "service_role";

grant truncate on table "public"."produto_estoque" to "service_role";

grant update on table "public"."produto_estoque" to "service_role";

grant delete on table "public"."produto_kit" to "anon";

grant insert on table "public"."produto_kit" to "anon";

grant references on table "public"."produto_kit" to "anon";

grant select on table "public"."produto_kit" to "anon";

grant trigger on table "public"."produto_kit" to "anon";

grant truncate on table "public"."produto_kit" to "anon";

grant update on table "public"."produto_kit" to "anon";

grant delete on table "public"."produto_kit" to "authenticated";

grant insert on table "public"."produto_kit" to "authenticated";

grant references on table "public"."produto_kit" to "authenticated";

grant select on table "public"."produto_kit" to "authenticated";

grant trigger on table "public"."produto_kit" to "authenticated";

grant truncate on table "public"."produto_kit" to "authenticated";

grant update on table "public"."produto_kit" to "authenticated";

grant delete on table "public"."produto_kit" to "service_role";

grant insert on table "public"."produto_kit" to "service_role";

grant references on table "public"."produto_kit" to "service_role";

grant select on table "public"."produto_kit" to "service_role";

grant trigger on table "public"."produto_kit" to "service_role";

grant truncate on table "public"."produto_kit" to "service_role";

grant update on table "public"."produto_kit" to "service_role";

grant delete on table "public"."produto_reservas" to "anon";

grant insert on table "public"."produto_reservas" to "anon";

grant references on table "public"."produto_reservas" to "anon";

grant select on table "public"."produto_reservas" to "anon";

grant trigger on table "public"."produto_reservas" to "anon";

grant truncate on table "public"."produto_reservas" to "anon";

grant update on table "public"."produto_reservas" to "anon";

grant delete on table "public"."produto_reservas" to "authenticated";

grant insert on table "public"."produto_reservas" to "authenticated";

grant references on table "public"."produto_reservas" to "authenticated";

grant select on table "public"."produto_reservas" to "authenticated";

grant trigger on table "public"."produto_reservas" to "authenticated";

grant truncate on table "public"."produto_reservas" to "authenticated";

grant update on table "public"."produto_reservas" to "authenticated";

grant delete on table "public"."produto_reservas" to "service_role";

grant insert on table "public"."produto_reservas" to "service_role";

grant references on table "public"."produto_reservas" to "service_role";

grant select on table "public"."produto_reservas" to "service_role";

grant trigger on table "public"."produto_reservas" to "service_role";

grant truncate on table "public"."produto_reservas" to "service_role";

grant update on table "public"."produto_reservas" to "service_role";

grant delete on table "public"."produto_tipo_avaria" to "anon";

grant insert on table "public"."produto_tipo_avaria" to "anon";

grant references on table "public"."produto_tipo_avaria" to "anon";

grant select on table "public"."produto_tipo_avaria" to "anon";

grant trigger on table "public"."produto_tipo_avaria" to "anon";

grant truncate on table "public"."produto_tipo_avaria" to "anon";

grant update on table "public"."produto_tipo_avaria" to "anon";

grant delete on table "public"."produto_tipo_avaria" to "authenticated";

grant insert on table "public"."produto_tipo_avaria" to "authenticated";

grant references on table "public"."produto_tipo_avaria" to "authenticated";

grant select on table "public"."produto_tipo_avaria" to "authenticated";

grant trigger on table "public"."produto_tipo_avaria" to "authenticated";

grant truncate on table "public"."produto_tipo_avaria" to "authenticated";

grant update on table "public"."produto_tipo_avaria" to "authenticated";

grant delete on table "public"."produto_tipo_avaria" to "service_role";

grant insert on table "public"."produto_tipo_avaria" to "service_role";

grant references on table "public"."produto_tipo_avaria" to "service_role";

grant select on table "public"."produto_tipo_avaria" to "service_role";

grant trigger on table "public"."produto_tipo_avaria" to "service_role";

grant truncate on table "public"."produto_tipo_avaria" to "service_role";

grant update on table "public"."produto_tipo_avaria" to "service_role";

grant delete on table "public"."produto_unidade" to "anon";

grant insert on table "public"."produto_unidade" to "anon";

grant references on table "public"."produto_unidade" to "anon";

grant select on table "public"."produto_unidade" to "anon";

grant trigger on table "public"."produto_unidade" to "anon";

grant truncate on table "public"."produto_unidade" to "anon";

grant update on table "public"."produto_unidade" to "anon";

grant delete on table "public"."produto_unidade" to "authenticated";

grant insert on table "public"."produto_unidade" to "authenticated";

grant references on table "public"."produto_unidade" to "authenticated";

grant select on table "public"."produto_unidade" to "authenticated";

grant trigger on table "public"."produto_unidade" to "authenticated";

grant truncate on table "public"."produto_unidade" to "authenticated";

grant update on table "public"."produto_unidade" to "authenticated";

grant delete on table "public"."produto_unidade" to "service_role";

grant insert on table "public"."produto_unidade" to "service_role";

grant references on table "public"."produto_unidade" to "service_role";

grant select on table "public"."produto_unidade" to "service_role";

grant trigger on table "public"."produto_unidade" to "service_role";

grant truncate on table "public"."produto_unidade" to "service_role";

grant update on table "public"."produto_unidade" to "service_role";

grant delete on table "public"."produtos" to "anon";

grant insert on table "public"."produtos" to "anon";

grant references on table "public"."produtos" to "anon";

grant select on table "public"."produtos" to "anon";

grant trigger on table "public"."produtos" to "anon";

grant truncate on table "public"."produtos" to "anon";

grant update on table "public"."produtos" to "anon";

grant delete on table "public"."produtos" to "authenticated";

grant insert on table "public"."produtos" to "authenticated";

grant references on table "public"."produtos" to "authenticated";

grant select on table "public"."produtos" to "authenticated";

grant trigger on table "public"."produtos" to "authenticated";

grant truncate on table "public"."produtos" to "authenticated";

grant update on table "public"."produtos" to "authenticated";

grant delete on table "public"."produtos" to "service_role";

grant insert on table "public"."produtos" to "service_role";

grant references on table "public"."produtos" to "service_role";

grant select on table "public"."produtos" to "service_role";

grant trigger on table "public"."produtos" to "service_role";

grant truncate on table "public"."produtos" to "service_role";

grant update on table "public"."produtos" to "service_role";

grant delete on table "public"."professor_turma_atribuicao" to "anon";

grant insert on table "public"."professor_turma_atribuicao" to "anon";

grant references on table "public"."professor_turma_atribuicao" to "anon";

grant select on table "public"."professor_turma_atribuicao" to "anon";

grant trigger on table "public"."professor_turma_atribuicao" to "anon";

grant truncate on table "public"."professor_turma_atribuicao" to "anon";

grant update on table "public"."professor_turma_atribuicao" to "anon";

grant delete on table "public"."professor_turma_atribuicao" to "authenticated";

grant insert on table "public"."professor_turma_atribuicao" to "authenticated";

grant references on table "public"."professor_turma_atribuicao" to "authenticated";

grant select on table "public"."professor_turma_atribuicao" to "authenticated";

grant trigger on table "public"."professor_turma_atribuicao" to "authenticated";

grant truncate on table "public"."professor_turma_atribuicao" to "authenticated";

grant update on table "public"."professor_turma_atribuicao" to "authenticated";

grant delete on table "public"."professor_turma_atribuicao" to "service_role";

grant insert on table "public"."professor_turma_atribuicao" to "service_role";

grant references on table "public"."professor_turma_atribuicao" to "service_role";

grant select on table "public"."professor_turma_atribuicao" to "service_role";

grant trigger on table "public"."professor_turma_atribuicao" to "service_role";

grant truncate on table "public"."professor_turma_atribuicao" to "service_role";

grant update on table "public"."professor_turma_atribuicao" to "service_role";

grant delete on table "public"."ra_alunos" to "anon";

grant insert on table "public"."ra_alunos" to "anon";

grant references on table "public"."ra_alunos" to "anon";

grant select on table "public"."ra_alunos" to "anon";

grant trigger on table "public"."ra_alunos" to "anon";

grant truncate on table "public"."ra_alunos" to "anon";

grant update on table "public"."ra_alunos" to "anon";

grant delete on table "public"."ra_alunos" to "authenticated";

grant insert on table "public"."ra_alunos" to "authenticated";

grant references on table "public"."ra_alunos" to "authenticated";

grant select on table "public"."ra_alunos" to "authenticated";

grant trigger on table "public"."ra_alunos" to "authenticated";

grant truncate on table "public"."ra_alunos" to "authenticated";

grant update on table "public"."ra_alunos" to "authenticated";

grant delete on table "public"."ra_alunos" to "service_role";

grant insert on table "public"."ra_alunos" to "service_role";

grant references on table "public"."ra_alunos" to "service_role";

grant select on table "public"."ra_alunos" to "service_role";

grant trigger on table "public"."ra_alunos" to "service_role";

grant truncate on table "public"."ra_alunos" to "service_role";

grant update on table "public"."ra_alunos" to "service_role";

grant delete on table "public"."respostas" to "anon";

grant insert on table "public"."respostas" to "anon";

grant references on table "public"."respostas" to "anon";

grant select on table "public"."respostas" to "anon";

grant trigger on table "public"."respostas" to "anon";

grant truncate on table "public"."respostas" to "anon";

grant update on table "public"."respostas" to "anon";

grant delete on table "public"."respostas" to "authenticated";

grant insert on table "public"."respostas" to "authenticated";

grant references on table "public"."respostas" to "authenticated";

grant select on table "public"."respostas" to "authenticated";

grant trigger on table "public"."respostas" to "authenticated";

grant truncate on table "public"."respostas" to "authenticated";

grant update on table "public"."respostas" to "authenticated";

grant delete on table "public"."respostas" to "service_role";

grant insert on table "public"."respostas" to "service_role";

grant references on table "public"."respostas" to "service_role";

grant select on table "public"."respostas" to "service_role";

grant trigger on table "public"."respostas" to "service_role";

grant truncate on table "public"."respostas" to "service_role";

grant update on table "public"."respostas" to "service_role";

grant delete on table "public"."respostas_conflito_bkp" to "anon";

grant insert on table "public"."respostas_conflito_bkp" to "anon";

grant references on table "public"."respostas_conflito_bkp" to "anon";

grant select on table "public"."respostas_conflito_bkp" to "anon";

grant trigger on table "public"."respostas_conflito_bkp" to "anon";

grant truncate on table "public"."respostas_conflito_bkp" to "anon";

grant update on table "public"."respostas_conflito_bkp" to "anon";

grant delete on table "public"."respostas_conflito_bkp" to "authenticated";

grant insert on table "public"."respostas_conflito_bkp" to "authenticated";

grant references on table "public"."respostas_conflito_bkp" to "authenticated";

grant select on table "public"."respostas_conflito_bkp" to "authenticated";

grant trigger on table "public"."respostas_conflito_bkp" to "authenticated";

grant truncate on table "public"."respostas_conflito_bkp" to "authenticated";

grant update on table "public"."respostas_conflito_bkp" to "authenticated";

grant delete on table "public"."respostas_conflito_bkp" to "service_role";

grant insert on table "public"."respostas_conflito_bkp" to "service_role";

grant references on table "public"."respostas_conflito_bkp" to "service_role";

grant select on table "public"."respostas_conflito_bkp" to "service_role";

grant trigger on table "public"."respostas_conflito_bkp" to "service_role";

grant truncate on table "public"."respostas_conflito_bkp" to "service_role";

grant update on table "public"."respostas_conflito_bkp" to "service_role";

grant delete on table "public"."respostas_conflito_bkp_v2" to "anon";

grant insert on table "public"."respostas_conflito_bkp_v2" to "anon";

grant references on table "public"."respostas_conflito_bkp_v2" to "anon";

grant select on table "public"."respostas_conflito_bkp_v2" to "anon";

grant trigger on table "public"."respostas_conflito_bkp_v2" to "anon";

grant truncate on table "public"."respostas_conflito_bkp_v2" to "anon";

grant update on table "public"."respostas_conflito_bkp_v2" to "anon";

grant delete on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant insert on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant references on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant select on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant trigger on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant truncate on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant update on table "public"."respostas_conflito_bkp_v2" to "authenticated";

grant delete on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant insert on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant references on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant select on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant trigger on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant truncate on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant update on table "public"."respostas_conflito_bkp_v2" to "service_role";

grant delete on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant insert on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant references on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant select on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant trigger on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant truncate on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant update on table "public"."respostas_perguntas_avaliacao_processos" to "anon";

grant delete on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant insert on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant references on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant select on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant trigger on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant truncate on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant update on table "public"."respostas_perguntas_avaliacao_processos" to "authenticated";

grant delete on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant insert on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant references on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant select on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant trigger on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant truncate on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant update on table "public"."respostas_perguntas_avaliacao_processos" to "service_role";

grant delete on table "public"."sala" to "anon";

grant insert on table "public"."sala" to "anon";

grant references on table "public"."sala" to "anon";

grant select on table "public"."sala" to "anon";

grant trigger on table "public"."sala" to "anon";

grant truncate on table "public"."sala" to "anon";

grant update on table "public"."sala" to "anon";

grant delete on table "public"."sala" to "authenticated";

grant insert on table "public"."sala" to "authenticated";

grant references on table "public"."sala" to "authenticated";

grant select on table "public"."sala" to "authenticated";

grant trigger on table "public"."sala" to "authenticated";

grant truncate on table "public"."sala" to "authenticated";

grant update on table "public"."sala" to "authenticated";

grant delete on table "public"."sala" to "service_role";

grant insert on table "public"."sala" to "service_role";

grant references on table "public"."sala" to "service_role";

grant select on table "public"."sala" to "service_role";

grant trigger on table "public"."sala" to "service_role";

grant truncate on table "public"."sala" to "service_role";

grant update on table "public"."sala" to "service_role";

grant delete on table "public"."sala_reservas" to "anon";

grant insert on table "public"."sala_reservas" to "anon";

grant references on table "public"."sala_reservas" to "anon";

grant select on table "public"."sala_reservas" to "anon";

grant trigger on table "public"."sala_reservas" to "anon";

grant truncate on table "public"."sala_reservas" to "anon";

grant update on table "public"."sala_reservas" to "anon";

grant delete on table "public"."sala_reservas" to "authenticated";

grant insert on table "public"."sala_reservas" to "authenticated";

grant references on table "public"."sala_reservas" to "authenticated";

grant select on table "public"."sala_reservas" to "authenticated";

grant trigger on table "public"."sala_reservas" to "authenticated";

grant truncate on table "public"."sala_reservas" to "authenticated";

grant update on table "public"."sala_reservas" to "authenticated";

grant delete on table "public"."sala_reservas" to "service_role";

grant insert on table "public"."sala_reservas" to "service_role";

grant references on table "public"."sala_reservas" to "service_role";

grant select on table "public"."sala_reservas" to "service_role";

grant trigger on table "public"."sala_reservas" to "service_role";

grant truncate on table "public"."sala_reservas" to "service_role";

grant update on table "public"."sala_reservas" to "service_role";

grant delete on table "public"."salas_horarios" to "anon";

grant insert on table "public"."salas_horarios" to "anon";

grant references on table "public"."salas_horarios" to "anon";

grant select on table "public"."salas_horarios" to "anon";

grant trigger on table "public"."salas_horarios" to "anon";

grant truncate on table "public"."salas_horarios" to "anon";

grant update on table "public"."salas_horarios" to "anon";

grant delete on table "public"."salas_horarios" to "authenticated";

grant insert on table "public"."salas_horarios" to "authenticated";

grant references on table "public"."salas_horarios" to "authenticated";

grant select on table "public"."salas_horarios" to "authenticated";

grant trigger on table "public"."salas_horarios" to "authenticated";

grant truncate on table "public"."salas_horarios" to "authenticated";

grant update on table "public"."salas_horarios" to "authenticated";

grant delete on table "public"."salas_horarios" to "service_role";

grant insert on table "public"."salas_horarios" to "service_role";

grant references on table "public"."salas_horarios" to "service_role";

grant select on table "public"."salas_horarios" to "service_role";

grant trigger on table "public"."salas_horarios" to "service_role";

grant truncate on table "public"."salas_horarios" to "service_role";

grant update on table "public"."salas_horarios" to "service_role";

grant delete on table "public"."slot_horarios" to "anon";

grant insert on table "public"."slot_horarios" to "anon";

grant references on table "public"."slot_horarios" to "anon";

grant select on table "public"."slot_horarios" to "anon";

grant trigger on table "public"."slot_horarios" to "anon";

grant truncate on table "public"."slot_horarios" to "anon";

grant update on table "public"."slot_horarios" to "anon";

grant delete on table "public"."slot_horarios" to "authenticated";

grant insert on table "public"."slot_horarios" to "authenticated";

grant references on table "public"."slot_horarios" to "authenticated";

grant select on table "public"."slot_horarios" to "authenticated";

grant trigger on table "public"."slot_horarios" to "authenticated";

grant truncate on table "public"."slot_horarios" to "authenticated";

grant update on table "public"."slot_horarios" to "authenticated";

grant delete on table "public"."slot_horarios" to "service_role";

grant insert on table "public"."slot_horarios" to "service_role";

grant references on table "public"."slot_horarios" to "service_role";

grant select on table "public"."slot_horarios" to "service_role";

grant trigger on table "public"."slot_horarios" to "service_role";

grant truncate on table "public"."slot_horarios" to "service_role";

grant update on table "public"."slot_horarios" to "service_role";

grant delete on table "public"."stg_corrigir_ras" to "anon";

grant insert on table "public"."stg_corrigir_ras" to "anon";

grant references on table "public"."stg_corrigir_ras" to "anon";

grant select on table "public"."stg_corrigir_ras" to "anon";

grant trigger on table "public"."stg_corrigir_ras" to "anon";

grant truncate on table "public"."stg_corrigir_ras" to "anon";

grant update on table "public"."stg_corrigir_ras" to "anon";

grant delete on table "public"."stg_corrigir_ras" to "authenticated";

grant insert on table "public"."stg_corrigir_ras" to "authenticated";

grant references on table "public"."stg_corrigir_ras" to "authenticated";

grant select on table "public"."stg_corrigir_ras" to "authenticated";

grant trigger on table "public"."stg_corrigir_ras" to "authenticated";

grant truncate on table "public"."stg_corrigir_ras" to "authenticated";

grant update on table "public"."stg_corrigir_ras" to "authenticated";

grant delete on table "public"."stg_corrigir_ras" to "service_role";

grant insert on table "public"."stg_corrigir_ras" to "service_role";

grant references on table "public"."stg_corrigir_ras" to "service_role";

grant select on table "public"."stg_corrigir_ras" to "service_role";

grant trigger on table "public"."stg_corrigir_ras" to "service_role";

grant truncate on table "public"."stg_corrigir_ras" to "service_role";

grant update on table "public"."stg_corrigir_ras" to "service_role";

grant delete on table "public"."stg_cursos" to "anon";

grant insert on table "public"."stg_cursos" to "anon";

grant references on table "public"."stg_cursos" to "anon";

grant select on table "public"."stg_cursos" to "anon";

grant trigger on table "public"."stg_cursos" to "anon";

grant truncate on table "public"."stg_cursos" to "anon";

grant update on table "public"."stg_cursos" to "anon";

grant delete on table "public"."stg_cursos" to "authenticated";

grant insert on table "public"."stg_cursos" to "authenticated";

grant references on table "public"."stg_cursos" to "authenticated";

grant select on table "public"."stg_cursos" to "authenticated";

grant trigger on table "public"."stg_cursos" to "authenticated";

grant truncate on table "public"."stg_cursos" to "authenticated";

grant update on table "public"."stg_cursos" to "authenticated";

grant delete on table "public"."stg_cursos" to "service_role";

grant insert on table "public"."stg_cursos" to "service_role";

grant references on table "public"."stg_cursos" to "service_role";

grant select on table "public"."stg_cursos" to "service_role";

grant trigger on table "public"."stg_cursos" to "service_role";

grant truncate on table "public"."stg_cursos" to "service_role";

grant update on table "public"."stg_cursos" to "service_role";

grant delete on table "public"."stg_diario_mesclados" to "anon";

grant insert on table "public"."stg_diario_mesclados" to "anon";

grant references on table "public"."stg_diario_mesclados" to "anon";

grant select on table "public"."stg_diario_mesclados" to "anon";

grant trigger on table "public"."stg_diario_mesclados" to "anon";

grant truncate on table "public"."stg_diario_mesclados" to "anon";

grant update on table "public"."stg_diario_mesclados" to "anon";

grant delete on table "public"."stg_diario_mesclados" to "authenticated";

grant insert on table "public"."stg_diario_mesclados" to "authenticated";

grant references on table "public"."stg_diario_mesclados" to "authenticated";

grant select on table "public"."stg_diario_mesclados" to "authenticated";

grant trigger on table "public"."stg_diario_mesclados" to "authenticated";

grant truncate on table "public"."stg_diario_mesclados" to "authenticated";

grant update on table "public"."stg_diario_mesclados" to "authenticated";

grant delete on table "public"."stg_diario_mesclados" to "service_role";

grant insert on table "public"."stg_diario_mesclados" to "service_role";

grant references on table "public"."stg_diario_mesclados" to "service_role";

grant select on table "public"."stg_diario_mesclados" to "service_role";

grant trigger on table "public"."stg_diario_mesclados" to "service_role";

grant truncate on table "public"."stg_diario_mesclados" to "service_role";

grant update on table "public"."stg_diario_mesclados" to "service_role";

grant delete on table "public"."stg_matriculas" to "anon";

grant insert on table "public"."stg_matriculas" to "anon";

grant references on table "public"."stg_matriculas" to "anon";

grant select on table "public"."stg_matriculas" to "anon";

grant trigger on table "public"."stg_matriculas" to "anon";

grant truncate on table "public"."stg_matriculas" to "anon";

grant update on table "public"."stg_matriculas" to "anon";

grant delete on table "public"."stg_matriculas" to "authenticated";

grant insert on table "public"."stg_matriculas" to "authenticated";

grant references on table "public"."stg_matriculas" to "authenticated";

grant select on table "public"."stg_matriculas" to "authenticated";

grant trigger on table "public"."stg_matriculas" to "authenticated";

grant truncate on table "public"."stg_matriculas" to "authenticated";

grant update on table "public"."stg_matriculas" to "authenticated";

grant delete on table "public"."stg_matriculas" to "service_role";

grant insert on table "public"."stg_matriculas" to "service_role";

grant references on table "public"."stg_matriculas" to "service_role";

grant select on table "public"."stg_matriculas" to "service_role";

grant trigger on table "public"."stg_matriculas" to "service_role";

grant truncate on table "public"."stg_matriculas" to "service_role";

grant update on table "public"."stg_matriculas" to "service_role";

grant delete on table "public"."stg_turmas_horarios" to "anon";

grant insert on table "public"."stg_turmas_horarios" to "anon";

grant references on table "public"."stg_turmas_horarios" to "anon";

grant select on table "public"."stg_turmas_horarios" to "anon";

grant trigger on table "public"."stg_turmas_horarios" to "anon";

grant truncate on table "public"."stg_turmas_horarios" to "anon";

grant update on table "public"."stg_turmas_horarios" to "anon";

grant delete on table "public"."stg_turmas_horarios" to "authenticated";

grant insert on table "public"."stg_turmas_horarios" to "authenticated";

grant references on table "public"."stg_turmas_horarios" to "authenticated";

grant select on table "public"."stg_turmas_horarios" to "authenticated";

grant trigger on table "public"."stg_turmas_horarios" to "authenticated";

grant truncate on table "public"."stg_turmas_horarios" to "authenticated";

grant update on table "public"."stg_turmas_horarios" to "authenticated";

grant delete on table "public"."stg_turmas_horarios" to "service_role";

grant insert on table "public"."stg_turmas_horarios" to "service_role";

grant references on table "public"."stg_turmas_horarios" to "service_role";

grant select on table "public"."stg_turmas_horarios" to "service_role";

grant trigger on table "public"."stg_turmas_horarios" to "service_role";

grant truncate on table "public"."stg_turmas_horarios" to "service_role";

grant update on table "public"."stg_turmas_horarios" to "service_role";

grant delete on table "public"."tabela" to "anon";

grant insert on table "public"."tabela" to "anon";

grant references on table "public"."tabela" to "anon";

grant select on table "public"."tabela" to "anon";

grant trigger on table "public"."tabela" to "anon";

grant truncate on table "public"."tabela" to "anon";

grant update on table "public"."tabela" to "anon";

grant delete on table "public"."tabela" to "authenticated";

grant insert on table "public"."tabela" to "authenticated";

grant references on table "public"."tabela" to "authenticated";

grant select on table "public"."tabela" to "authenticated";

grant trigger on table "public"."tabela" to "authenticated";

grant truncate on table "public"."tabela" to "authenticated";

grant update on table "public"."tabela" to "authenticated";

grant delete on table "public"."tabela" to "service_role";

grant insert on table "public"."tabela" to "service_role";

grant references on table "public"."tabela" to "service_role";

grant select on table "public"."tabela" to "service_role";

grant trigger on table "public"."tabela" to "service_role";

grant truncate on table "public"."tabela" to "service_role";

grant update on table "public"."tabela" to "service_role";

grant delete on table "public"."tabela_datas_teste" to "anon";

grant insert on table "public"."tabela_datas_teste" to "anon";

grant references on table "public"."tabela_datas_teste" to "anon";

grant select on table "public"."tabela_datas_teste" to "anon";

grant trigger on table "public"."tabela_datas_teste" to "anon";

grant truncate on table "public"."tabela_datas_teste" to "anon";

grant update on table "public"."tabela_datas_teste" to "anon";

grant delete on table "public"."tabela_datas_teste" to "authenticated";

grant insert on table "public"."tabela_datas_teste" to "authenticated";

grant references on table "public"."tabela_datas_teste" to "authenticated";

grant select on table "public"."tabela_datas_teste" to "authenticated";

grant trigger on table "public"."tabela_datas_teste" to "authenticated";

grant truncate on table "public"."tabela_datas_teste" to "authenticated";

grant update on table "public"."tabela_datas_teste" to "authenticated";

grant delete on table "public"."tabela_datas_teste" to "service_role";

grant insert on table "public"."tabela_datas_teste" to "service_role";

grant references on table "public"."tabela_datas_teste" to "service_role";

grant select on table "public"."tabela_datas_teste" to "service_role";

grant trigger on table "public"."tabela_datas_teste" to "service_role";

grant truncate on table "public"."tabela_datas_teste" to "service_role";

grant update on table "public"."tabela_datas_teste" to "service_role";

grant delete on table "public"."textos_listas_selecao" to "anon";

grant insert on table "public"."textos_listas_selecao" to "anon";

grant references on table "public"."textos_listas_selecao" to "anon";

grant select on table "public"."textos_listas_selecao" to "anon";

grant trigger on table "public"."textos_listas_selecao" to "anon";

grant truncate on table "public"."textos_listas_selecao" to "anon";

grant update on table "public"."textos_listas_selecao" to "anon";

grant delete on table "public"."textos_listas_selecao" to "authenticated";

grant insert on table "public"."textos_listas_selecao" to "authenticated";

grant references on table "public"."textos_listas_selecao" to "authenticated";

grant select on table "public"."textos_listas_selecao" to "authenticated";

grant trigger on table "public"."textos_listas_selecao" to "authenticated";

grant truncate on table "public"."textos_listas_selecao" to "authenticated";

grant update on table "public"."textos_listas_selecao" to "authenticated";

grant delete on table "public"."textos_listas_selecao" to "service_role";

grant insert on table "public"."textos_listas_selecao" to "service_role";

grant references on table "public"."textos_listas_selecao" to "service_role";

grant select on table "public"."textos_listas_selecao" to "service_role";

grant trigger on table "public"."textos_listas_selecao" to "service_role";

grant truncate on table "public"."textos_listas_selecao" to "service_role";

grant update on table "public"."textos_listas_selecao" to "service_role";

grant delete on table "public"."tipo_produto" to "anon";

grant insert on table "public"."tipo_produto" to "anon";

grant references on table "public"."tipo_produto" to "anon";

grant select on table "public"."tipo_produto" to "anon";

grant trigger on table "public"."tipo_produto" to "anon";

grant truncate on table "public"."tipo_produto" to "anon";

grant update on table "public"."tipo_produto" to "anon";

grant delete on table "public"."tipo_produto" to "authenticated";

grant insert on table "public"."tipo_produto" to "authenticated";

grant references on table "public"."tipo_produto" to "authenticated";

grant select on table "public"."tipo_produto" to "authenticated";

grant trigger on table "public"."tipo_produto" to "authenticated";

grant truncate on table "public"."tipo_produto" to "authenticated";

grant update on table "public"."tipo_produto" to "authenticated";

grant delete on table "public"."tipo_produto" to "service_role";

grant insert on table "public"."tipo_produto" to "service_role";

grant references on table "public"."tipo_produto" to "service_role";

grant select on table "public"."tipo_produto" to "service_role";

grant trigger on table "public"."tipo_produto" to "service_role";

grant truncate on table "public"."tipo_produto" to "service_role";

grant update on table "public"."tipo_produto" to "service_role";

grant delete on table "public"."turma_etapa_anosemestre" to "anon";

grant insert on table "public"."turma_etapa_anosemestre" to "anon";

grant references on table "public"."turma_etapa_anosemestre" to "anon";

grant select on table "public"."turma_etapa_anosemestre" to "anon";

grant trigger on table "public"."turma_etapa_anosemestre" to "anon";

grant truncate on table "public"."turma_etapa_anosemestre" to "anon";

grant update on table "public"."turma_etapa_anosemestre" to "anon";

grant delete on table "public"."turma_etapa_anosemestre" to "authenticated";

grant insert on table "public"."turma_etapa_anosemestre" to "authenticated";

grant references on table "public"."turma_etapa_anosemestre" to "authenticated";

grant select on table "public"."turma_etapa_anosemestre" to "authenticated";

grant trigger on table "public"."turma_etapa_anosemestre" to "authenticated";

grant truncate on table "public"."turma_etapa_anosemestre" to "authenticated";

grant update on table "public"."turma_etapa_anosemestre" to "authenticated";

grant delete on table "public"."turma_etapa_anosemestre" to "service_role";

grant insert on table "public"."turma_etapa_anosemestre" to "service_role";

grant references on table "public"."turma_etapa_anosemestre" to "service_role";

grant select on table "public"."turma_etapa_anosemestre" to "service_role";

grant trigger on table "public"."turma_etapa_anosemestre" to "service_role";

grant truncate on table "public"."turma_etapa_anosemestre" to "service_role";

grant update on table "public"."turma_etapa_anosemestre" to "service_role";

grant delete on table "public"."turma_etapas" to "anon";

grant insert on table "public"."turma_etapas" to "anon";

grant references on table "public"."turma_etapas" to "anon";

grant select on table "public"."turma_etapas" to "anon";

grant trigger on table "public"."turma_etapas" to "anon";

grant truncate on table "public"."turma_etapas" to "anon";

grant update on table "public"."turma_etapas" to "anon";

grant delete on table "public"."turma_etapas" to "authenticated";

grant insert on table "public"."turma_etapas" to "authenticated";

grant references on table "public"."turma_etapas" to "authenticated";

grant select on table "public"."turma_etapas" to "authenticated";

grant trigger on table "public"."turma_etapas" to "authenticated";

grant truncate on table "public"."turma_etapas" to "authenticated";

grant update on table "public"."turma_etapas" to "authenticated";

grant delete on table "public"."turma_etapas" to "service_role";

grant insert on table "public"."turma_etapas" to "service_role";

grant references on table "public"."turma_etapas" to "service_role";

grant select on table "public"."turma_etapas" to "service_role";

grant trigger on table "public"."turma_etapas" to "service_role";

grant truncate on table "public"."turma_etapas" to "service_role";

grant update on table "public"."turma_etapas" to "service_role";

grant delete on table "public"."turmas" to "anon";

grant insert on table "public"."turmas" to "anon";

grant references on table "public"."turmas" to "anon";

grant select on table "public"."turmas" to "anon";

grant trigger on table "public"."turmas" to "anon";

grant truncate on table "public"."turmas" to "anon";

grant update on table "public"."turmas" to "anon";

grant delete on table "public"."turmas" to "authenticated";

grant insert on table "public"."turmas" to "authenticated";

grant references on table "public"."turmas" to "authenticated";

grant select on table "public"."turmas" to "authenticated";

grant trigger on table "public"."turmas" to "authenticated";

grant truncate on table "public"."turmas" to "authenticated";

grant update on table "public"."turmas" to "authenticated";

grant delete on table "public"."turmas" to "service_role";

grant insert on table "public"."turmas" to "service_role";

grant references on table "public"."turmas" to "service_role";

grant select on table "public"."turmas" to "service_role";

grant trigger on table "public"."turmas" to "service_role";

grant truncate on table "public"."turmas" to "service_role";

grant update on table "public"."turmas" to "service_role";

grant delete on table "public"."turmas_calendario" to "anon";

grant insert on table "public"."turmas_calendario" to "anon";

grant references on table "public"."turmas_calendario" to "anon";

grant select on table "public"."turmas_calendario" to "anon";

grant trigger on table "public"."turmas_calendario" to "anon";

grant truncate on table "public"."turmas_calendario" to "anon";

grant update on table "public"."turmas_calendario" to "anon";

grant delete on table "public"."turmas_calendario" to "authenticated";

grant insert on table "public"."turmas_calendario" to "authenticated";

grant references on table "public"."turmas_calendario" to "authenticated";

grant select on table "public"."turmas_calendario" to "authenticated";

grant trigger on table "public"."turmas_calendario" to "authenticated";

grant truncate on table "public"."turmas_calendario" to "authenticated";

grant update on table "public"."turmas_calendario" to "authenticated";

grant delete on table "public"."turmas_calendario" to "service_role";

grant insert on table "public"."turmas_calendario" to "service_role";

grant references on table "public"."turmas_calendario" to "service_role";

grant select on table "public"."turmas_calendario" to "service_role";

grant trigger on table "public"."turmas_calendario" to "service_role";

grant truncate on table "public"."turmas_calendario" to "service_role";

grant update on table "public"."turmas_calendario" to "service_role";

grant delete on table "public"."turmas_dias" to "anon";

grant insert on table "public"."turmas_dias" to "anon";

grant references on table "public"."turmas_dias" to "anon";

grant select on table "public"."turmas_dias" to "anon";

grant trigger on table "public"."turmas_dias" to "anon";

grant truncate on table "public"."turmas_dias" to "anon";

grant update on table "public"."turmas_dias" to "anon";

grant delete on table "public"."turmas_dias" to "authenticated";

grant insert on table "public"."turmas_dias" to "authenticated";

grant references on table "public"."turmas_dias" to "authenticated";

grant select on table "public"."turmas_dias" to "authenticated";

grant trigger on table "public"."turmas_dias" to "authenticated";

grant truncate on table "public"."turmas_dias" to "authenticated";

grant update on table "public"."turmas_dias" to "authenticated";

grant delete on table "public"."turmas_dias" to "service_role";

grant insert on table "public"."turmas_dias" to "service_role";

grant references on table "public"."turmas_dias" to "service_role";

grant select on table "public"."turmas_dias" to "service_role";

grant trigger on table "public"."turmas_dias" to "service_role";

grant truncate on table "public"."turmas_dias" to "service_role";

grant update on table "public"."turmas_dias" to "service_role";

grant delete on table "public"."turmas_dias_extra_calendario" to "anon";

grant insert on table "public"."turmas_dias_extra_calendario" to "anon";

grant references on table "public"."turmas_dias_extra_calendario" to "anon";

grant select on table "public"."turmas_dias_extra_calendario" to "anon";

grant trigger on table "public"."turmas_dias_extra_calendario" to "anon";

grant truncate on table "public"."turmas_dias_extra_calendario" to "anon";

grant update on table "public"."turmas_dias_extra_calendario" to "anon";

grant delete on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant insert on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant references on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant select on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant trigger on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant truncate on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant update on table "public"."turmas_dias_extra_calendario" to "authenticated";

grant delete on table "public"."turmas_dias_extra_calendario" to "service_role";

grant insert on table "public"."turmas_dias_extra_calendario" to "service_role";

grant references on table "public"."turmas_dias_extra_calendario" to "service_role";

grant select on table "public"."turmas_dias_extra_calendario" to "service_role";

grant trigger on table "public"."turmas_dias_extra_calendario" to "service_role";

grant truncate on table "public"."turmas_dias_extra_calendario" to "service_role";

grant update on table "public"."turmas_dias_extra_calendario" to "service_role";

grant delete on table "public"."user_email_audit" to "anon";

grant insert on table "public"."user_email_audit" to "anon";

grant references on table "public"."user_email_audit" to "anon";

grant select on table "public"."user_email_audit" to "anon";

grant trigger on table "public"."user_email_audit" to "anon";

grant truncate on table "public"."user_email_audit" to "anon";

grant update on table "public"."user_email_audit" to "anon";

grant delete on table "public"."user_email_audit" to "authenticated";

grant insert on table "public"."user_email_audit" to "authenticated";

grant references on table "public"."user_email_audit" to "authenticated";

grant select on table "public"."user_email_audit" to "authenticated";

grant trigger on table "public"."user_email_audit" to "authenticated";

grant truncate on table "public"."user_email_audit" to "authenticated";

grant update on table "public"."user_email_audit" to "authenticated";

grant delete on table "public"."user_email_audit" to "service_role";

grant insert on table "public"."user_email_audit" to "service_role";

grant references on table "public"."user_email_audit" to "service_role";

grant select on table "public"."user_email_audit" to "service_role";

grant trigger on table "public"."user_email_audit" to "service_role";

grant truncate on table "public"."user_email_audit" to "service_role";

grant update on table "public"."user_email_audit" to "service_role";

grant delete on table "public"."user_expandido" to "anon";

grant insert on table "public"."user_expandido" to "anon";

grant references on table "public"."user_expandido" to "anon";

grant select on table "public"."user_expandido" to "anon";

grant trigger on table "public"."user_expandido" to "anon";

grant truncate on table "public"."user_expandido" to "anon";

grant update on table "public"."user_expandido" to "anon";

grant delete on table "public"."user_expandido" to "authenticated";

grant insert on table "public"."user_expandido" to "authenticated";

grant references on table "public"."user_expandido" to "authenticated";

grant select on table "public"."user_expandido" to "authenticated";

grant trigger on table "public"."user_expandido" to "authenticated";

grant truncate on table "public"."user_expandido" to "authenticated";

grant update on table "public"."user_expandido" to "authenticated";

grant delete on table "public"."user_expandido" to "service_role";

grant insert on table "public"."user_expandido" to "service_role";

grant references on table "public"."user_expandido" to "service_role";

grant select on table "public"."user_expandido" to "service_role";

grant trigger on table "public"."user_expandido" to "service_role";

grant truncate on table "public"."user_expandido" to "service_role";

grant update on table "public"."user_expandido" to "service_role";

create policy "todos veem blocos"
on "public"."bloco_perguntas"
as permissive
for select
to authenticated
using (true);


create policy "admin pode tudo em cursos"
on "public"."curso"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "autenticados podem ver"
on "public"."curso"
as permissive
for select
to authenticated
using (true);


create policy "secretaria pode tudo"
on "public"."curso"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text));


create policy "todos veem"
on "public"."curso"
as permissive
for select
to public
using (true);


create policy "admin pode tudo em curso encontros"
on "public"."curso_encontros"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "autenticados podem ver curso_encontros"
on "public"."curso_encontros"
as permissive
for select
to authenticated
using (true);


create policy "secretaria pode tudo "
on "public"."curso_encontros"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text));


create policy "todos veem"
on "public"."curso_encontros"
as permissive
for select
to public
using (true);


create policy "admin_full_access_ficha_avaliacao"
on "public"."curso_ficha_avaliacao"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text, 'analista'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text, 'analista'::text])));


create policy "select_ficha_avaliacao_auth"
on "public"."curso_ficha_avaliacao"
as permissive
for select
to authenticated
using (true);


create policy "diario_admin_analistas_secretaria_all"
on "public"."diario"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])));


create policy "diario_anon_all_but_delete"
on "public"."diario"
as permissive
for all
to anon
using (true)
with check (true);


create policy "diario_docente_select"
on "public"."diario"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['docente'::text, 'docente_colaborador'::text])));


create policy "diario_estudante_select"
on "public"."diario"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'estudante'::text) AND (id_aluno IN ( SELECT ue.id
   FROM user_expandido ue
  WHERE (ue.user_id = auth.uid())))));


create policy "diario_controle_sync_admin_secretaria_analistas_all"
on "public"."diario_controle_sync"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])));


create policy "diario_controle_sync_anon_all_but_delete"
on "public"."diario_controle_sync"
as permissive
for all
to anon
using (true)
with check (true);


create policy "diario_controle_sync_docente_select"
on "public"."diario_controle_sync"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['docente'::text, 'docente_colaborador'::text])));


create policy "diario_sync_sessao_admin_all"
on "public"."diario_sync_sessao"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text])));


create policy "diario_sync_sessao_anon_all_but_delete"
on "public"."diario_sync_sessao"
as permissive
for all
to anon
using (true)
with check (true);


create policy "diario_sync_sessao_docente_select"
on "public"."diario_sync_sessao"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['docente'::text, 'docente_colaborador'::text])));


create policy "Admin e Secretaria completa na queue"
on "public"."email_queue"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Admin e Secretaria completa nas threads"
on "public"."email_threads"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "nao logado veem feriados"
on "public"."feriados"
as permissive
for select
to public
using (true);


create policy "Analistas podem ver matriculas"
on "public"."matriculas"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'analistas'::text));


create policy "Convidados podem ver matriculas"
on "public"."matriculas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text));


create policy "admin_secretaria_all_matriculas"
on "public"."matriculas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "anopodetudoaqui"
on "public"."matriculas"
as permissive
for all
to anon
using (true)
with check (true);


create policy "Leitura para autenticados"
on "public"."papeis_user"
as permissive
for select
to authenticated
using (true);


create policy "todos_veem_tudo"
on "public"."papeis_user"
as permissive
for select
to public
using (true);


create policy "Admin pode inserir user_auth"
on "public"."papeis_user_auth"
as permissive
for insert
to public
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "Producao pode inserir user_expandido com papel docente ou colab"
on "public"."papeis_user_auth"
as permissive
for all
to authenticated
with check ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (papel_id = ANY (ARRAY['5568548e-856c-4a2e-99f3-a2d7fe5a15e9'::uuid, '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid, '49c397b5-cbee-4967-ae4f-085644ad9414'::uuid]))));


create policy "Usuário pode se vincular a um papel"
on "public"."papeis_user_auth"
as permissive
for all
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "service role e anon podem tudo"
on "public"."papeis_user_auth"
as permissive
for all
to anon, service_role, postgres
using (true)
with check (true);


create policy "todos veem sem autenticacao"
on "public"."perguntas"
as permissive
for select
to public
using (true);


create policy "todos_veem_perguntas"
on "public"."perguntas"
as permissive
for select
to authenticated
using (true);


create policy "Admin / Analista / Secretaria podem atualizar perguntas"
on "public"."perguntas_avaliacao_processos"
as permissive
for update
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text])));


create policy "Admin / Analista / Secretaria podem deletar perguntas"
on "public"."perguntas_avaliacao_processos"
as permissive
for delete
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text])));


create policy "Admin / Analista / Secretaria podem inserir perguntas"
on "public"."perguntas_avaliacao_processos"
as permissive
for insert
to authenticated
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text])));


create policy "Admin / Analista / Secretaria podem ver perguntas"
on "public"."perguntas_avaliacao_processos"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text])));


create policy "Todos autenticados podem ver documentos obrigatórios"
on "public"."processo_documentos_obrigatorios"
as permissive
for select
to authenticated
using (true);


create policy "ANALISTAS SECRETARIA ADMIN PODEM TUDO "
on "public"."processos"
as permissive
for all
to public
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analistas'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])));


create policy "Usuário pode criar seu próprio processo"
on "public"."processos"
as permissive
for insert
to authenticated
with check ((user_id = auth.uid()));


create policy "Usuário pode ver seus próprios processos"
on "public"."processos"
as permissive
for select
to authenticated
using ((user_id = auth.uid()));


create policy "processos_todos_veem"
on "public"."processos_antigos"
as permissive
for select
to public
using (true);


create policy "Admin e Producao podem tudo em produto avarias"
on "public"."produto_avarias"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e Producao podem tudo em produto_categoria"
on "public"."produto_categoria"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e Producao podem tudo em produto_estoque"
on "public"."produto_estoque"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e Producao podem tudo em produto_kit"
on "public"."produto_kit"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e Producao podem tudo em produto_reservas"
on "public"."produto_reservas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Papeis especificos veem suas proprias reservas"
on "public"."produto_reservas"
as permissive
for all
to authenticated
using (((auth.uid() = auth_user_id) AND ((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['docente'::text, 'outro_papel'::text]))))
with check (((auth.uid() = auth_user_id) AND ((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['docente'::text, 'outro_papel'::text]))));


create policy "todos_veem_tipo_avaria"
on "public"."produto_tipo_avaria"
as permissive
for select
to public
using (true);


create policy "Admin e Producao podem tudo em produto_unidade"
on "public"."produto_unidade"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e Producao podem tudo em produtos"
on "public"."produtos"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin pode tudo em professor_turma_atribuicao"
on "public"."professor_turma_atribuicao"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "Docente gerencia seus dados em professor_turma_atribuicao"
on "public"."professor_turma_atribuicao"
as permissive
for all
to authenticated
using ((auth_id = auth.uid()))
with check ((auth_id = auth.uid()));


create policy "Secretaria pode tudo em professor_turma_atribuicao"
on "public"."professor_turma_atribuicao"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text));


create policy "Analistas Secretaria podem ver ra_alunos"
on "public"."ra_alunos"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['analistas'::text, 'secretaria'::text])));


create policy "admin_all_ra_alunos"
on "public"."ra_alunos"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "anopodetudoaqui"
on "public"."ra_alunos"
as permissive
for all
to anon, service_role
using (true)
with check (true);


create policy "Analistas podem ver respostas dos alunos/candidatos"
on "public"."respostas"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'analistas'::text) AND (EXISTS ( SELECT 1
   FROM user_expandido ue
  WHERE ((ue.id = respostas.id_usuario) AND (ue.papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid])))))));


create policy "Convidados podem atualizar apenas a resposta da pergunta de fot"
on "public"."respostas"
as permissive
for update
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid)))
with check ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (id_pergunta = 'c95e476a-c4dc-4520-badd-d7392b0aeab7'::uuid)));


create policy "Convidados podem ver respostas dos alunos/candidatos"
on "public"."respostas"
as permissive
for all
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (EXISTS ( SELECT 1
   FROM user_expandido ue
  WHERE ((ue.id = respostas.id_usuario) AND (ue.papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid])))))));


create policy "Coordenadores podem ver estudantes e analistas"
on "public"."respostas"
as permissive
for select
to public
using ((((auth.jwt() ->> 'papeis_user'::text) = 'coordenadores'::text) AND (EXISTS ( SELECT 1
   FROM user_expandido ue
  WHERE ((ue.id = respostas.id_usuario) AND (ue.papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid])))))));


create policy "Curadores podem ver estudantes e candidatos"
on "public"."respostas"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'curadores'::text) AND (EXISTS ( SELECT 1
   FROM user_expandido ue
  WHERE ((ue.id = respostas.id_usuario) AND (ue.papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid])))))));


create policy "Editar respostas próprias"
on "public"."respostas"
as permissive
for update
to authenticated
using ((id_usuario = auth.uid()));


create policy "Inserir resposta"
on "public"."respostas"
as permissive
for insert
to authenticated
with check ((id_usuario = auth.uid()));


create policy "Usuário pode deletar sua própria resposta"
on "public"."respostas"
as permissive
for delete
to authenticated
using ((id_usuario = auth.uid()));


create policy "Ver respostas próprias"
on "public"."respostas"
as permissive
for select
to authenticated
using ((id_usuario = auth.uid()));


create policy "admin_secretaria_all"
on "public"."respostas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "producao pode ver alunos"
on "public"."respostas"
as permissive
for select
to public
using ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (EXISTS ( SELECT 1
   FROM user_expandido ue
  WHERE ((ue.id = respostas.id_usuario) AND (ue.papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid])))))));


create policy "todos_veem_perguntas_com_service_role"
on "public"."respostas"
as permissive
for select
to public
using (true);


create policy "Admin / Analista / Secretaria / Curadores / Coordenadores podem"
on "public"."respostas_perguntas_avaliacao_processos"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])));


create policy "Admin / Analista / Secretaria podem atualizar respostas"
on "public"."respostas_perguntas_avaliacao_processos"
as permissive
for update
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])));


create policy "Admin / Analista / Secretaria podem deletar respostas"
on "public"."respostas_perguntas_avaliacao_processos"
as permissive
for delete
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])));


create policy "Admin / Analista / Secretaria podem inserir respostas"
on "public"."respostas_perguntas_avaliacao_processos"
as permissive
for insert
to authenticated
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'analista'::text, 'secretaria'::text, 'curadores'::text, 'coordenadores'::text])));


create policy "Admin e Producao Analistas Asistentes e Coordenadores podem tud"
on "public"."sala"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])));


create policy "autenticados_podem_ver_salas"
on "public"."sala"
as permissive
for select
to authenticated
using (true);


create policy "admin pode tudo em sala_reservas"
on "public"."sala_reservas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "auth pode ver sala_reservas"
on "public"."sala_reservas"
as permissive
for select
to authenticated
using (true);


create policy "producao analistas assistentes coordenadores  pode tudo em sala"
on "public"."sala_reservas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])));


create policy "admin pode tudo em salas_horarios"
on "public"."salas_horarios"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "auth pode ver salas_horarios"
on "public"."salas_horarios"
as permissive
for select
to authenticated
using (true);


create policy "producao analistas assistentes coordenadores pode tudo em salas"
on "public"."salas_horarios"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['producao'::text, 'analistas'::text, 'assistentes'::text, 'coordenadores'::text])));


create policy "Todos autenticados podem ver slot_horarios"
on "public"."slot_horarios"
as permissive
for select
to authenticated
using (true);


create policy "tabela select só admin"
on "public"."tabela"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text));


create policy "datas_pol"
on "public"."tabela_datas_teste"
as permissive
for all
to public
using (true)
with check (true);


create policy "abalistas podem tudo "
on "public"."textos_listas_selecao"
as permissive
for all
to public
using (((auth.jwt() ->> 'papeis_user'::text) = 'analistas'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'analistas'::text));


create policy "amdin pode tudo "
on "public"."textos_listas_selecao"
as permissive
for all
to public
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "secretaria pode tudo"
on "public"."textos_listas_selecao"
as permissive
for all
to public
using (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'secretaria'::text));


create policy "todos veem"
on "public"."textos_listas_selecao"
as permissive
for select
to authenticated
using (true);


create policy "Admin e Producao podem tudo em tipo_produto"
on "public"."tipo_produto"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'producao'::text])));


create policy "Admin e secretaria podem gerenciar turma_etapa_anosemestre"
on "public"."turma_etapa_anosemestre"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Todos autenticados podem ver turma_etapa_anosemestre"
on "public"."turma_etapa_anosemestre"
as permissive
for select
to authenticated
using (true);


create policy "Admin e secretaria podem gerenciar turma_etapas"
on "public"."turma_etapas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Todos autenticados podem ver turma_etapas"
on "public"."turma_etapas"
as permissive
for select
to authenticated
using (true);


create policy "Admin acesso total"
on "public"."turmas"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text))
with check (((auth.jwt() ->> 'papeis_user'::text) = 'admin'::text));


create policy "Leitura pública para todos"
on "public"."turmas"
as permissive
for select
to public
using (true);


create policy "Liberar updates via service_role"
on "public"."turmas"
as permissive
for update
to public
using (true)
with check (true);


create policy "Qualquer um pode inserir turmas (usado pelo service_role)"
on "public"."turmas"
as permissive
for insert
to public
with check (true);


create policy "Todos autenticados podem ver turmas"
on "public"."turmas"
as permissive
for select
to authenticated
using (true);


create policy "Admin e secretaria podem gerenciar turmas_calendario"
on "public"."turmas_calendario"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Todos autenticados podem ver turmas_calendario"
on "public"."turmas_calendario"
as permissive
for select
to authenticated
using (true);


create policy "todos veem"
on "public"."turmas_dias"
as permissive
for select
to public
using (true);


create policy "Admin e secretaria podem gerenciar dias extra"
on "public"."turmas_dias_extra_calendario"
as permissive
for all
to authenticated
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Todos autenticados podem ver dias extra"
on "public"."turmas_dias_extra_calendario"
as permissive
for select
to authenticated
using (true);


create policy "Admin e Secretaria pode atualizar user_expandido"
on "public"."user_expandido"
as permissive
for update
to public
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])))
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Admin e secretaria pode deletar user_expandido"
on "public"."user_expandido"
as permissive
for delete
to public
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Admin e secretaria pode inserir user_expandido"
on "public"."user_expandido"
as permissive
for insert
to public
with check (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Admin e secretaria pode ver user_expandido"
on "public"."user_expandido"
as permissive
for select
to public
using (((auth.jwt() ->> 'papeis_user'::text) = ANY (ARRAY['admin'::text, 'secretaria'::text])));


create policy "Analistas podem ver user_expandido com papel aluno ou candidato"
on "public"."user_expandido"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'analistas'::text) AND (papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid]))));


create policy "Convidados podem atualizar apenas estudantes"
on "public"."user_expandido"
as permissive
for update
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (papel_id = '9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid)))
with check ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (papel_id = '9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid)));


create policy "Coordenadores podem ver candidatos e estudantes"
on "public"."user_expandido"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'coordenadores'::text) AND (papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid]))));


create policy "Curadores podem ver candidatos e estudantes"
on "public"."user_expandido"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'curadores'::text) AND (papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid]))));


create policy "Prod pode ver us_exp docent,doc_col,prod,aluno"
on "public"."user_expandido"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (papel_id = ANY (ARRAY['5568548e-856c-4a2e-99f3-a2d7fe5a15e9'::uuid, '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid, '49c397b5-cbee-4967-ae4f-085644ad9414'::uuid, '9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid]))));


create policy "Producao pode editar user_expandido com papel docente ou colabo"
on "public"."user_expandido"
as permissive
for update
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (papel_id = ANY (ARRAY['5568548e-856c-4a2e-99f3-a2d7fe5a15e9'::uuid, '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid, '49c397b5-cbee-4967-ae4f-085644ad9414'::uuid]))))
with check ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (papel_id = ANY (ARRAY['5568548e-856c-4a2e-99f3-a2d7fe5a15e9'::uuid, '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid, '49c397b5-cbee-4967-ae4f-085644ad9414'::uuid]))));


create policy "Producao pode inserir user_expandido com papel docente ou colab"
on "public"."user_expandido"
as permissive
for insert
to authenticated
with check ((((auth.jwt() ->> 'papeis_user'::text) = 'producao'::text) AND (papel_id = ANY (ARRAY['5568548e-856c-4a2e-99f3-a2d7fe5a15e9'::uuid, '8f3d1cd3-75fd-4549-b4ea-2b2e1411c2ec'::uuid, '49c397b5-cbee-4967-ae4f-085644ad9414'::uuid]))));


create policy "Usuário pode tudo com ele mesmo"
on "public"."user_expandido"
as permissive
for all
to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));


create policy "convidados podem ver estudantes"
on "public"."user_expandido"
as permissive
for select
to authenticated
using ((((auth.jwt() ->> 'papeis_user'::text) = 'convidados'::text) AND (papel_id = ANY (ARRAY['9a33b6e1-13ae-4029-85f9-ec02fba4b5f2'::uuid, 'd19ba89e-9a15-4194-929a-db47695fb2be'::uuid]))));


create policy "service_role_pode_inserir"
on "public"."user_expandido"
as permissive
for all
to service_role, anon
using (true)
with check (true);


CREATE TRIGGER trg_curso_ficha_avaliacao_updated BEFORE UPDATE ON public.curso_ficha_avaliacao FOR EACH ROW EXECUTE FUNCTION trg_set_updated_at_curso_ficha();

CREATE TRIGGER trg_diario_after_change AFTER INSERT OR UPDATE ON public.diario FOR EACH ROW EXECUTE FUNCTION trg_diario_sync();

CREATE TRIGGER trg_diario_consistency BEFORE INSERT OR UPDATE ON public.diario FOR EACH ROW EXECUTE FUNCTION trg_diario_maintain_consistency();

CREATE TRIGGER mandar_email_lote AFTER UPDATE ON public.email_threads FOR EACH ROW EXECUTE FUNCTION supabase_functions.http_request('https://zonnvyzcstlntcfztyan.supabase.co/functions/v1/enviar_email_secretaria_lote', 'POST', '{"Content-type":"application/json","Authorization":"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inpvbm52eXpjc3RsbnRjZnp0eWFuIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0Mjg0MDk0MSwiZXhwIjoyMDU4NDE2OTQxfQ.J3SuPkEk3dSjrRDvYsrp9HATZ3rkv-gdEw5OyJmfIfA"}', '{}', '5000');

CREATE TRIGGER trg_fila_email AFTER INSERT ON public.email_threads FOR EACH ROW EXECUTE FUNCTION par_trg_fila_email();

CREATE TRIGGER trg_gerar_ra_matricula AFTER INSERT ON public.matriculas FOR EACH ROW EXECUTE FUNCTION fn_gerar_ra_matricula();

CREATE TRIGGER trg_update_perg_avaliacao BEFORE UPDATE ON public.perguntas_avaliacao_processos FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp_perg_avaliacao();

CREATE TRIGGER trg_processos_modificado BEFORE INSERT OR UPDATE ON public.processos FOR EACH ROW EXECUTE FUNCTION trg_processos_set_modificado();

CREATE TRIGGER trg_processos_preencher_ux BEFORE INSERT OR UPDATE ON public.processos FOR EACH ROW EXECUTE FUNCTION perguntas_preencher_id_user_expandido_auth();

CREATE TRIGGER trigger_novo_processo AFTER INSERT ON public.processos FOR EACH ROW EXECUTE FUNCTION notificar_processo_enviado();

CREATE TRIGGER trg_estoque_ad AFTER DELETE ON public.produto_estoque FOR EACH ROW EXECUTE FUNCTION trg_estoque_after_delete();

CREATE TRIGGER trg_estoque_ai AFTER INSERT ON public.produto_estoque FOR EACH ROW EXECUTE FUNCTION trg_estoque_after_insert();

CREATE TRIGGER trg_reservas_aud AFTER INSERT OR DELETE OR UPDATE ON public.produto_reservas FOR EACH ROW EXECUTE FUNCTION trg_reservas_status();

CREATE TRIGGER trg_gerar_ra BEFORE INSERT ON public.ra_alunos FOR EACH ROW EXECUTE FUNCTION fn_gerar_ra();

CREATE TRIGGER trg_atualiza_imagem_user AFTER INSERT OR UPDATE ON public.respostas FOR EACH ROW EXECUTE FUNCTION trg_atualiza_imagem_user();

CREATE TRIGGER trg_respostas_preencher_usuario_auth BEFORE INSERT OR UPDATE ON public.respostas FOR EACH ROW EXECUTE FUNCTION dados_preencher_id_usuario();

CREATE TRIGGER trg_respostas_preencher_ux BEFORE INSERT OR UPDATE ON public.respostas FOR EACH ROW EXECUTE FUNCTION perguntas_preencher_id_user_expandido_auth();

CREATE TRIGGER trg_stg_matriculas_set_flags BEFORE INSERT OR UPDATE OF email_aluno, codigo_turma ON public.stg_matriculas FOR EACH ROW EXECUTE FUNCTION stg_matriculas_set_flags();

CREATE TRIGGER trg_textos_listas_selecao BEFORE UPDATE ON public.textos_listas_selecao FOR EACH ROW EXECUTE FUNCTION fg_update_textos_listas_selecao();

CREATE TRIGGER trg_sync_link_video_processo AFTER INSERT OR UPDATE OF link_video ON public.turmas FOR EACH ROW EXECUTE FUNCTION fn_sync_link_video_processo();

CREATE TRIGGER trg_turmas_calendario_set_data BEFORE INSERT OR UPDATE ON public.turmas_calendario FOR EACH ROW EXECUTE FUNCTION fn_turmas_calendario_set_data();

CREATE TRIGGER trg_update_turmas_dias_extra BEFORE UPDATE ON public.turmas_dias_extra_calendario FOR EACH ROW EXECUTE FUNCTION fn_update_timestamp_turmas_dias_extra();

CREATE TRIGGER trg_vincular_papel AFTER INSERT ON public.user_expandido FOR EACH ROW EXECUTE FUNCTION trigger_vincular_papel();


